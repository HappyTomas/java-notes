1. Chapter 1 Spring Basics
- 总而言之 (ch1 and ch2 spring basics and configuration)
1) 5 typles of application Context： AnnotationConfigApplicationContext/AnnotationConfigWebApplicationContext are for loading Java config class. ClassPathXmlApplicationContext/FileSystemXmlApplicationContext/XmlWebApplicationContext are for loading xml config files.
2) 3 ways of wiring beans: perfer autodiscovery > java config > xml
3) @Configuration == applicationContext.xml
4) @Bean == <bean id="knight" class="com.springinaction.knights.BraveKnight">
5) @Bean method operation == <property>, <constructor-arg>, <p:>...
6) @ComponentScan(basePackages={"soundsystem", "video"}) == <conext:component-scan base-packages="soundsystem, video"/>
7) @EnableAspectJAutoProxy == <aop:aspectj-autoproxy /> //enable @Aspect @pointcut ....
8) In test class: @ContextConfiguration(classes=KnightConfig.class) == @ContextConfiguration(locations="classpath:knight.xml")
9) Java config imports other config: @Configuration @Import(CDPlayerConfig.class) @ImportResource("classpath:cd-config.xml")
10) xml config imports other config: <import resource="cd-config.xml" /> <bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
Web Tier
11) SpittrWebAppInitializer = the spring dispatcher servlet and contextListener config in web.xml
public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer
12) WebConfig == dispatcherServlet-context.xml
13) RootConfig == root-context.xml
14) @PropertySource("classpath:/com/soundsystem/app.properties") = <context:property-placeholder location="com/soundsystem/app.properties" />;  
15) DefaultServletHandler = <mvc:resources mapping ="/resources/**" location="/resources/"/> //but use different approach
16) @EnableWebMvc == <mvc:annotation-driven/>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Injecting object with xml
<bean id="knight" class="com.springinaction.knights.BraveKnight">
	<constructor-arg ref="quest" />
</bean>

#Injecting static class
<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
	<constructor-arg value="#{T(System).out}" />
</bean>

#Injecting with java config, more natural
@Configuration
public class KnightConfig {
	@Bean
	public Knight knight() {
		return new BraveKnight(quest());
	}
	@Bean
	public Quest quest() {
		return new SlayDragonQuest(System.out);
	}
}

# uses the application context as a factory to retrieve the bean whose ID is knight.
Knight knight = context.getBean(Knight.class);
Knight knight = (Knight) context.getBean("knight"); //equivalence in spring3

#Application Context
- AnnotationConfigApplicationContext: Loads an application context from Java-based configuration classes (new in S4)
- AnnotationConfigWebApplicationContext:Loads a web application context from Java-based configuration classes (new in S4)
- ClassPathXmlApplicationContext: Loads a context definition from one or more XML files located in the classpath, treating context-definition files as classpath resources
- FileSystemXmlApplicationContext: Loads a context definition from one or more XML files in the filesystem
- XmlWebApplicationContext: Loads context definitions from one or more XML files contained in a web application

#AnnotationConfigApplicationContext
ApplicationContext context = new AnnotationConfigApplicationContext(KnightConfig.class);

2. Chapter 2 Wiring bean
#options
- XML
- Java config
- autowiring and auto-discovery

#mix-and-match, best practice is auto->java->xml
- so you could choose XML to wire up some beans, use Spring’s Java-based configuration (JavaConfig) for other beans, and let other beans be automatically discovered by Spring. 
- use automatic configuration as much as you can. 
- When you must explicitly configure beans (such as when you’re configuring beans for which you don’t maintain the source code), prefer type-safe and more powerful JavaConfig over XML.
- fall back on XML only in situations where there’s a convenient XML namespace you want to use that has no equivalent in JavaConfig.

#Component scanning + Autowiring
@Configuration
@ComponentScan
public class CDPlayerConfig {
}

@Configuration
@ComponentScan(excludeFilters={@Filter(type=FilterType.ANNOTATION, value=Configuration.class)})
public class ComponentScannedConfig {

}

@Component
public class CDPlayer implements MediaPlayer {}
@Component
public class SgtPeppers implements CompactDisc {}
@Autowire
public CDPlayer(CompactDisc cd) {
    this.cd = cd;
}

#JUnit Test
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {
...
}

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:META-INF/spring/soundsystem.xml")
public class CDPlayerXMLConfigTest {
...
}

#Naming a component-scanned bean
- by default, the annotated bean is given an ID lowercasing the first letter of the class name
- provide a differnt name
@Component("lonelyHeartsClub")

#Setting a base package for component scanning
@Configuration
@ComponentScan("soundsystem")
public class CDPlayerConfig {}

@Configuration
@ComponentScan(basePackages="soundsystem")
public class CDPlayerConfig {}

- scan multiple packages 
@Configuration
@ComponentScan(basePackages={"soundsystem", "video"}) //scan for beans in soundsystem and video packages
public class CDPlayerConfig {}

- specifying them via classes or interfaces that are in the packages:
@Configuration
//scan for beans of packages in where CDPlayer and DVDPlayer resides 
@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class}) 
public class CDPlayerConfig {}

#Java Config
- bean wiring through @bean method
@Configuration
public class CDPlayerConfig {  
  @Bean
  public CompactDisc sgtPeppers() {
    return new SgtPeppers();
  }

  @Bean
  public CDPlayer cdPlayer() {
    return new CDPlayer(sgtPeppers());
  }
}
- bean wiring through constructor
public class CDPlayerConfig {  
  @Bean
  public CompactDisc compactDisc() {
    return new SgtPeppers();
  }  
  @Bean
  public CDPlayer cdPlayer(CompactDisc compactDisc) { 
    return new CDPlayer(compactDisc);
  }  
}
- When Spring calls cdPlayer() to create the CDPlayer bean, it autowires a CompactDisc into the configuration method.
- This approach to referring to other beans is usually the best choice because it doesn’t depend on the CompactDisc bean being declared in the same configuration class. it can even be defined in defined xml.

#Referencing XML configuration in JavaConfig
- Java Config import other java config
@Configuration
@Import(CDConfig.class)
public class CDPlayerConfig {
	...
}

- Main Java Config import sub java configs
@Configuration
@Import({CDPlayerConfig.class, CDConfig.class})
public class SoundSystemConfig {
}

- Java Config importing xml config
@Configuration
@Import(CDPlayerConfig.class)
@ImportResource("classpath:cd-config.xml")
public class SoundSystemConfig {
}

- test config
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=SoundSystemConfig.class)
public class ImportXmlConfigTest {
}

#Referencing JavaConfig in XML configuration
- xml config imports other xml config
<import resource="cd-config.xml" />

- xml config import java config, define a bean in xml
<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />

- test
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:cdplayer-config.xml")
public class ImportJavaConfigTest {
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

3. Chapter3 - Advanced wiring
- 总而言之，(Profile)
1） @Profile("dev/prod") specifies different configuration for different environment. only beans in active profile will be created.
2) values of spring.profiles.active and spring.profiles.default defines the active profiles. spring.profiles.active has higher priority.
3) values of spring.profiles.active and spring.profiles.default can be retrieved from 1) initialization parameters of DispatcherServlet,2)context parameters of a web application, 3)JNDI entries, 4)environment variables 5)JVM system properties 6)@ActiveProfiles annotation on test class
4) Usually, spring.profiles.default is set to dev in DispatcherServlet so that development can download and use dev config, in qa/prod, qa/operation team can use env variables or JNDI entry to configure spring.profiles.active to qa/prod.

<<<<<<<<<<<<<<<<<<<<<<<<<<
#Environments and profiles
- the beans in this configuration class should be created only if the dev profile is active. If the dev profile isn’t active, then the @Bean methods will be ignored.
@Configuration
@Profile("dev")
public class DevelopmentProfileConfig {
	@Bean...
}

@Configuration
@Profile("prod")
public class ProductionProfileConfig {
	@Bean...
}

- bean level profile config
@Configuration
public class DataSourceConfig {
@Bean(destroyMethod="shutdown")
@Profile("dev")
public DataSource embeddedDataSource() {
...
}
@Bean
@Profile("prod")
public DataSource jndiDataSource() {
...
}

#CONFIGURING PROFILES IN XML
- option1, setup different xml files for different profiles
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
...
http://www.springframework.org/schema/beans/spring-beans.xsd"
profile="dev">

- optional2. all profiles in a single xml
<beans profile="dev">
	<bean id="dataSource"
	class="org.apache.commons.dbcp.BasicDataSource"
	destroy-method="close"
	.../>
</beans>
<beans profile="qa">

</beans>
<beans profile="prod">
...
</beans>

#Activating profiles
- two separate properties when determining which profiles are active: spring.profiles.active and spring.profiles.default.
- ways to set these properties:
As initialization parameters on DispatcherServlet
As context parameters of a web application
As JNDI entries
As environment variables
As JVM system properties
Using the @ActiveProfiles annotation on an integration test class

- In web.xml, for context listener
<context-param>
	<param-name>spring.profiles.default</param-name>
	<param-value>dev</param-value>
</context-param>

- for context listener 
<init-param>
	<param-name>spring.profiles.default</param-name>
	<param-value>dev</param-value>
</init-param>

- In qa/production, set spring.profiles.active using system properties, environment variables, or JNDI as appropriate.

#TESTING WITH PROFILES
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes={PersistenceTestConfig.class})
@ActiveProfiles("dev")
public class PersistenceTest {
...
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Conditional Bean
@Bean
@Conditional(MagicExistsCondition.class)
public MagicBean magicBean() {
	return new MagicBean();
}

- MagicExistsCondition need to be implemented

#Addressing ambiguity in autowiring
- Spring tries byName first, if fails, tries byType
- Designating a primary bean
- by component scanning
@Component
@Primary
public class IceCream implements Dessert

- in java Configuration
@Bean
@Primary
public Dessert iceCream() {
	return new IceCream();
}

in XML
<bean id="iceCream" class="com.desserteater.IceCream primary="true" />

#Qualifying autowired beans
@Autowired
@Qualifier("iceCream")
public void setDessert(Dessert dessert) {
	this.dessert = dessert;
}

- use "cold" decouple IceCream class name
@Component
@Qualifier("cold")
public class IceCream implements Dessert { ... }

@Autowired
@Qualifier("cold")
public void setDessert(Dessert dessert) {
	this.dessert = dessert;
}

DEFINING CUSTOM QUALIFIER ANNOTATIONS
- define @creamy qualifier
@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,
ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Creamy { }

- define @cold qualifier
@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,
ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Cold { }

-apply @cold and @creamy to component
@Component
@Cold
@Creamy
public class IceCream implements Dessert { ... }

- autowired with @cold and @creamy annotation
@Autowired
@Cold
@Creamy
public void setDessert(Dessert dessert) {
	this.dessert = dessert;
}

#Bean scoping
- Singleton/Prototype/Session/Request

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class Notepad { ... }

@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Notepad notepad() {
	return new Notepad();
}
==
<bean id="notepad" class="com.myapp.Notepad" scope="prototype" />

@Component
@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)
public ShoppingCart cart() { ... }

#CGLib
if ShoppingCart is a concrete class, there’s no way Spring can create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy.

- session bean definition in xml
<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
	<aop:scoped-proxy />
</bean>

- generate an interface-based proxy by setting the proxy-target-class attribute to false:
<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
	<aop:scoped-proxy proxy-target-class="false" />
</bean>

#Runtime value injection
- by property placeholders
- by SpEL

#Injecting external values <Test> <Test Done>
- 总而言之，Injecting external values
there are 4 ways to inject external values:
1) declare a property source and retrieve the properties via the Spring Environment. @PropertySource("classpath:app.properties"), @Autowired
Environment env, env.getProperty("disc.title").
2) RESOLVING PROPERTY PLACEHOLDERS from external properties files. 
2.1) Config properties files: in xml: <context:property-placeholder location="com/soundsystem/app.properties" />;  in java config: @PropertySource("classpath:/com/soundsystem/app.properties"), same as #1.
2.2）declare a PropertySourcesPlaceholderConfigurer bean if using java config
2.3) Access property value: in xml: c:_title="${disc.title}"; in java: @Value("${disc.title}") String title
3) retrieves value from systemProperties or systemEnvironment: @Value("#{systemProperties.myFavoriteSong}")
4) retrieve value from properties file using SpEL, In context xml: <util:properties id="s3Properties" location="classpath:s3.properties"/>
@Value("#{s3Properties['webRootPath']}") <Test> <Test Failed>
5) @PropertySource can be configured in WebConfig or RootConfig and there is no difference
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- The simplest way to resolve external values in Spring is to declare a property source and retrieve the properties via the Spring Environment.
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties") //This properties file is loaded into Spring’s Environment, from which it can be retrieved later.
public class ExpressiveConfig {
	@Autowired
	Environment env;
	
	@Bean
	public BlankDisc disc() {
		return new BlankDisc(
			env.getProperty("disc.title"),
			env.getProperty("disc.artist"));
	}
}
- app.properties. 
disc.title=Sgt. Peppers Lonely Hearts Club Band
disc.artist=The Beatles
- String getProperty(String key)
- String getProperty(String key, String defaultValue)
- T getProperty(String key, Class<T> type) //get Integer
- T getProperty(String key, Class<T> type, T defaultValue)

@Bean
public BlankDisc disc() {
	return new BlankDisc(
		env.getProperty("disc.title", "Rattle and Hum"),
		env.getProperty("disc.artist", "U2"));
}

int connectionCount = env.getProperty("db.connection.count", Integer.class, 30);

#RESOLVING PROPERTY PLACEHOLDERS
- Spring has always supported the option of externalizing properties into a properties file and then plugging them into Spring beans using placeholder values. In Spring wiring, placeholder values are property names wrapped with ${ ... }.
- xml config:
<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="${disc.title}" c:_artist="${disc.artist}" />
- you can use the @Value annotation in much the same way as you might use the @Autowired annotation.
public BlankDisc(
	@Value("${disc.title}") String title,
	@Value("${disc.artist}") String artist) {
	this.title = title;
	this.artist = artist;
}

- In Java config
- In order to use placeholder values, you must configure either a PropertyPlaceholderConfigurer bean or a PropertySourcesPlaceholderConfigurer bean. Starting with Spring 3.1, PropertySourcesPlaceholderConfigurer is preferred because it resolves placeholders against the Spring Environment and its set of property sources.
@Configuration
@ComponentScan
@PropertySource("classpath:/com/soundsystem/app.properties")
public class PropertiesConfig {
    @Bean
    public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
        return new PropertySourcesPlaceholderConfigurer();
    }
}

- In XML
<context:property-placeholder location="com/soundsystem/app.properties" />
- the <context:property-placeholder> element from Spring’s context namespace will give you a PropertySourcesPlaceholderConfigurer bean
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#SpEL
#{T(System).currentTimeMillis()}
#{systemProperties['disc.title']}
#{sgtPeppers}
#{sgtPeppers.artist}
#{artistSelector.selectArtist()}
#{artistSelector.selectArtist().toUpperCase()}
#{artistSelector.selectArtist()?.toUpperCase()}
#{jukebox.songs.?[artist eq 'Aerosmith']}
#{jukebox.songs.![title]}
#{jukebox.songs.^[artist eq 'Aerosmith']}
#{jukebox.songs.?[artist eq 'Aerosmith'].![title]}

4. Chapter4 Aop
#@EnableAspectJAutoProxy
- If you’re using JavaConfig, you can turn on auto-proxying by applying the @EnableAspectJAutoProxy annotation at the class level of the configuration class.
@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class ConcertConfig {
	@Bean
	public Audience audience() {
		return new Audience();
	}
}
== 
in xml congfig
<context:component-scan base-package="concert" />
<aop:aspectj-autoproxy />
<bean class="concert.Audience" />

5. Chapter5 Spring MVC mechanism
#CONFIGURING DISPATCHERSERVLET
- thanks to recent advances in the Servlet 3 specification and in Spring 3.1. Instead of a web.xml file, you can use Java to configure DispatcherServlet in the servlet container.
public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { // Configure spring Context == loading web.xml
	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };	// Map DispatcherServlet to / (== configure DispatcherServlet mapping <servlet-mapping> in xml)
	}
	
	@Override
	protected Class<?>[] getRootConfigClasses() {
		return new Class<?>[] { RootConfig.class }; 			//Specify contextLoaderListener context configuration class  						
																	== loading classpath:datasource-context-jdbcDaoSupport.xml
	}
	
	@Override
	protected Class<?>[] getServletConfigClasses() {
		return new Class<?>[] { WebConfig.class };	//Specify disptacherServlet context configuration class == laoding spitter-context.xml
	}
}

- 总而言之 (Spring MVC Java Configuration)
1. any class that extends AbstractAnnotationConfigDispatcherServletInitializer will automatically be used to configure 1)DispatcherServlet and 2)the Spring application context in the application’s servlet context.
2. AbstractAnnotationConfigDispatcherServletInitializer creates both a DispatcherServlet and a ContextLoaderListener. 
public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer
3. SpittrWebAppInitializer == the spring dispatcher servlet and contextlistener config in web.xml
4. getServletMappings() identifies one or more paths that DispatcherServlet will be mapped to. In this case, it’s mapped to /, indicating that it will be the application’s default servlet. It will handle all requests coming into the application.
4. @Configuration classes returned from getServletConfigClasses() will define beans for DispatcherServlet’s application context. 
- WebConfig == dispatcherServlet-context.xml
5. the @Configuration class’s returned getRootConfigClasses() will be used to configure the application context created by ContextLoaderListener. 
- RootConfig == root-context.xml
6. WebConfig extends WebMvcConfigurerAdapter + configureDefaultServletHandling() == <mvc:resources mapping ="/resources/**" location="/resources/"/> //but use different approach
7. @EnableWebMvc == <mvc:annotation-driven/>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#further information:
- configuring DispatcherServlet via AbstractAnnotationConfigDispatcherServletInitializer is an alternative to the traditional web.xml file. Although you can include a web.xml file alongside a subclass of AbstractAnnotationConfigDispatcherServletInitializer if you like, it’s not necessary.
- configuring DispatcherServlet using AbstractAnnotationConfigDispatcherServletInitializer will only work when deploying to a server that supports
Servlet 3.0, such as Apache Tomcat 7 or higher. The Servlet 3.0 specification has been final since December 2009. If you’re not yet working with a Servlet 3.0-capable server, you’ll have no choice but to configure DispatcherServlet in web.xml.

#Machanism
- In a Servlet 3.0 environment, the container looks for any classes in the classpath that implement the "javax.servlet.ServletContainerInitializer" interface; if any are found, they’re used to configure the servlet container.
- Spring supplies an implementation of that interface called SpringServletContainerInitializer that, in turn, seeks out any classes that implement WebApplicationInitializer and delegates to them for configuration.
- Spring 3.2 introduced a convenient base implementation of WebApplicationInitializer called AbstractAnnotationConfigDispatcherServletInitializer. Because
your SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer (and thus implements WebApplicationInitializer), it will
be automatically discovered when deployed in a Servlet 3.0 container and be used to configure the servlet context.

#relationship between DispatcherServlet and a servlet listener known as ContextLoaderListener.
- DispatcherServlet is expected to load beans containing web components such as controllers, view resolvers, and handler mappings.
- But in Spring web applications, there’s often another application context. This other application context is created by ContextLoaderListener.
- ContextLoaderListener is expected to load the other beans in your application. These beans are typically the middle-tier and data-tier components that drive the back end of the application.

#ENABLING SPRING MVC
- Just as there are several ways of configuring DispatcherServlet, there’s more than one way to enable Spring MVC components. Historically, Spring has been configured using XML, and there’s an <mvc:annotation-driven> element that you can use to enable annotation-driven Spring MVC.

- Simplest Spring MVC configuration. 
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
@Configuration
@EnableWebMvc
public class WebConfig {
}

- WebConfig == spitter-servlet.xml
- @EnableWebMvc == <mvc:annotation-driven>
- In above simplest config, no view resolver is configured. default to using BeanNameViewResolver, a view resolver that resolves views by looking for beans ID matching the view name and whose class implements the View interface.
- Component-scanning isn’t enabled. controllers need to be  declared explicitly in the configuration.
- DispatcherServlet is mapped as the default servlet and will handle all requests, including requests for static resources, such as images and stylesheets

@Configuration
@EnableWebMvc
@ComponentScan("spitter.web")	//Enable component-scanning == <context:component-scan base-package="spitter.web"/>
public class WebConfig extends WebMvcConfigurerAdapter {
	@Bean
	public ViewResolver viewResolver() {	//Configure a JSP view resolver == <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		InternalResourceViewResolver resolver = New InternalResourceViewResolver();
		resolver.setPrefix("/WEB-INF/views/");
		resolver.setSuffix(".jsp");
		resolver.setExposeContextBeansAsAttributes(true);
		return resolver;
	}
	
	@Override
	public void configureDefaultServletHandling(	//Configure static content handling == <mvc:resources mapping="/resources/**" location="/resources/"/> ??
		DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}
}

- WebConfig is now annotated with @ComponentScan so that the spitter.web package will be scanned for components
- a ViewResolver bean is added
- extends WebMvcConfigurerAdapter and overrides its configureDefaultServletHandling() method. By calling enable() on the given DefaultServletHandlerConfigurer, you’re asking DispatcherServlet to forward requests for static resources to the servlet container’s default servlet and not to try to handle them itself. where is static resources located? It doesn't matter, dispatcher mapping of / indicates all requests should will be handle by dispatcher servlet, Since DefaultServletHandlerConfigurer is configured at the lowest precedence, effectively it allows all other handler mappings to handle the request, and if none of them do, this handler can forward it to the "default" Servlet. let the "default" servelt to handle static resources.
- configureDefaultServletHandling() = <mvc:resources mapping ="/resources/**" location="/resources/"/> //but use different approach

#RootConfig for ContextListener
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration
@ComponentScan(basePackages={"spitter"},
	excludeFilters={
		@Filter(type=FilterType.ANNOTATION, value=EnableWebMvc.class)
	})
public class RootConfig {
}

#Writing a simple controller
#关联知识点
- <c:url value="/spittles" /> 会自动生成URL rewrite
- /spittles;jsessionid=50C9E74BE0850DB689664D7432305378" //在原始url后面添加;jsessionid=xxxxxx
- <%@ page session="false" %> //不生成session, 默认创建session
- maven中三种classpath：编译，测试，运行，scope不同的artifact会放到不同的classpath中 
1.compile：默认范围，编译测试运行都有效 
2.provided：在编译和测试时有效 
3.runtime：在测试和运行时有效 
4.test:只在测试时有效 
5.system:在编译和测试时有效，与本机系统关联，可移植性差
- for example:
- 以下aritifacts在编译测试运行都有效，可以在编译和测试代码中使用，也要部署到server
compile "org.springframework:spring-webmvc:$springVersion"
compile "org.springframework:spring-jdbc:$springVersion"
- 以下aritifacts在编译和测试时有效，可以在编译和测试代码中使用，不需部署到server, 因为server本身有 
providedCompile "javax.servlet:javax.servlet-api:$servletApiVersion"
providedCompile "javax.servlet.jsp:jsp-api:$jspApiVersion"
providedCompile "javax.el:javax.el-api:$jspElVersion"
- 以下aritifacts只在测试时有效，只可以在测试代码中reference（编译代码中是用不了Junit的），也不会部署到server， 
testCompile "junit:junit-dep:$junitVersion"
testCompile "org.springframework:spring-test:$springVersion"
testCompile "org.mockito:mockito-core:$mockitoVersion"
testCompile "org.hamcrest:hamcrest-library:$hamcrestVersion"

- it’s easy to test POJOs. ??because you don't need all the dependency libary.
public class HomeControllerTest {
	@Test
	public void testHomePage() throws Exception {
		HomeController controller = new HomeController();
		assertEquals("home", controller.home());
	}
}
- it only tests what happens in the home() method. It calls home() directly and asserts that a String containing the value “home” is returned. 
- It completely fails to test what makes that method a Spring MVC controller method. Nothing about the test asserts that home() will be called when a GET request for / comes in. And just because it returns “home”, there’s nothing to truly test that home is the name of the view.
- Starting with Spring 3.2, you can test Spring MVC controllers as controllers, not merely as POJOs. Spring now includes a mechanism for mocking all
the mechanics of Spring MVC and executing HTTP requests against controllers. 
- enable you to test your controllers without firing up a web server or web browser.

public class HomeControllerTest {
	@Test
	public void testHomePage() throws Exception {
		HomeController controller = new HomeController();
		MockMvc mockMvc = standaloneSetup(controller).build();	//Set up MockMvc
		mockMvc.perform(get("/"))								//Perform GET /
			.andExpect(view().name("home"));					//Expect home view
	}
}

- Rather than call home() directly and test its return value, this test issues a GET request for / and asserts that the resulting view is named home. 
- It starts by passing an instance of HomeController to MockMvcBuilders.standaloneSetup() and calling build() to set up the MockMvc instance. 
- Then it asks the MockMvc instance to perform a GET request for / and sets an expectation for the view name.

#Passing model data to the view
- domain object
public class Spittle {
	private final Long id;
	private final String message;
	private final Date time;
	private Double latitude;
	private Double longitude;
	
	public Spittle(String message, Date time) {
		this(message, time, null, null);
	}
	...
	@Override
	public boolean equals(Object that) {
		return EqualsBuilder.reflectionEquals(this, that, "id", "time");
	}
	
	@Override
	public int hashCode() {
		return HashCodeBuilder.reflectionHashCode(this, "id", "time");
	}
}

- using Apache Commons Lang for easy implementation of the equals() and hashCode() methods. Aside from the general utility value of those methods, they’ll be valuable in writing a test for the controller handler method.


@Test
  public void shouldShowRecentSpittles() throws Exception {
    List<Spittle> expectedSpittles = createSpittleList(20);									//create a list of 20 spittles
    SpittleRepository mockRepository = mock(SpittleRepository.class);					//creating a mock implementation of the SpittleRepository interface
    when(mockRepository.findSpittles(Long.MAX_VALUE, 20))		//mock respository will return the list of 20 Spittle objects from its findSpittles() method
    	.thenReturn(expectedSpittles);		

    SpittleController controller = new SpittleController(mockRepository);	 				//injects that repository into a new SpittleController instance	
    MockMvc mockMvc = standaloneSetup(controller)											//sets up MockMvc to use the controller.
        .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp"))		//calls setSingleView() on the MockMvc builder
        .build();

    mockMvc.perform(get("/spittles"))														//GET /spittles
       .andExpect(view().name("spittles"))													//asserting that the view name is spittles
       .andExpect(model().attributeExists("spittleList"))									//asserting the model has an attribute named spittleList
       .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray())));	//asserting the attribute spittleList has expected contents.
  }

- unlike HomeControllerTest, this test calls setSingleView() on the MockMvc builder. so the mock framework won’t try to resolve the view name coming from the controller on its own. In many cases, this is unnecessary. But for this controller method, the view name (spittles) will be similar to the request’s path(/spittles); left to its default view resolution, MockMvc will fail because the view path will be confused with the controller’s path. 
- The actual path given when constructing the InternalResourceView is unimportant in this test, but you set it to be consistent with how you’ve configured InternalResourceViewResolver.
- when a controller’s handler method finishes, a logical view name is usually returned. Even if the method doesn’t directly return a logical view name (if the method returns void, for example), then the logical view name is derived from the request’s URL.

@RequestMapping(method=RequestMethod.GET)
public List<Spittle> spittles() {
	return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
}

- Rather than return a logical view name and explicitly setting the model, this method returns the Spittle list. When a handler method returns an object or a collection like this, the value returned is put into the model, and the model key is inferred from its type (spittleList, as in the other examples).
- As for the logical view name, it’s inferred from the request path. Because this method handles GET requests for /spittles, the view name is spittles (chopping off the leading slash).
- Now that there’s data in the model, how does the JSP access it? As it turns out when the view is a JSP, the model data is copied into the request as request attributes. Therefore, the spittles.jsp file can use JavaServer Pages Standard Tag Library’s (JSTL).
<c:forEach items="${spittleList}" var="spittle" >
    <li id="spittle_<c:out value="${spittle.id}"/>">
      <div class="spittleMessage"><c:out value="${spittle.message}" /></div>
      <div>
        <span class="spittleTime"><c:out value="${spittle.time}" /></span>
        <span class="spittleLocation">(<c:out value="${spittle.latitude}" />, <c:out value="${spittle.longitude}" />)</span>
      </div>
    </li>
</c:forEach>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Accepting request input
- 总而言之，3 ways for accepting input
1) Query parameters: @RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max
2) Form parameters: <sf:form method="POST" commandName="spitter"> + <sf:input path="username" cssErrorClass="error"/>; processRegistration(Spitter spitter) 
- <sf:form method="POST" modelAttribute="spitter">  = <sf:form method="POST" commandName="spitter"> ??
3) Path variables: @PathVariable("userid") Integer id
4) InternalResourceViewResolver regconize redirect: prefix as a redirect specification instead of as a view name; it also recognizes the forward: prefix and forward the request to the given URL path instead of view resolving or redirected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

- 3 ways for a client to pass data into a controller’s handler method:
Query parameters
Form parameters
Path variables

#Taking query parameters
- If you’re going to let users go through spittle history a page at a time, you’ll need to offer a way for them to pass in parameters that determine which set of spittles to display.
- To implement this paging solution, you’ll need to write a handler method that accepts the following:
A max parameter (which indicates the ID of the Spittle that all Spittle objects in the results are before)
A count parameter (which indicates how many spittles to include in the result)
@RequestMapping(method=RequestMethod.GET)
public List<Spittle> spittles(@RequestParam("max") long max, @RequestParam("count") int count) {
	return spittleRepository.findSpittles(max, count);
}

- If the handler method in SpittleController is going to handle requests with or without the max and count parameters, you’ll need to change it to accept those parameters, but still default to Long.MAX_VALUE and 20 if those parameters are absent on the request. The defaultValue attribute of @RequestParam will do the trick:

@RequestMapping(method=RequestMethod.GET)
public List<Spittle> spittles(
	@RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max,
	@RequestParam(value="count", defaultValue="20") int count) {
	return spittleRepository.findSpittles(max, count);
}

- if the max parameter isn’t specified, it will default to the maximum value of Long.
- Because query parameters are always of type String, the defaultValue attribute requires a String value. Therefore, Long.MAX_VALUE won’t work. Instead, you can capture Long.MAX_VALUE in a String constant, it will be converted to a Long when bound to the method’s max parameter:
private static final String MAX_LONG_AS_STRING = "9223372036854775807";

#Taking input via path parameters
- path parameter is popular in building resource-oriented controllers
- from a resource-orientation perspective, the resource being identified (the Spittle) would be identified by the URL path, not by query parameters.
- /spittles/show?spittle_id=12345 == A GET request for /spittles/12345
- The latter identifies a resource to be retrieved. The former describes an operation with a parameter—essentially RPC over HTTP.
- Up to this point, all of your controller methods have been mapped (via @RequestMapping) to a statically defined path. But if you’re going to make this test pass, you’ll need to write an @RequestMapping that has a variable portion of the path that represents the Spittle ID.
- To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path. The placeholders are names surrounded by curly braces
({ and }). Although all the other parts of the path need to match exactly for the request to be handled, the placeholder can carry any value.

@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
public String spittle(@PathVariable("spittleId") long spittleId, Model model) {
	model.addAttribute(spittleRepository.findOne(spittleId));
	return "spittle";
}

- spittle() has a spittleId parameter that is annotated with @PathVariable("spittleId"). This indicates that whatever value is at the placeholder
position in the request path will be passed into the handler method’s spittleId parameter.

#Processing forms
- Query parameters and path parameters are fine for passing small amounts of data on a request.
- But often you need to pass a lot of data (perhaps data coming from a form submission), and query parameters are too awkward and limited for that.
- There are two sides to working with forms: displaying the form and processing the data the user submits from the form.
- same as "sia3".

- More mockMvc usage:
 @Test
  public void shouldProcessRegistration() throws Exception {
    SpitterRepository mockRepository = mock(SpitterRepository.class);
    Spitter unsaved = new Spitter("jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov");
    Spitter saved = new Spitter(24L, "jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov");
    when(mockRepository.save(unsaved)).thenReturn(saved);
    
    SpitterController controller = new SpitterController(mockRepository);
    MockMvc mockMvc = standaloneSetup(controller).build();

    mockMvc.perform(post("/spitter/register") 	//performs a POST request against /spitter/register
           .param("firstName", "Jack")			// As part of that POST request, user information is passed as parameters on the request to simulate a form being submitted.
           .param("lastName", "Bauer")	
           .param("username", "jbauer")
           .param("password", "24hours")
           .param("email", "jbauer@ctu.gov"))
           .andExpect(redirectedUrl("/spitter/jbauer")); //expects that the request will end in a redirect to the URL path of the new user’s profile page.    
    verify(mockRepository, atLeastOnce()).save(unsaved); //verifies that the mocked SpitterRepository was actually used to save the data coming in on the form.
  }

@RequestMapping(value="/register", method=POST)
public String processRegistration(Spitter spitter) {
	spitterRepository.save(spitter);
	return "redirect:/spitter/" + spitter.getUsername();
}

- processRegistration() method is given a Spitter object as a parameter. This object has firstName, lastName, username, and password properties that will be populated from the request parameters of the same name.
- When InternalResourceViewResolver sees the redirect: prefix on the view specification, it knows to interpret it as a redirect specification instead of as a view name. 
- in addition to redirect:, InternalResourceViewResolver also recognizes the forward: prefix. When it sees a view specification prefixed with forward:, the request is forwarded to the given URL path instead of view resolving or redirected.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Validating forms
- 总而言之，spring mvc validation
1) processRegistration(@Valid Spitter spitter, Errors errors)
2) In domain object: use jsr303 validation annotation (e.g. @Max, @Min, @NotNull，on the field)
3) if (errors.hasErrors()) { return "registerForm"; }
4) In the view: <sf:errors path="username"> 

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Rather than litter your handler methods with validation logic, however, you can take advantage of Spring’s support for the Java Validation API (a.k.a. JSR-303). 
- Starting with Spring 3.0, Spring supports the Java Validation API in Spring MVC. No extra configuration is required to make Java Validation work in Spring MVC. You just need to make sure an implementation of the Java API, such as Hibernate Validator, is in the project’s classpath.
- The Java Validation API defines several annotations that you can put on properties to place constraints on the values of those properties. All of these annotations are in the javax.validation.constraints package.
@AssertFalse: The annotated element must be a Boolean type and be false.
@AssertTrue: The annotated element must be a Boolean type and be true.
@DecimalMax: The annotated element must be a number whose value is less than or equal to a given BigDecimalString value.
@DecimalMin: The annotated element must be a number whose value is greater than or equal to a given BigDecimalString value.
@Digits: The annotated element must be a number whose value has a specified number of digits.
@Future: The value of the annotated element must be a date in the future.
@Max: The annotated element must be a number whose value is less than or equal to a given value.
@Min: The annotated element must be a number whose value is greater than or equal to a given value.
@NotNull: The value of the annotated element must not be null.
@Null: The value of the annotated element must be null.
@Past: The value of the annotated element must be a date in the past.
@Pattern: The value of the annotated element must match a given regular expression.
@Size The value of the annotated element must be either a String, a collection, or an array whose length fits within the given range.
- In addition to the annotations in above list, Java Validation API implementations may provide additional validation annotations. And it’s also possible to define your own constraints.

public class Spitter {
	private Long id;
	
	@NotNull				//Not null
	@Size(min=5, max=16)	//from 5 to 16 characters
	private String username;
	
	@NotNull
	@Size(min=5, max=25)
	private String password;
	
	@NotNull
	@Size(min=2, max=30)	
	private String firstName;
	
	@NotNull
	@Size(min=2, max=30)
	private String lastName;
	...
}

- it’s important that the Errors parameter immediately follow the @Valid-annotated parameter that’s being validated.) The first thing processRegistration() does is call Errors.hasErrors() to check for any errors.
- in the next chapter, you’ll adapt the form (using srping taglib) to 1)show the values that were originally submitted <sf:form method="POST" modelAttribute="spitter"> and 2)communicate validation problems to the user. <sf:error>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

6. Chapter6 Spring MVC Views
- 总而言之 (JSP view)
1）controller is responsible for accepting input, processing input and populating the input and return a logical viewname; controller is not aware of the actual view.
2) ViewResolver interface return an View object based on logical view name and locale, View object use the model render the output to http response
3) TilesViewResolver to achieve layout control over JSP pages.
4) Thymleaf has more in common with the HTML than JSP, is more natural.
5) Spring supports JSP views in two ways: 1) InternalResourceViewResolver can be used to resolve view names into JSP files. also support JSTL locale and resource bundle variables; 2) Spring provides "form-to-model binding" and general "utility" taglib.
6）Spring’s form-binding JSP tag library includes 14 tags, most of which render HTML. i.e. sf:form, sf:errors, sf:input, sf:password, sf:label..., modelAttribute
7) <sf:errors path="username" cssClass="error" /> will display validation error and add a css class named error to the element. by predefining the 'error'
class style, error can be highlighted. same way applied to 1)<sf:errors path="*" element="div" cssClass="errors" /> and 2)<sf:label path="firstName" cssErrorClass="error">
8) message bundle and internalization: 1) annotation in domain object @Size(min=5, max=16, message="{username.size}"); 2) create a ValidationMessage.properites file at root context and ValiationMessage_xx.properties for other locale; 3) request Content-Language header will be used to match the resource bunder suffix to select the appropriate properties file.
9) general "utility" taglib has XXX tag. 1)<s:url>: Creates context-relative URLs with support for URI template variables and 2)<s:message> retrieves the message with the given code and either renders it (default) or assigns to a variable with different scopes.
10) <s:url> can use <s:param> tag to add reqest parameter or path parameter to the URL
11) Displaying internationalized message: 1)create a MessageSource bean 2)create the default properties file named messages.properties:
spittr.welcome=Welcome to Spittr! and another properties file named messages_es.properties: spittr.welcome=Bienvenidos a Spittr! 3) use <s:message key="spittr.welcome" /> in jsp page

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Understanding view resolution
- Decoupling request-handling logic in the controller from the view-rendering of a view
- controllers do not directly produce the HTML that is rendered in the browser. Instead, they populate the model with some data and then pass the model off to a view for rendering. controllers is not aware of JSP etc.
- At most, the controller methods and view implementations should agree on the contents of the model

#Test case:
1. Validation (done)
2. validation with message in one place and label cssErrorClass (Done)
3. Validation with internationalized validation message （done）
4. DISPLAYING INTERNATIONALIZED MESSAGES (done)
5. DISPLAYING INTERNATIONALIZED MESSAGES using ReloadableResourceBundleMessageSource (failed)
6. S:url tag (done)

#ViewResolver machanism
- Spring MVC defines an interface named ViewResolver that looks a little something like this:
public interface ViewResolver {
	View resolveViewName(String viewName, Locale locale) throws Exception;
}

- The resolveViewName() method, when given a view name and a Locale, returns a View instance:
public interface View {
	String getContentType();
	void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception;
}
- take the model, as well as the servlet request and response objects, and render output into the response.

- TilesViewResolver to achieve layout control over JSP pages
- Thymeleaf is a compelling alternative to JSP that offers a view resolver for working with Thymeleaf’s natural templates: templates that have more in common with the HTML they produce than with the Java code that drives them.

#Creating JSP views
- JSP has evolved over the years to include support for an expression language and custom tag libraries.
- Spring supports JSP views in two ways:
1) InternalResourceViewResolver can be used to resolve view names into JSP files. Moreover, if you’re using JavaServer Pages Standard Tag Library (JSTL)
tags in your JSP pages, InternalResourceViewResolver can resolve view names into JSP files fronted by JstlView to expose JSTL locale and resource bundle
variables to JSTL’s formatting and message tags.
2) Spring provides two JSP tag libraries, one for "form-to-model binding" and one providing general "utility" features.

#Configuring a JSP-ready view resolver
@Bean
public ViewResolver viewResolver() {
	InternalResourceViewResolver resolver = new InternalResourceViewResolver();
	resolver.setPrefix("/WEB-INF/views/");
	resolver.setSuffix(".jsp");
	return resolver;
}

#RESOLVING JSTL VIEWS
- InternalResourceViewResolver resolves logical view names into instances of InternalResourceView that reference jsp files.
- if those JSP files are using JSTL tags for formatting or messages, then you may want to configure InternalResourceViewResolver to resolve a JstlView instead.

@Bean
public ViewResolver viewResolver() {
	InternalResourceViewResolver resolver = new InternalResourceViewResolver();
	resolver.setPrefix("/WEB-INF/views/");
	resolver.setSuffix(".jsp");
	resolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
	return resolver;
}

- JSTL’s formatting tags need a Locale to properly format locale-specific values such as dates and money. And its message tags can use a Spring message source and a Locale to properly choose messages to render in HTML. By resolving JstlView, the JSTL tags will be given the Locale and any message source configured in Spring.

#Using Spring’s JSP libraries
- Tag libraries are a powerful way to bring functionality to a JSP template without resorting to writing Java code directly in scriptlet blocks.

#form-binding tag library
- form can be prepopulated and validation errors can be displayed after a failed form submission.
- Spring’s form-binding JSP tag library includes 14 tags, most of which render HTML.
- But what makes these different from the raw HTML tags is that they’re bound to an object in the model and can be populated with values from the model object’s properties.
- The tag library also includes a tag that can be used to communicate errors to the user by rendering them into the resulting HTML.

<%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
*<sf:checkbox>: Renders an HTML <input> tag with type set to checkbox.
<sf:checkboxes>: Renders multiple HTML <input> tags with type set to checkbox.
*<sf:errors>: Renders field errors in an HTML <span> tag.
*<sf:form>: Renders an HTML <form> tag and exposed "binding path" to inner tags for data-binding.
*<sf:hidden>: Renders an HTML <input> tag with type set to hidden.
*<sf:input>: Renders an HTML <input> tag with type set to text.
*<sf:label>: Renders an HTML <label> tag.
<sf:option>: Renders an HTML <option> tag. The selected attribute is set according to the bound value.
<sf:options>: Renders a list of HTML <option> tags corresponding to the bound collection, array, or map.
*<sf:password>: Renders an HTML <input> tag with type set to password.
<sf:radiobutton>: Renders an HTML <input> tag with type set to radio.
<sf:radiobuttons>: Renders multiple HTML <input> tags with type set to radio.
<sf:select>: Renders an HTML <select> tag.
*<sf:textarea>: Renders an HTML <textarea> tag.

<sf:form method="POST" commandName="spitter"> 
	First Name: <sf:input path="firstName" /><br/> //value=${spitter.firstName}
	Last Name: <sf:input path="lastName" /><br/>
	Email: <sf:input path="email" /><br/>
	Username: <sf:input path="username" /><br/>
	Password: <sf:password path="password" /><br/>
	<input type="submit" value="Register" />
</sf:form>

- The <sf:form> tag renders an HTML <form> tag. But it also sets some context around a model object designated in the commandName attribute. 
- Properties on the model object will be referenced in the other form-binding tags you use.
- In the preceding code, you set commandName to spitter. Therefore, there must be an object in the model whose key is spitter, or else the form won’t be able to render (and you’ll get JSP errors). Add a Spitter object is in the model：
model.addAttribute(new Spitter());
- Its value attribute will be set to the value of the model object’s property specified in the path attribute
- starting with Spring 3.1, the <sf:input> tag allows you to specify a type attribute so that you can declare HTML 5–specific type text fields such as data,
range, and email, among other options.
<sf:input path="email" type="email" /><br/>
rendered as: <input id="email" name="email" type="email" value="jack"/><br/>

#<sf:errors>
<sf:form method="POST" commandName="spitter">
	First Name: <sf:input path="firstName" />
	<sf:errors path="firstName" /><br/>
	...
</sf:form>
- its path attribute is set to firstName, the name of the Spitter model object property for which errors should be displayed. If there are no errors for the firstName property, then <sf:errors> won’t render anything. But if there is a validation error, it will render that error message in an HTML <span> tag.
- set the cssClass attribute for changing the style of the error so that it stands out 
<sf:errors path="firstName" cssClass="error" />
- display error all together. 
<sf:errors path="*" element="div" cssClass="errors" />
- set the element attribute to div. By default, errors are rendered in an HTML <span> tag
- setting the cssErrorClass attribute on each field. You can also wrap each label with <sf:label> and set its cssErrorClass
<sf:form method="POST" commandName="spitter" >
	<sf:label path="firstName" cssErrorClass="error">First Name</sf:label>:
	<sf:input path="firstName" cssErrorClass="error" /><br/>
		...
</sf:form>

- set the message attribute on the validation annotations to reference a friendly message
@NotNull
@Size(min=5, max=16, message="{username.size}")
private String username;

- create a file named ValidationMessages.properties at the root of the classpath
firstName.size=First name must be between {min} and {max} characters long.
lastName.size=Last name must be between {min} and {max} characters long.
username.size=Username must be between {min} and {max} characters long.
password.size=Password must be between {min} and {max} characters long.
email.valid=The email address must be valid.
- the key for each message in ValidationMessages.properties corresponds to the placeholder values in the message attributes
- messages have placeholders of their own—{min} and {max}—that reference the min and max attributes given on the @Size annotation
- extracting the error messages to a properties file enables displaying language- and locale-specific messages by creating a locale-specific properties
file such as ValidationMessages_es.properties:
firstName.size=Nombre debe ser entre {min} y {max} caracteres largo.
lastName.size=El apellido debe ser entre {min} y {max} caracteres largo.
username.size=Nombre de usuario debe ser entre {min} y {max} caracteres largo.
password.size=Contraseña debe estar entre {min} y {max} caracteres largo.
email.valid=La dirección de email no es válida

根据浏览器语言设置，broswser will send http request with different Content-Language header, if the Content-Language header matches the resource bunder suffix.
e.g. Content-Language:es matches ValidationMessages_es.properties, message in the file will be displayed, if no match, default message from ValidationMessages.properties will be used.
Content-Language:zh
Content-Language:es

#SPRING’S GENERAL TAG LIBRARY
- <%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
<s:bind>: Exports a bound property status to a page-scoped status property. Used along with <s:path> to obtain a bound property value.
<s:escapeBody>: HTML and/or JavaScript escapes the content in the body of the tag. 
<s:hasBindErrors>: Conditionally renders content if a specified model object (in a request attribute) has bind errors.
<s:htmlEscape>: Sets the default HTML escape value for the current page.
<s:message>: Retrieves the message with the given code and either renders it (default) or assigns it to a page-, request-, session-, or application-scoped variable (when using the var and scope attributes).
<s:nestedPath>: Sets a nested path to be used by <s:bind>.
<s:theme>: Retrieves a theme message with the given code and either renders it (default) or assigns it to a page-, request-, session-, or application-scoped
variable (when using the var and scope attributes).
<s:transform>: Transforms properties not contained in a command object using a command object’s property editors.
<s:url>: Creates context-relative URLs with support for URI template variables and HTML/XML/JavaScript escaping. Can either render the URL (default) or
assign it to a page-, request-, session-, or application-scoped variable (when using the var and scope attributes).
<s:eval>: Evaluates Spring Expression Language (SpEL) expressions, rendering the result (default) or assigning it to a page-, request-, session-, or applicationscoped variable (when using the var and scope attributes).

#DISPLAYING INTERNATIONALIZED MESSAGES
- As it stands, your JSP templates contain a lot of hard-coded text, it doesn’t lend itself to easily changing the text. 
- Moreover, there’s no way to internationalize the text so it’s tailored to the user’s language settings.
- The <s:message> tag is perfect for rendering text that’s externalized in one or more properties files:
<h1><s:message key="spittr.welcome" /></h1>
- <s:message> will render the text available from a message source where the key is spittr.welcome.
- Spring has a handful of message-source classes, all implementing the MessageSource interface. One of the more common and useful implementations is "ResourceBundleMessageSource". It loads messages from a properties file whose name is derived from a base name.
@Bean
public MessageSource messageSource() {
	ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
	messageSource.setBasename("messages"); //base name to resolve properties file names
	return messageSource;
}
- setting of the basename property. You can set it to any value you’d like, but here I’ve chosen to set it to messages. By setting it to messages, you can expect ResourceBundleMessageResolver to resolve messages from properties files at the root of the classpath whose names are derived from that base name.
- ReloadableResourceBundleMessageSource works much like ResourceBundleMessageSource, but it has the ability to reload message properties without recompiling or restarting the application.
@Bean
public MessageSource messageSource() {
	ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
	messageSource.setBasename("file:///etc/spittr/messages");
	messageSource.setCacheSeconds(10);
	return messageSource;
}
- The basename property can be set to look for messages in the classpath (with a classpath: prefix), in the filesystem (with a file: prefix), or at the root of the web application(with no prefix).
- create the default properties file named messages.properties:
spittr.welcome=Welcome to Spittr!
- create another properties file named messages_es.properties:
spittr.welcome=Bienvenidos a Spittr!

#CREATING URLS
- <s:url> tag's main job is to create a URL and either assign it to a variable or render it in the response. It’s a drop-in replacement for JSTL’s
<c:url> tag, but with a few new tricks up its sleeve.

<a href="<s:url href="/spitter/register" />">Register</a>
- prepend servlet context: In its simplest form, <s:url> takes a servlet-context-relative URL and renders it with the servlet context path prepended.
<a href="<s:url href="/spitter/register" />">Register</a>
- rendered as:
<a href="/spittr/spitter/register">Register</a> // /spittr is the servlet context

- reuse: have <s:url> construct the URL and assign it to a variable to be used later in the template
<s:url href="/spitter/register" var="registerUrl" />
<a href="${registerUrl}">Register</a>

- resue: By default, URL variables are created in page scope. But you can have <s:url> create them in application, session, or request scope instead by setting the scope attribute:
<s:url href="/spitter/register" var="registerUrl" scope="request" />

- use <s:param> tag to add parameters to the URL:
<s:url href="/spittles" var="spittlesUrl">
	<s:param name="max" value="60" />
	<s:param name="count" value="20" />
</s:url>

- create a URL with a path parameter
<s:url href="/spitter/{username}" var="spitterUrl">
	<s:param name="username" value="jbauer" />
</s:url>
- the parameter is inserted into the placeholder’s spot. If the <s:param> parameter doesn’t match any placeholders in href, then the parameter is used as a
query parameter.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Defining a layout with Apache Tiles views
- 总而言之 (Tiles Views)
1) declare a TilesConfigurer bean whose job is to locate and load tile definitions and generally coordinate Tiles.
2) declare a TilesViewResolver bean to resolve logical view names to tile definitions.
3) define tile definition xml: 1) base template with the standard layout including header, footer, body... 2) other template inherit base. and define its own body. 3)each template can choose to overwrite the header and footer if they want. 4) header and footer is reused.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- add a common header and footer to all pages in the application
- use a layout engine such as Apache Tiles to define a common page layout that will be applied to all pages. 
- Spring MVC provides support for Apache Tiles in the form of a view resolver that can resolve logical view names into tile definitions.
- 1)declare a TilesConfigurer bean whose job is to locate and load tile definitions and generally coordinate Tiles. 

@Bean
public TilesConfigurer tilesConfigurer() {
	TilesConfigurer tiles = new TilesConfigurer();
	tiles.setDefinitions(new String[] {
		"/WEB-INF/layout/tiles.xml"			//Specify tile definition locations
	});
	tiles.setCheckRefresh(true);			//Enable refresh
	return tiles;
}
- the most important property you set is definitions. This property takes an array of Strings where each entry specifies the location of tile-definition XML files. For the Spittr application, you’ll have it look for /WEB-INF/layout/tiles.xml
- it’s also possible to specify multiple tile-definition files and even use wildcards in the location path. For example, you could ask that TilesConfigurer look for any file named tiles.xml anywhere under the /WEB-INF/ directory by setting the definitions property like this:
tiles.setDefinitions(new String[] {
	"/WEB-INF/**/tiles.xml"
});

- 2)declare a TilesViewResolver bean to resolve logical view names to tile definitions.
@Bean
public ViewResolver viewResolver() {
	return new TilesViewResolver();
}

#DEFINING TILES
- Apache Tiles provides a document type definition (DTD) for specifying tile definitions in an XML file. Each definition consists of a <definition> element that generally has one or more <put-attribute> elements.
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE tiles-definitions PUBLIC "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
	"http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
<tiles-definitions>
	<definition name="base" template="/WEB-INF/layout/page.jsp">			//base definition
		<put-attribute name="header" value="/WEB-INF/layout/header.jsp" />
		<put-attribute name="footer" value="/WEB-INF/layout/footer.jsp" />
	</definition>
	<definition name="home" extends="base">									//home definition, inherit header/footer
		<put-attribute name="body" value="/WEB-INF/views/home.jsp" />
	</definition>
	<definition name="registerForm" extends="base">							//registerForm definition
		<put-attribute name="body" value="/WEB-INF/views/registerForm.jsp" />
	</definition>
	<definition name="profile" extends="base">								//profile definition
		<put-attribute name="body" value="/WEB-INF/views/profile.jsp" />	
	</definition>
	<definition name="spittles" extends="base">								//spittles definition
		<put-attribute name="body" value="/WEB-INF/views/spittles.jsp" />	
	</definition>
	<definition name="spittle" extends="base">								//spittle definition
		<put-attribute name="body" value="/WEB-INF/views/spittle.jsp" />	
	</definition>
</tiles-definitions>

- Each <definition> element defines a tile that ultimately references a JSP template. 
- In the case of the tile whose name is base, the template referenced is at /WEB-INF/layout/page.jsp.
- A tile may also reference other JSP templates to be embedded in the main template. For the base tile, it references a header JSP template and a footer JSP
template.
<html>
	<head>
		<title>Spittr</title>
			...
	</head>
	<body>
		<div id="header">
			<t:insertAttribute name="header" />		//Insert the header 
		</div>
		<div id="content">
			<t:insertAttribute name="body" />		//Insert the body
		</div>
		<div id="footer">
			<t:insertAttribute name="footer" />		//Insert the footer
		</div>
	</body>
</html>

- The header and footer attributes were set in the base tile definition to point at /WEB-INF/layout/header.jsp and /WEB-INF/layout/footer.jsp respectively.
- The base tile is never expected to be used on its own. It serves as a base definition (thus the meaning behind its name) for other tile definitions to extend. the other tile definitions all extend base.
- This means they inherit its settings for the header and footer attributes (although they could choose to override them).
- But each also sets a body attribute to reference a JSP template specific to that tile.
- therfore, home tile's effective definition is the following:
<definition name="home" template="/WEB-INF/layout/page.jsp">
	<put-attribute name="header" value="/WEB-INF/layout/header.jsp" />
	<put-attribute name="footer" value="/WEB-INF/layout/footer.jsp" />
	<put-attribute name="body" value="/WEB-INF/views/home.jsp" />
</definition>

- The key point here is that the common elements of a page are captured in page.jsp, header.jsp, and footer.jsp and are absent in each of the other tile templates. This makes them reusable across all pages and simplifies maintenance of those elements.

Testcase :
1) tiles (done)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Working with Thymeleaf
- 总而言之(Thymeleaf)
1) JSP is not natural, littered with jsp tags and the template cannot be displayed by browser; 
2) Thymeleaf templates are natural and don’t rely on tag libraries and can be edited and rendered as HTML，without special tags or tag libraries as with JSP. 
3）Configuring resolverThymeleafViewResolver +  SpringTemplateEngine + TemplateResolver
4）Defining Thymeleaf templates： HTML files + Thymeleaf attributes to the standard set of HTML tags via a custom namespace.e.g. th:href="@{/spittles}, th:field="*{firstName}"， th:class="${#fields.hasErrors('firstName')}? 'error'，th:if="${#fields.hasErrors('*')， th:each="err:${#fields.errors('*')}"， th:text="${err}"
5) The ${} expressions (such as ${spitter}) are variable expressions. In the case of ${spitter}, it resolves to the model property whose key is spitter.
6) *{} expressions are selection expressions. Whereas variable expressions are evaluated against the entire SpEL context, selection expressions are evaluated on a selected object. In the case of the form, the selected object is the one given in the <form> tag’s th:object attribute: a Spitter object from the model. Therefore the *{firstName} expression evaluates to the firstName property on the Spitter object.
7） @{} expressions to calculate context-sensitive URL paths

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Disadvantage of JSP
- JSP has been around for a long time and is ubiquitous among Java web servers, it has a few unfortunate flaws.
1) it appears to be a form of HTML or XML, but it’s really neither. Most JSP templates take the form of HTML, "littered with tags from various JSP tag libraries".
2) Although these tag libraries bring dynamic rendering power to JSP in a succinct form, they break any hope of authoring a well-formed document. e.g. a JSP tag can even be used as the value of an HTML parameter: <input type="text" value="<c:out value="${thing.name}"/>" />
3) Because JSP isn’t truly HTML, many web browsers and editors have problems to display anything that aesthetically approximates what the template will render.
4) JSP is a specification that’s tightly coupled to the servlet specification. This means it can only be used for web views in a servlet-based web application. JSP templates aren’t an option for general-purpose templating (such as formatted emails) or in web applications that aren’t based on servlets.

#Thymeleaf
- Thymeleaf templates are natural and don’t rely on tag libraries. 
- They can be edited and rendered anywhere that raw HTML is welcome. And they’re not coupled to the servlet specification

- Configuring a Thymeleaf view resolver
1)A ThymeleafViewResolver that resolves Thymeleaf template views from logical view names
@Bean
public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
		ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
		viewResolver.setTemplateEngine(templateEngine);
		return viewResolver;
}

2)A SpringTemplateEngine to process the templates and render the results
@Bean
public TemplateEngine templateEngine(TemplateResolver templateResolver) {
		SpringTemplateEngine templateEngine = new SpringTemplateEngine();
		templateEngine.setTemplateResolver(templateResolver);
		return templateEngine;
}
3)A TemplateResolver that loads Thymeleaf templates
@Bean
public TemplateResolver templateResolver() {
	TemplateResolver templateResolver = new ServletContextTemplateResolver();
	templateResolver.setPrefix("/WEB-INF/templates/");
	templateResolver.setSuffix(".html");
	templateResolver.setTemplateMode("HTML5");
	return templateResolver;
}

- ThymeleafViewResolver is an implementation of Spring MVC’s ViewResolver. Just like any view resolver, it takes a logical view name and resolves a view. But in this case, that view is ultimately a Thymeleaf template.
- Notice that the ThymeleafViewResolver bean is injected with a reference to the SpringTemplateEngine bean. SpringTemplateEngine is a Spring-enabled Thymeleaf
engine for parsing templates and rendering results based on those templates. As you can see, it’s injected with a reference to the TemplateResolver bean.
- TemplateResolver is what ultimately locates the templates. It’s configured much as you previously configured InternalResourceViewResolver with prefix and
suffix properties. The prefix and suffix are applied to the logical view name to locate the Thymeleaf template. Its templateMode property is also set to HTML5, indicating that the templates resolved are expected to render HTML5 output.

- ThymeleafViewResolver ref SpringTemplateEngine ref TemplateResolver, templateResolver locates the actual template

#Defining Thymeleaf templates
- Thymeleaf templates are primarily just HTML files. There are no special tags or tag libraries as with JSP. 
- it adds Thymeleaf attributes to the standard set of HTML tags via a custom namespace. 
<html xmlns="http://www.w3.org/1999/xhtml" 
			xmlns:th="http://www.thymeleaf.org">											//Declare Thymeleaf namespace
	<head>
		<title>Spittr</title>
		<link rel="stylesheet" type="text/css" th:href="@{/resources/style.css}"></link>	//th:href link to stylesheet
	</head>
	<body>
		<h1>Welcome to Spittr</h1>
		<a th:href="@{/spittles}">Spittles</a> |											//th:href links to pages
		<a th:href="@{/spitter/register}">Register</a>
	</body>
</html>

- th:href attribute greatly resembles its native HTML counterpart, the href attribute, and can be used the same way. 
- th:href attribute's value can contain Thymeleaf expressions to evaluate dynamic values. It will render a standard href attribute containing a value that’s dynamically created at render time. 
- attributes in the Thymeleaf namespace mirror the standard HTML attribute that they share a name with, to render some computed value. 
- In this case, all three uses of the th:href attribute use the @{} expressions to calculate context-sensitive URL paths (much as you might use JSTL’s <c:url> tag or Spring’s <s:url> tag in a JSP page). 
- The only thing that stands out is the th:href attribute. Otherwise, it’s your basic, garden-variety HTML file.

#FORM BINDING WITH THYMELEAF
- instead of using Spring’s JSP tags to achieve form binding, you’ll take advantage of features of Thymeleaf’s Spring dialect.

<label th:class="${#fields.hasErrors('firstName')}? 'error'">First Name</label>:
<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>

- Instead of using the cssClassName attribute as you did with Spring’s JSP tags, here you use Thymeleaf’s th:class attribute on standard HTML tags. The th:class attribute renders a class attribute with a value calculated from the given expression. In both uses of th:class, it directly checks to see if there are any field errors for the firstName field. If so, the class attribute is rendered with a value of error. If there are no field errors, the class attribute isn’t rendered at all.
- The <input> tag uses the th:field attribute to reference the firstName field from the backing object.
- because you’re binding the field to the backing object’s firstName property, you use the th:field attribute, referring to the firstName field. By using
th:field, you get both a value attribute set to the value of firstName and also a name attribute set to firstName.

<form method="POST" th:object="${spitter}">	//th:object ref to a Spitter object from the model
	<div class="errors" th:if="${#fields.hasErrors('*')}">	//checks to see if there are any errors
		<ul>
			//The th:each attribute on the <li> tag instructs Thymeleaf to render the <li> one time for each error
			//th:text attribute render its value as the body of the <li> tag
			<li th:each="err : ${#fields.errors('*')}" th:text="${err}">Input is incorrect</li>
		</ul>
	</div>
	
	<label th:class="${#fields.hasErrors('firstName')}? 'error'">First Name</label>:
	<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>	//*{firstName} ref to spitter.firstname
	
	<label th:class="${#fields.hasErrors('lastName')}? 'error'">Last Name</label>:
	<input type="text" th:field="*{lastName}" th:class="${#fields.hasErrors('lastName')}? 'error'" /><br/>

	<label th:class="${#fields.hasErrors('email')}? 'error'">Email</label>:
	<input type="text" th:field="*{email}" th:class="${#fields.hasErrors('email')}? 'error'" /><br/>
	
	<label th:class="${#fields.hasErrors('username')}? 'error'">Username</label>:
	<input type="text" th:field="*{username}" th:class="${#fields.hasErrors('username')}? 'error'" /><br/>

	<label th:class="${#fields.hasErrors('password')}? 'error'">Password</label>:
	<input type="password" th:field="*{password}" th:class="${#fields.hasErrors('password')}? 'error'" /><br/>	
	<input type="submit" value="Register" />
</form>

- Thymeleaf is used near the top of the form to render all errors. The <div> element has a th:if attribute that checks to see if there are any errors. If
there are, the <div> will be rendered. Otherwise, it won’t be rendered.
- In the <div> is an unordered list to display each of the errors. The th:each attribute on the <li> tag instructs Thymeleaf to render the <li> one time for each error, assigning the current error in each iteration to a variable named err.
- th:text attribute. This attribute instructs Thymeleaf to evaluate an expression (in this case, the value of the err variable) and render its value as the body of the <li> tag. In effect, there will be one <li> for each error, displaying the text of that error.

- the difference between the expressions wrapped with ${} and those wrapped with *{}. The ${} expressions (such as ${spitter}) are variable
expressions. Normally, these are Object-Graph Navigation Language (OGNL) expressions (http://commons.apache.org/proper/commons-ognl/). But when used
with Spring, they’re SpEL expressions. In the case of ${spitter}, it resolves to the model property whose key is spitter.

- As for *{} expressions, they’re selection expressions. Whereas variable expressions are evaluated against the entire SpEL context, selection expressions are evaluated on a selected object. In the case of the form, the selected object is the one given in the <form> tag’s th:object attribute: a Spitter object from the model. Therefore the *{firstName} expression evaluates to the firstName property on the Spitter object.

Test case: Thymleaf home.html (done)
1) setup resolver/templateEmgine/templateResolver
2) home.html, spitter.html
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

7. Chapter 7 Advanced Spring MVC

- how to pass data around in the model such that it survives a redirect

- 总而言之 (More on spring MVC configuration)
1）traditional web.xml may be needed if pre-Servlet3.0 container is used.
2) setup additional configuration on DispatcherServlet: besides three abstract methods mandatory to overide, more methods that can be overridden to apply additional configuration: e.g. customizeRegistration(Dynamic registration). 
3) With the ServletRegistration.Dynamic, set the load-on-startup priority by calling setLoadOnStartup(), set an initialization parameter by calling setInitParameter(), and call setMultipartConfig() to configure Servlet 3.0 multipart support. 
4) setup servlets and filters in addition to DispatcherServlet: 1)create a class implments WebApplicationInitializer interface; 2)onStartup(ServletContext servletContext)-> servletContext.addServlet("myServlet", MyServlet.class); 3) onStartup(ServletContext servletContext)-> servletContext.addFilter("myFilter", MyFilter.class);
5) if addtional filters only map to DispatcherServlet, override the getServletFilters() method of AbstractAnnotationConfigDispatcherServletInitializer.
protected Filter[] getServletFilters() { return new Filter[] { new MyFilter() }; }
6) load the configuration from @Configuration-annotated classes (e.g. WebConfig) from web.xml: 
<param-name>contextClass</param-name><param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
<param-name>contextConfigLocation</param-name><param-value>com.habuma.spitter.config.WebConfigConfig</param-value>
7) also need to specify java config location and contextClass in <context-param> for contextListener, same as #6.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Alternate Spring MVC configuration

- Spring configuration in Java may not always fit what you need. You may need servlets and filters in addition to DispatcherServlet. Maybe you need to do some additional configuration on DispatcherServlet itself. if you’re deploying your application to a pre-Servlet 3.0 container, you may need to
configure DispatcherServlet in a traditional web.xml file.

#Customizing DispatcherServlet configuration
- The three methods you wrote in SpittrWebAppInitializer were the only abstract ones you were required to override. But there are more methods that can be overridden to apply additional configuration.
- If you plan to use Servlet 3.0 support for multipart configuration, you need to enable DispatcherServlet’s registration to enable multipart requests. You can override the customizeRegistration() method to set a MultipartConfigElement like this:
@Override
protected void customizeRegistration(Dynamic registration) {
	registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
}
- With the ServletRegistration.Dynamic that’s given to customizeRegistration(), you can do several things, including set the load-on-startup priority by calling setLoadOnStartup(), set an initialization parameter by calling setInitParameter(), and call setMultipartConfig() to configure Servlet 3.0 multipart support. 
- In the preceding example, you’re setting up multipart support to temporarily store uploaded files at /tmp/spittr/uploads.

#Adding additional servlets and filters
- AbstractAnnotationConfigDispatcherServletInitializer will create a DispatcherServlet and a ContextLoaderListener. 
- WebApplicationInitializer is a fine general-purpose way of registering servlets, filters, and listeners in Java when deploying to a Servlet 3.0 container.
- Using Java-based initializer (unlike with web.xml), you can define as many initializer classes as you want. Therefore, if you need to register any additional components into the web container, you need only create a new initializer class. 
- The easiest way to do this is by implementing Spring’s WebApplicationInitializer interface. the following listing shows how to create an implementation of
WebApplicationInitializer that registers a servlet: 

import javax.servlet.ServletRegistration.Dynamic;
import org.springframework.web.WebApplicationInitializer;
import com.myapp.MyServlet;
public class MyServletInitializer implements WebApplicationInitializer {
	@Override
	public void onStartup(ServletContext servletContext) throws ServletException {
		Dynamic myServlet = servletContext.addServlet("myServlet", MyServlet.class); 	//Register the servlet
		myServlet.addMapping("/custom/**");												//Map the servlet
	}
}

- You could use this approach to register DispatcherServlet manually. (But there’s no need, because AbstractAnnotationConfigDispatcherServletInitializer does a fine job without as much code.)

- Similarly, you can register listeners and filters by creating a new implementation of WebApplicationInitializer.
@Override
public void onStartup(ServletContext servletContext) throws ServletException {
	javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter("myFilter", MyFilter.class);		//Register filter
	filter.addMappingForUrlPatterns(null, false, "/custom/*");													//Add filter mapping
}

- if you’re registering a filter and only need to map that filter to DispatcherServlet, then there’s a shortcut in AbstractAnnotationConfigDispatcherServletInitializer.

- To register one or more filters and map them to DispatcherServlet, all you need to do is override the getServletFilters() method of AbstractAnnotationConfigDispatcherServletInitializer. For example, the following getServletFilters() method overrides the one from AbstractAnnotationConfigDispatcherServletInitializer to register a filter:
@Override
protected Filter[] getServletFilters() {
	return new Filter[] { new MyFilter() };
}
- As you can see, this method returns an array of javax.servlet.Filter. Here it only returns a single filter, but it could return as many filters as you need. There’s no need to declare the mapping for the filters; any filter returned from getServletFilters() will automatically be mapped to DispatcherServlet.

- When deploying to a Servlet 3.0 container, Spring offers several ways of registering servlets (including DispatcherServlet), filters, and listeners without creating a web.xml file.

#Declaring DispatcherServlet in web.xml
<?xml version="1.0" encoding="UTF-8"?>
	<web-app version="2.5" 	xmlns="http://java.sun.com/xml/ns/javaee"
							xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
							xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
							http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>		//Set root context location
	</context-param>

	<listener>
		<listener-class>
			org.springframework.web.context.contextLoaderListener 		//Register ContextLoaderListener
		</listener-class>
	</listener>

	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>
			org.springframework.web.servlet.DispatcherServlet 			//Register DispatcherServlet
		</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/spring/appServlet/servlet-context 				//set DispatcherServlet configuration file location
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>									//Map DispatcherServlet to /
	</servlet-mapping>
</web-app>

- DispatcherServlet loads its application context with beans defined in a file whose name is based on the servlet name. In above listing, the servlet is named appServlet. Therefore, DispatcherServlet loads its application context from an XML file at /WEB-INF/appServlet-context.xml.
- If you’d rather specify the location of the DispatcherServlet configuration file, you can set a "contextConfigLocation initialization parameter on the servlet". 

#Configuring web.xml to use Java configuration
- To use Java-based configuration in Spring MVC, you need to tell DispatcherServlet and ContextLoaderListener to use AnnotationConfigWebApplicationContext, an
implementation of WebApplicationContext that loads Java configuration classes instead of XML.

<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" 	xmlns="http://java.sun.com/xml/ns/javaee"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
						http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<context-param>
		<param-name>contextClass</param-name>
		<param-value>																		
			org.springframework.web.context.support.AnnotationConfigWebApplicationContext
																			//register application context loader class, default to XmlWebApplicationContext
		</param-value>
	</context-param>
	
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>com.habuma.spitter.config.RootConfig</param-value>		//register java config class location == root-context.xml location		
	</context-param>

	<listener>
		<listener-class>
			org.springframework.web.context.contextLoaderListener 			//register context listener
		</listener-class>
	</listener>

	<servlet>
		<servlet-name>appServlet</servlet-name>								//register Dispatcher Servlet
		<servlet-class>
			org.springframework.web.servlet.DispatcherServlet
		</servlet-class>
		<init-param>
			<param-name>contextClass</param-name>			//Dispatcher servlet's init param define context loader class, default to XmlWebApplicationContext
			<param-value>
				org.springframework.web.context.support.AnnotationConfigWebApplicationContext
			</param-value>
		</init-param>

		<init-param>										//Dispatcher servlet's init param define java config class location == appServlet-servlet.xml
			<param-name>contextConfigLocation</param-name>
			<param-value>
				com.habuma.spitter.config.WebConfig
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	
	<servlet-mapping>										//DispatcherServlet mapping / handles all requests
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
</web-app>

Test case:
1) web.xml config loading default xml context file (done)
- declare DispatcherServlet and mapping
- declare ContextListener
- default configuration file location should be /WEB-INF/servletName-servlet.xml and /WEB-INF/applicationContext.xml

2) web.xml config loading xml context file from customized locations (done)
- specify configuration file location. In servlet config, specify <init-param><param-name>contextConfigLocation; speficy <context-param><param-name>contextConfigLocation
- furthermore, you can use only DispatcherServlet or contextListener to load both context config files. 

3) web.xml config loading java web configs (done)
- instead of specify xml config file location, specify java config class location: <init-param><param-name>contextConfigLocation  <init-param><param-value>xxx.xxx.WebConfig
- also need to specify <init-param><param-name>contextClass to AnnotationConfigWebApplicationContext
- meanwhile, need to specify java config location and contextClass in <context-param> for contextListener

4) pure java config (done)
- WebAppInitializer class extends AbstractAnnotationConfigDispatcherServletInitializer and implements three methods: getRootConfigClasses(), getServletConfigClasses() and getServletMappings() (==web.xml)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


#Processing multipart form data
总而言之，(spring MVC file upload)
1）"configure multipart resolver", either a CommonsMultipartResolver from Jakarta Commons FileUpload or StandardServletMultipartResolver from Spring 3.1
2) CommonsMultipartResolver is useful if using pre-Servlet 3.0 container and StandardServletMultipartResolver is prefer because it doesn't require Jakarta Commons FileUpload.
3) if you use StandardServletMultipartResolver, you must configure multipart details as part of DispatcherServlet’s configuration in web.xml or in the servlet
initializer class.
3.1） If you’re configuring DispatcherServlet in a servlet initializer class that implements WebApplicationInitializer, within onStarup() method, registration.setMultipartConfig(...);
3.2) If you’ve configured DispatcherServlet in a servlet initializer class that extends AbstractAnnotationConfigDispatcherServletInitializer or AbstractDispatcherServletInitializer, you can override the customizeRegistration() method(which is given a Dynamic as a parameter)
3.3) If you’re configuring DispatcherServlet in a more traditional way in web.xml, you can specify multipart configuration using the <multipart-config> element in the <servlet> element
4) if you use Jakarta Commons FileUpload, you declare CommonsMultipartResolver bean and specify multipart upload details in the bean directly
5) "update form": enctype="multipart/form-data and <input type="file"...>
6) "update controller handler method": 1)@RequestPart, 2)MultipartFile
6.1) annotate a controller method parameter with @RequestPart: @RequestPart("profilePicture") byte[] profilePicture, need to process byte arrays
6.2) use MultipartFile from spring:  MutipartFile profilePicture. MutipartFile provides original filename, size, and content type and transferTo() method to write file to filesystems.
6.3) use javax.servlet.http.Part in Servlet 3.0 container, @RequestPart("profilePicture") Part profilePicture. the Part interface has several methods
similar to MultipartFile. no need to configure the StandardServletMultipartResolver bean if using Part interface. 

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- The request resulting from a typical form submission is simple and takes the form of multiple name-value pairs separated by ampersands. when submitting
the registration form from the Spittr application, the request might look like this:
firstName=Charles&lastName=Xavier&email=professorx%40xmen.org&username=professorx&password=letmein01
-In contrast, multipart form data breaks a form into individual parts, with one part per field. Each part can have its own type. Typical form fields have textual data in their parts, but when something is being uploaded, the part can be binary:

------WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="firstName"

Charles

------WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="lastName"

Xavier
...
------WebKitFormBoundaryqgkaBn8IHJCuNmiW
Content-Disposition: form-data; name="profilePicture"; filename="me.jpg"
Content-Type: image/jpeg				//it has its own Content-Type header indicating that it’s a JPEG image
[[ Binary image data goes here ]]
------WebKitFormBoundaryqgkaBn8IHJCuNmiW--

#Configuring a multipart resolver
- Since Spring 3.1, Spring comes with two out-of-the-box implementations of MultipartResolver to choose from:
1) CommonsMultipartResolver — Resolves multipart requests using Jakarta Commons FileUpload
2) StandardServletMultipartResolver — Relies on Servlet 3.0 support for multipart requests (since Spring 3.1)

- Generally speaking, StandardServletMultipartResolver should probably be your first choice of these two. It uses existing support in your servlet container and doesn’t require any additional project dependencies. 
- But you might choose CommonsMultipartResolver if you’ll be deploying your application to a pre-Servlet 3.0 container or if you aren’t using Spring 3.1 or higher yet.

#RESOLVING MULTIPART REQUESTS WITH SERVLET 3.0
- declare MultipartResolver as a bean in your Spring configuration
@Bean
public MultipartResolver multipartResolver() throws IOException {
	return new StandardServletMultipartResolver();
}

- instead of configuring StandardServletMultipartResolver in your Spring configuration, you must specify multipart configuration in the servlet
configuration.
- If you’re configuring DispatcherServlet in a servlet initializer class that implements WebApplicationInitializer, you can configure multipart details by calling setMultipartConfig() on the servlet registration, passing an instance of MultipartConfigElement.
DiaspatcherServlet ds = new DispatcherServlet();
Dynamic registration = context.addServlet("appServlet", ds);
registration.addMapping("/");
registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads")); //sets the temporary location to /tmp/spittr/uploads

- If you’ve configured DispatcherServlet in a servlet initializer class that extends AbstractAnnotationConfigDispatcherServletInitializer or AbstractDispatcherServletInitializer, you don’t create the instance of DispatcherServlet or register it with the servlet context directly.
- Consequently, there’s no handy reference to the Dynamic servlet registration to work with. But you can override the customizeRegistration() method (which is given a Dynamic as a parameter) to configure multipart details:

@Override
protected void customizeRegistration(Dynamic registration) {
	registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
}
- The single-argument constructor for MultipartConfigElement that you’ve been using thus far takes the absolute path to a directory in the filesystem where the uploaded file will be written temporarily.

- In addition to the temporary location path, the other constructor accepts the following:
1) The maximum size (in bytes) of any file uploaded. By default there is no limit.
2) The maximum size (in bytes) of the entire multipart request, regardless of how many parts or how big any of the parts are. By default there is no limit.
3) The maximum size (in bytes) of a file that can be uploaded without being written to the temporary location. The default is 0, meaning that all uploaded files will be written to disk.

@Override
protected void customizeRegistration(Dynamic registration) {
	registration.setMultipartConfig(
			new MultipartConfigElement("c:/tmp/spittr/uploads", 2097152, 4194304, 0));
}

- limit files to no more than 2 MB, to limit the entire request to no more than 4 MB, and to write all files to disk.
- If you’re configuring DispatcherServlet in a more traditional way in web.xml, you can specify multipart configuration using the <multipart-config> element in the <servlet> element, like this:
<servlet>
	<servlet-name>appServlet</servlet-name>
	<servlet-class>
		org.springframework.web.servlet.DispatcherServlet
	</servlet-class>
	<load-on-startup>1</load-on-startup>
	<multipart-config>
		<location>/tmp/spittr/uploads</location>
		<max-file-size>2097152</max-file-size>
		<max-request-size>4194304</max-request-size>
	</multipart-config>
</servlet>

#CONFIGURING A JAKARTA COMMONS FILEUPLOAD MULTIPART RESOLVER
- Spring offers CommonsMultipartResolver as an out-of-the-box alternative to StandardServletMultipartResolver

- declare CommonsMultipartResolver as a Spring bean:
@Bean
public MultipartResolver multipartResolver() {
	return new CommonsMultipartResolver();
}

- specify other multipart upload details directly in the Spring configuration:
@Bean
public MultipartResolver multipartResolver() throws IOException {
	CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
	multipartResolver.setUploadTempDir(new FileSystemResource("/tmp/spittr/uploads"));
	multipartResolver.setMaxUploadSize(2097152);
	multipartResolver.setMaxInMemorySize(0);
	return multipartResolver;
}
- Unlike StandardServletMultipartResolver, there’s no need to configure a temporary file location with CommonsMultipartResolver. By default, the location is the servlet container’s temporary directory.
- Unlike MultipartConfigElement, however, there’s no way to specify the maximum multipart request size.

#Handling multipart requests
- The most common way of doing that is to annotate a controller method parameter with @RequestPart.
- update the form so that the user can select a picture to be uploaded
<form method="POST" th:object="${spitter}" enctype="multipart/form-data">
	...
	<label>Profile Picture</label>:
	<input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif" /><br/>
	...
</form>

- enctype="multipart/form-data and <input type="file"...>

- change the processRegistration() method to accept the uploaded image. One way to do that is to add a byte array parameter that’s annotated with @RequestPart:

@RequestMapping(value="/register", method=POST)
public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture, @Valid Spitter spitter, Errors errors) {
	...
}

#RECEIVING A MULTIPARTFILE
- Working with the uploaded file’s raw bytes is simple but limiting, Spring also offers MultipartFile as a way to get a richer object for processing multipart data:

package org.springframework.web.multipart;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;

public interface MultipartFile {
	String getName();
	String getOriginalFilename();
	String getContentType();
	boolean isEmpty();
	long getSize();
	byte[] getBytes() throws IOException;
	InputStream getInputStream() throws IOException;
	void transferTo(File dest) throws IOException;
}
- MultipartFile offers a way to get at the bytes for the uploaded file. But it offers much more, including the original filename, size, and content type. It
also offers an InputStream for reading the file data as a stream.
- MultipartFile offers a convenient transferTo() method to help you write the uploaded file to the filesystem. e.g.
profilePicture.transferTo(new File("/data/spittr/" + profilePicture.getOriginalFilename()));

#SAVING FILES TO AMAZON S3

#RECEIVING THE UPLOADED FILE AS A PART
- If you’re deploying your application to a Servlet 3.0 container, you have an alternative to MultipartFile. Spring MVC will also accept a javax.servlet.http.Part as a controller method parameter. Using Part instead of MultipartFile leaves the processRegistration() method signature looking like this:
@RequestMapping(value="/register", method=POST)
	public String processRegistration(@RequestPart("profilePicture") Part profilePicture, @Valid Spitter spitter, Errors errors) {
	...
}
- For the most part, the Part interface isn’t much different from MultipartFile. As you can see in the next listing, the Part interface has several methods
that mirror the methods in MultipartFile.
package javax.servlet.http;
import java.io.*;
import java.util.*;
public interface Part {
	public InputStream getInputStream() throws IOException;
	public String getContentType();
	public String getName();
	public String getSubmittedFileName();
	public long getSize();
	public void write(String fileName) throws IOException;
	public void delete() throws IOException;
	public String getHeader(String name);
	public Collection<String> getHeaders(String name);
	public Collection<String> getHeaderNames();
}

profilePicture.write("/data/spittr/" + profilePicture.getOriginalFilename());

- It’s worth noting that if you write your controller handler methods to accept file uploads via a Part parameter, then you don’t need to configure the StandardServletMultipartResolver bean. StandardServletMultipartResolver is required only when you’re working with MultipartFile.

#Test cases:
1)  JAKARTA COMMONS FILEUPLOAD MULTIPART RESOLVER + servlet 2.3 using xml: sia3 (done)
- in jsp form: <form enctype="multipart/form data"/> <input type="file" name="image">
- MutipartResolver bean: 
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> + uploadSize...
- @RequestParam("image") MultiPartFile file
- file.transferTo(new File("/abc/def/"+filename))

2)  JAKARTA COMMONS FILEUPLOAD MULTIPART RESOLVER + java config: sia4 java config (done)
- in jsp file form: (same as above)
- @Bean InternalResourceViewResolver in WebConfig (Depending on the view template used)
- @Bean multipartResolver in WebConfig (using CommonsMultipartResolver)
- @RequestParam("image") MultiPartFile file (same as above)
- file.transferTo(new File("/abc/def/"+filename))  (same as above)

3) java config file upload using servlet3 (done)
- in jsp file form: (same as above)
- @Bean multipartResolver in WebConfig (using StandardServletMultipartResolver())
- Config upload parameters for ServletContext in SpittrWebInitializer: registration.setMultipartConfig(new MultipartConfigElement("c:/ftpfile/temp/", 2097152, 4194304, 0));
- or config in web.xml's servlet config: <multipart-config>
- @RequestParam("image") MultiPartFile file (same as above)
- or (@RequestPart("profilePicture") Part profilePicture using javax.servlet.http.Part  (***failed***))
- file.transferTo(new File("/abc/def/"+filename))  (same as above)

4) saving files to amazon s3. <Test>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Handling exceptions
总而言之，(spring MVC exception handling)
1) the outcome of a servlet request is a servlet response, an exception must be translated into a response.
2) 4 ways to translate exceptions to response: 1) Some Spring exceptions are mapped by default to specific HTTP status codes; 2) map exceptions to HTTP status codes using @ResponseStatus; 3) annotate method with @ExceptionHandler. 4) @ControllerAdvice for global exception handling
2.1) Some Spring exceptions are mapped by default to specific HTTP status codes, if something going wrong in DispatcherServlet or while performing validation, an exception will be thrown and resulting in a response with a mapped status code.
2.2) map exceptions to HTTP status codes using @ResponseStatus: @ResponseStatus(value=HttpStatus.NOT_FOUND, reason="Spittle Not Found"),the response would have a status code of 404 and a reason of Spittle Not Found.
2.3) annotate method with @ExceptionHandler: @ExceptionHandler(DuplicateSpittleException.class) public String handleDuplicateSpittle() { return "error/duplicate";}. DuplicateSpittleException will be caught and return to view "error/duplicate", @ExceptionHandler methods handle exceptions from any handler method in the "same controller".
2.4) @ControllerAdvice for global exception handling: WebConfig requires @EnableWebMvc, create exception, create AppWideExceptionHandler class and annotated with @ControllerAdvice, create exception handler method in the class

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- No matter what happens, good or bad, the outcome of a servlet request is a servlet response. If an exception occurs during request processing, the outcome is still a servlet response. Somehow, the exception must be translated into a response.
- Spring offers a handful of ways to translate exceptions to responses:
1) Certain Spring exceptions are automatically mapped to specific HTTP status codes.
2) An exception can be annotated with @ResponseStatus to map it to an HTTP status code.
3) A method can be annotated with @ExceptionHandler to handle the exception.

#Mapping exceptions to HTTP status codes, Some Spring exceptions are mapped by default to HTTP status codes:
- BindException 400 - Bad Request
- ConversionNotSupportedException 500 - Internal Server Error
- HttpMediaTypeNotAcceptableException 406 - Not Acceptable
- HttpMediaTypeNotSupportedException 415 - Unsupported Media Type
- HttpMessageNotReadableException 400 - Bad Request
- HttpMessageNotWritableException 500 - Internal Server Error
- HttpRequestMethodNotSupportedException 405 - Method Not Allowed
- MethodArgumentNotValidException 400 - Bad Request
- MissingServletRequestParameterException 400 - Bad Request
- MissingServletRequestPartException 400 - Bad Request
- NoSuchRequestHandlingMethodException 404 - Not Found
- TypeMismatchException 400 - Bad Request

- The exceptions above are usually thrown by Spring itself as the result of something going wrong in DispatcherServlet or while performing validation. For example, if DispatcherServlet can’t find a controller method suitable to handle a request, a NoSuchRequestHandlingMethodException will be thrown, resulting in a response with a status code of 404 (Not Found).
- in the event of any exception that isn’t otherwise mapped, the response will always have a 500 status code.

-Spring offers a way to map exceptions to HTTP status codes via the @ResponseStatus annotation.
@ResponseStatus(value=HttpStatus.NOT_FOUND, reason="Spittle Not Found")
public class SpittleNotFoundException extends RuntimeException {
}
- After introducing this @ResponseStatus annotation, if a SpittleNotFoundException were to be thrown from a controller method, the response would have a status code of 404 and a reason of Spittle Not Found.

#Writing exception-handling methods
@ExceptionHandler(DuplicateSpittleException.class)
public String handleDuplicateSpittle() {
	return "error/duplicate";
}
- The @ExceptionHandler annotation has been applied to the handleDuplicateSpittle() method, designating it as the go-to method when a DuplicateSpittle-
Exception is thrown. It returns a String, which, just as with the request-handling method, specifies the logical name of the view to render, telling the user that they attempted to create a duplicate entry.
- @ExceptionHandler methods handle exceptions from any handler method in the "same controller".

#Advising controllers
- As of Spring 3.2, by using a controller advice class, spring can handle exceptions thrown from handler methods in any controller. 
- create a base controller class that all of your controllers could extend to inherit the common @ExceptionHandler method.
- Spring 3.2 brings another option to the table: controller advice. A controller advice is any class that’s annotated with @ControllerAdvice and has one or more of the following kinds of methods:
1) @ExceptionHandler-annotated
2) @InitBinder-annotated
3) @ModelAttribute-annotated
-Those methods in an @ControllerAdvice-annotated class are applied globally across all @RequestMapping-annotated methods on all controllers in an application.
-One of the most practical uses for @ControllerAdvice is to gather all @ExceptionHandler methods in a single class so that exceptions from all controllers are handled consistently in one place.
@ControllerAdvice
public class AppWideExceptionHandler {
	@ExceptionHandler(DuplicateSpittleException.class)
	public String duplicateSpittleHandler() {
		return "error/duplicate";
	}
}
- Those methods in an @ControllerAdvice-annotated class are applied globally across all @RequestMapping-annotated methods on all controllers in an application.

#Test cases:
1) map exceptions to HTTP status codes via the @ResponseStatus annotation. (done)
@ResponseStatus(value= HttpStatus.NOT_FOUND, reason = "spittle not found")
public class SpittleNotFoundException extends RuntimeException {
}
- 很难看，没什么用
2) exception-handling methods (done)
- create exception
public class DuplicateSpittleException extends RuntimeException {
}
- config exception handler nethod in controller 
@ExceptionHandler(DuplicateSpittleException.class)
public String handleDuplicateSpittle() {		//exception can be passed into the method: handleDuplicateSpittle(DuplicateSpittleException e)
	return "error/duplicate";
}
- more friendly (done)
3) @ControllerAdvice
- WebConfig requires @EnableWebMvc
- create exception
- careate AppWideExceptionHandler
@ControllerAdvice
public class AppWideExceptionHandler {
	@ExceptionHandler(DuplicateSpittleException.class)
	public String duplicateSpittleHandler() {
		return "error/duplicate";
	}
}
- very userful
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Carrying data across redirect requests
总而言之，(carrying data across Spring MVC redirect)
1) redirect after handling POST request prevents the client from reissuing a dangerous POST request by clicking the Refresh or back-arrow button in browser.
2) when redirect happens, the original request ends and a new HTTP GET request begins. Any model data carried in the original request are lost.
3) 2 options to get the data from the redirecting method to the redirect handling method: 1) Passing data as path variables and/or query parameters using URL templates; 2) Sending data in flash attributes
3.1) using templates to define redirect URLs, return "redirect:/spitter/{username}"; 
3.2) set the value in the model; attribute in the model map to placeholder will be part of the redirect url
3.3) attribute from the model doesn’t map to any URL placeholders will be added to the redirect automatically as a query parameter. 
3.4) Sending data across a redirect via path variables and query parameters is only good for sending simple values, such as String and numeric values. There’s no good way to send anything more complex such as an object in a URL. 
3.5) use flash attributes via RedirectAttributes, a sub-interface of Model: model.addFlashAttribute("spitter", spitter); 
3.6) Flash attributes are stored in the session and then retrieved into the model, surviving a redirect.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- it’s generally a good practice to perform a redirect after handling a POST request. Among other things, this prevents the client from reissuing a dangerous POST request if the user clicks the Refresh or back-arrow button in their browser.
- when a controller method results in a redirect, the original request ends and a new HTTP GET request begins. Any model data carried in the original request dies with the request. The new request is devoid of any model data in its attributes and has to figure it out on its own.
- a couple of options to get the data from the redirecting method to the redirect handling method:
1) Passing data as path variables and/or query parameters using URL templates
2) Sending data in flash attributes

#Redirecting with URL templates
- for example, the newly created Spitter’s username is passed as a path variable. But as it’s currently written, the username value is concatenated to the redirect String. That works, but it’s far from bulletproof. String concatenation is dangerous business when constructing things like URLs and SQL queries.
return "redirect:/spitter/" + username ; 
- Instead of concatenating your way to a redirect URL, Spring offers the option of using templates to define redirect URLs.
return "redirect:/spitter/{username}"; <Test> <Test done>
- All you need to do is set the value in the model. To do that, the processRegistration() needs to be written to accept a Model as a parameter and populate it with the username: <Test> <Test-Done>
@RequestMapping(value="/register", method=POST)
public String processRegistration(Spitter spitter, Model model) {
		spitterRepository.save(spitter);
		model.addAttribute("username", spitter.getUsername());
		return "redirect:/spitter/{username}";
}

- Because it’s filled into the placeholder in the URL template instead of concatenated into the redirect String, any unsafe characters in the username property are escaped.
- This is safer than allowing the user to type in whatever they want for the username and then appending it to the path.

- What’s more, any other primitive values in the model are also added to the redirect URL as query parameters. <Test> <Test-Done>
@RequestMapping(value="/register", method=POST)
	public String processRegistration(Spitter spitter, Model model) {
	spitterRepository.save(spitter);
	model.addAttribute("username", spitter.getUsername());
	model.addAttribute("spitterId", spitter.getId());
	return "redirect:/spitter/{username}";
}
- because the spitterId attribute from the model doesn’t map to any URL placeholders in the redirect, it’s tacked on to the redirect automatically as a query parameter. If the username attribute is habuma and the spitterId attribute is 42, then the resulting redirect path will be /spitter/habuma?spitterId=42.

- Sending data across a redirect via path variables and query parameters is only good for sending simple values, such as String and numeric values. There’s no good way to send anything more complex in a URL. <Test> <Test-Done> exception thrown when an object is add to attributes and redirect.

#Working with flash attributes
- Let’s say that instead of sending a username or ID in the redirect, you want to send the actual Spitter object.
- A Spitter object is a bit more complex than a String or an int. Therefore, it can’t easily be sent as a path variable or a query parameter. It can, however, be set as an attribute in the model.
- But as we’ve already discussed, model attributes are ultimately copied into the request as request attributes and are lost when the redirect takes place. Therefore, you need to put the Spitter object somewhere that will survive the redirect.
- One option is to put the Spitter into the session. A session is long-lasting, spanning multiple requests. So you could put the Spitter into the session before the redirect and then retrieve it from the session after the redirect. Of course, you’re also responsible for cleaning it up from the session after the redirect.
- As it turns out, Spring agrees that putting data into the session is a great way to pass information that survives a redirect. But Spring doesn’t think you should be responsible for managing that data. Instead, Spring offers the capability of sending the data as flash attributes. Flash attributes, by definition, carry data until the next request; then they go away.  
- Spring offers a way to set flash attributes via RedirectAttributes, a sub-interface of Model added in Spring 3.1. RedirectAttributes offers everything that Model offers, plus a few methods for setting flash attributes.
@RequestMapping(value="/register", method=POST)
	public String processRegistration(Spitter spitter, RedirectAttributes model) {
			spitterRepository.save(spitter);
			model.addAttribute("username", spitter.getUsername());
			model.addFlashAttribute("spitter", spitter);
			return "redirect:/spitter/{username}";
}

- Flash attributes are stored in the session and then retrieved into the model, surviving a redirect. <Test> <Test-Done>
@RequestMapping(value="/{username}", method=GET)
public String showSpitterProfile(@PathVariable String username, Model model) {
	if (!model.containsAttribute("spitter")) {		
	//only if the model doesn’t contain a spitter attribute, then showSpitterProfile() will look up the Spitter from the repository 
		model.addAttribute(
			spitterRepository.findByUsername(username));
	}
	return "profile";
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 16 Spring REST

总而言之 (Spring MVC restful request and response)
1) controller works at Java Object level and do not concern with resources representation (json, xml, html...)
2) 2 options to convert a resource’s Java representation into the representation to the client: 1) Content negotiation 2) Message conversion
2.1) Content negotiation: still rely on view resolving and rendering machnism, a view is selected that can render the model into a representation to be served to the client.
2.2) Message conversion: bypass the view resolving and rendering machnism, a message converter transforms an object returned from the controller into a representation to be served to the client.
3) Content negotiation match view name and find representation suitable to the client. first looks at the URL’s file extension then considers the Accept header
4) three ways to configure a ContentNegotiationManager: 1) Directly declare a bean whose type is ContentNegotiationManager. (more complicated) 2) Create the bean indirectly via ContentNegotiationManagerFactoryBean. 3) Override the configureContentNegotiation() method of WebMvcConfigurerAdapter.
5) For Java configuration, the easiest way to get a ContentNegotiationManager is to extend WebMvcConfigurerAdapter and override the configureContentNegotiation() method.
6) then inject ContentNegotiationManager into the contentNegotiationManager property of ContentNegotiatingViewResolver.
7) A common configuration: ContentNegotiatingViewResolver defaults to HTML views but renders JSON output for certain view names.
8) ContentNegotiatingViewResolver's benefits and limitation: 1) layered approach,no change in controller code; 2) userful with more overlap; 3) but overlap is not much; 4) cannot handle different request foramt; 5) subtle difference in rendering format
9) Message conversion bypass view machnism. message converter convert the java object from controller to a resource representation in json/xml/text/... using MappingJacksonHttpMessageConverter, MappingJackson2HttpMessageConverter, FormHttpMessageConverter, Jaxb2RootElementHttpMessageConverter, JAXB2-annotated objects, StringHttpMessageConverter...
10) @ResponseBody: tell Spring to skip the normal model/view flow and use a message converter instead: @ResponseBody List<Spittle>
11) DispatcherServlet considers the request’s Accept header and looks for a message converter that can give the client the representation it wants.
12) Jackson JSON libraries use reflection in producing the JSON, you can influence how the JSON is produced by applying Jackson’s mapping annotations on the Java type. e.g. @JsonIgnore
13) @RequestBody: tells Spring to find a message converter to convert a resource representation coming from a client into an object: @RequestBody Spittle spittle.
14) DispatcherServlet will look at the Content-Type header of the request and try to find a message converter that can convert the request body into the java object
15) @RestController: @RestController = @Controller + @ResponseBody. if you’re writing a controller that has several methods, all of which should use message conversion, Spring 4.0 introduced the @RestController annotation which applies message conversion to all handler methods in the controller. You don’t need to annotate each method with @ResponseBody.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- controllers usually don’t concern themselves with how resources are represented. Controllers deal with resources in terms of the Java objects
that define them.
- two options to transform a resource’s Java representation into the representation to the client:
1)Content negotiation—A view is selected that can render the model into a representation to be served to the client.
2)Message conversion—A message converter transforms an object returned from the controller into a representation to be served to the client.

- Match view name + find representation suitable to the client
- ContentNegotiatingViewResolver considers the Accept header and uses whatever media types it asks for, but only after it first looks at the URL’s file extension.
There are three ways to configure a ContentNegotiationManager:
1) Directly declare a bean whose type is ContentNegotiationManager. (more complicated)
2) Create the bean indirectly via ContentNegotiationManagerFactoryBean.
3) Override the configureContentNegotiation() method of WebMvcConfigurerAdapter.

- ContentNegotiationManager is relatively new to Spring, having been introduced in Spring 3.2. As of Spring 3.2, most of the setter methods of ContentNegotiatingViewResolver have been deprecated, and you’re encouraged to configure it via a ContentNegotiationManager.

- Generally speaking, ContentNegotiationManagerFactoryBean is most useful when you’re configuring the ContentNegotiationManager in XML. configure a ContentNegotiationManager with a default content type of application/json in XML:
<bean id="contentNegotiationManager" class="org.springframework.http.ContentNegotiationManagerFactoryBean" p:defaultContentType="application/json">
- ContentNegotiationManagerFactoryBean is an implementation of FactoryBean, this results in a ContentNegotiationManager bean being created.
- That ContentNegotiationManager can then be injected into ContentNegotiatingViewResolver’s contentNegotiationManager property.

<Test> <Test done>
- For Java configuration, the easiest way to get a ContentNegotiationManager is to extend WebMvcConfigurerAdapter and override the configureContentNegotiation() method. In WebConfig:

@Override
public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
	configurer.defaultContentType(MediaType.APPLICATION_JSON);
}

- inject ContentNegotiationManager into the contentNegotiationManager property of ContentNegotiatingViewResolver.
@Bean
public ViewResolver cnViewResolver(ContentNegotiationManager cnm) {	
	ContentNegotiatingViewResolver cnvr = new ContentNegotiatingViewResolver();
	cnvr.setContentNegotiationManager(cnm);
	return cnvr;
}

- common configuration: ContentNegotiatingViewResolver defaults to HTML views but renders JSON output for certain view names.
@Override
public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
	configurer.defaultContentType(MediaType.TEXT_HTML);
}

@Bean
public ViewResolver beanNameViewResolver() {
	return new BeanNameViewResolver();
}

@Bean
public View spittles() {
	return new MappingJackson2JsonView();
}

- Under most circumstances, ContentNegotiatingViewResolver assumes that the client wants HTML, as configured in its ContentNegotiationManager. 
- But if the client specifies that it wants JSON (either with a .json extension on the request path or via the Accept header), then ContentNegotiatingViewResolver attempts to find a view resolver that can serve a JSON view.
- If the logical view name is “spittles”, then the configured BeanNameViewResolver resolves the View declared in the spittles() method. That’s because the bean name matches the logical view name. 
- Otherwise, unless there’s another matching View, ContentNegotiatingViewResolver falls back to the default, serving HTML. Once ContentNegotiatingViewResolver knows what media types the client wants, it’s time to find a view that can render that kind of content.

#THE BENEFITS AND LIMITATIONS OF CONTENTNEGOTIATINGVIEWRESOLVER
- The key benefit of using ContentNegotiatingViewResolver is that it layers REST resource representation on top of the Spring MVC with no change in controller code. The same controller method that serves human-facing HTML content can also serve JSON or XML to a non-human client.
- Content negotiation is a convenient option when there’s a great deal of overlap between your human and non-human interfaces.
- In practice, though, human-facing views rarely deal at the same level of detail as a REST API. The benefit of ContentNegotiatingViewResolver isn’t realized when there isn’t much overlap between the human and non-human interfaces.
- As a ViewResolver implementation, it only has an opportunity to determine how a resource is rendered to a client. It has no say in what representations a controller can consume from the client. If the client is sending JSON or XML, then ContentNegotiatingViewResolver isn’t much help.
- The View chosen renders the model—not the resource—to the client. this is a subtle but important distinction. 

#Working with HTTP message converters
- Message conversion is a more direct way to transform data produced by a controller into a representation that’s served to a client. When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. In fact, there is no model, and there is no view. There is only data produced by the controller and a resource representation produced when a message converter transforms that data.
- list of converters:
MappingJacksonHttpMessageConverter: json<->object or hashmap
MappingJackson2HttpMessageConverter: same as above
FormHttpMessageConverter: application/x-www-form-urlencoded<->MultiValueMap<String,String>. MultiValueMap<String, Object>->multipart/form-data.
Jaxb2RootElementHttpMessageConverter: XML (either text/xml or application/xml)<->JAXB2-annotated objects.
StringHttpMessageConverter: (*/*) -> String, String->text/plain

- For example, suppose the client has indicated via the request’s Accept header that it can accept application/json. Assuming that the Jackson JSON library is in the application’s classpath, the object returned from the handler method is given to MappingJacksonHttpMessageConverter for conversion into a JSON representation to be returned to the client. 
- On the other hand, if the request header indicates that the client prefers text/xml, then Jaxb2RootElementHttpMessageConverter is tasked with
producing an XML response to the client.
- if you want to use MappingJacksonHttpMessageConverter to convert JSON messages to and from Java objects, you’ll need to add the Jackson JSON Processor library to the classpath. same applied to Jaxb2RootElementHttpMessageConverter.

#RESPONSE BODY
- Normally, when a handler method returns a Java object (anything other than String or an implementation of View), that object ends up in the model for rendering in the view. But if you’re going to employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message converter instead. There are a handful of ways to do this, but the simplest is to annotate the controller method with @ResponseBody.
@RequestMapping(method=RequestMethod.GET, produces="application/json")
public @ResponseBody List<Spittle> spittles(
	@RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max,
	@RequestParam(value="count", defaultValue="20") int count) {
	return spittleRepository.findSpittles(max, count);
}
- The @ResponseBody annotation tells Spring that you want to send the returned object as a resource to the client, converted into some representational form that the client can accept. More specifically, DispatcherServlet considers the request’s Accept header and looks for a message converter that can give the client the representation it wants. <Test> <Test Done>

- the Jackson JSON libraries use reflection in producing the JSON resource representation from the returned object. For simple representations, this may be fine. But if you refactor the Java type by adding, removing, or renaming properties, then the produced JSON will be changed as well (which might break clients, depending on those properties). 
- You can influence how the JSON is produced by applying Jackson’s mapping annotations on the Java type. This gives you more control over what the resulting JSON looks like and prevents changes that could break your API and its clients. Jackson’s mapping annotations are well outside the scope of this book, but there’s some useful documentation on the subject at http://wiki.fasterxml.com/Jackson-Annotations. <Test> <Test Done>
e.g. 
@JsonIgnore
private final Long id;

#REQUEST BODY
- @RequestBody tells Spring to find a message converter to convert a resource representation coming from a client into an object.
@RequestMapping(method=RequestMethod.POST, consumes="application/json")
public @ResponseBody
Spittle saveSpittle(@RequestBody Spittle spittle) {
	return spittleRepository.save(spittle);
}
- the Spittle parameter is annotated with @RequestBody, Spring will look at the Content-Type header of the request and try to find a message converter that can convert the request body into a Spittle.
- For example, if the client sent the Spittle data in a JSON representation, then the Content-Type header might be set to application/json. In that case, DispatcherServlet will look for a message converter that can convert JSON into Java objects. <Test> <Test Done>

@RestController
- @RestController = @Controller + @ResponseBody
- if you’re writing a controller that has several methods, all of which should use message conversion, Spring 4.0 introduced the @RestController annotation 
which applies message conversion to all handler methods in the controller. You don’t need to annotate each method with @ResponseBody.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Serving more than resources
总而言之, sending headers and status code in restful Spring MVC 
1) A good REST API does more than transfer resources between the client and server. It also gives the client additional metadata such as headers and status code to help the client understand the resource or know what has just taken place in the request.
2) 3 ways to communicate errors to the client:
2.1) use @ResponseStatus annotation to return a status codes
2.2) use ResponseEntity to return more metadata concerning the response: ResponseEntity<Spittle> spittleById(@PathVariable long id); return new ResponseEntity<Spittle>(spittle, status);
2.3) use exception handler to deal with the error cases, leaving the handler methods to focus on the happy path. 
- First, define an Error object with code and message
- second, update controller method when error situation happens, throw a excetpion
- third, defining an error handler for Exception
3) sending response header: use HttpHeaders and ResponseEntity to send response header: 
4) HttpHeaders headers = new HttpHeaders(); headers.setLocation(locationUri); ResponseEntity<Spittle> responseEntity = new ResponseEntity<Spittle>(spittle, headers, HttpStatus.CREATED)
5) The UriComponentsBuilder given to the handler method is preconfigured with known information such as the host, port, and servlet content. It obtains this foundational information from the request that the handler method is serving.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- there’s more to a response than the payload. There are headers and status codes that can also provide useful information about the response to the client. Let’s see how to populate response headers and set the status code when serving resources.
- A good REST API does more than transfer resources between the client and server. It also gives the client additional metadata to help the client understand the resource or know what has just taken place in the request.

#Communicating errors to the client
@RequestMapping(value="/{id}", method=RequestMethod.GET)
public @ResponseBody Spittle spittleById(@PathVariable long id) {
	return spittleRepository.findOne(id);
}

- if spittleById() returns null, the body of the response is empty. <Test> <Test Done> status code=200, response body is empty
- No useful data is returned to the client. Meanwhile, the default HTTP status code carried on the response is 200 (OK), which means everything is fine.

- Spring offers a few options for dealing with such scenarios:
1） Status codes can be specified with the @ResponseStatus annotation.	<Test> 
2) Controller methods can return a ResponseEntity that carries more metadata concerning the response. <Test> <Test Done> 
- return status 404 and {"code": 1,"message": "spittle not found"}
3) An exception handler can deal with the error cases, leaving the handler methods to focus on the happy path. <Test> <Test Done>

#WORKING WITH RESPONSEENTITY
@RequestMapping(value="/{id}", method=RequestMethod.GET)
public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
	Spittle spittle = spittleRepository.findOne(id);
	HttpStatus status = spittle != null ? HttpStatus.OK : HttpStatus.NOT_FOUND;
	return new ResponseEntity<Spittle>(spittle, status);
}
- if spittle no found, return status 404, body is empty
- Notice that spittleById() isn’t annotated with @ResponseBody. In addition to carrying response headers, a status code, and a payload, ResponseEntity implies the semantics of @ResponseBody, so the payload will be rendered into the response body just as if the method were annotated with @ResponseBody. There’s no need to annotate the method with @ResponseBody if it returns ResponseEntity.

- configure the body to carry additional error information.
- First, define an Error object to carry the error information:
public class Error {
	private int code;
	private String message;
	public Error(int code, String message) {
		this.code = code;
		this.message = message;
	}
	public int getCode() {
		return code;
	}
	public String getMessage() {
		return message;
	}
}

Then you can change spittleById() to return the Error:
@RequestMapping(value="/{id}", method=RequestMethod.GET)
public ResponseEntity<?> spittleById(@PathVariable long id) {
	Spittle spittle = spittleRepository.findOne(id);
	if (spittle == null) {
		Error error = new Error(4, "Spittle [" + id + "] not found");
		return new ResponseEntity<Error>(error, HttpStatus.NOT_FOUND);
	}
	return new ResponseEntity<Spittle>(spittle, HttpStatus.OK);
}

- There’s a bit more logic involved, including a conditional statement. And the fact that the method returns ResponseEntity<?> feels wrong. The generic use of ResponseEntity leaves too much open for interpretation or mistake.

#HANDLING ERRORS
- The if block in spittleById() is handling an error. But that’s what controller error handlers are good for. Error handlers deal with the ugly realities of what could go wrong, leaving the regular handler methods to blissfully focus on the happy path.
- defining an error handler that reacts to a SpittleNotFoundException:
@ExceptionHandler(SpittleNotFoundException.class)
public ResponseEntity<Error> spittleNotFound(SpittleNotFoundException e) {
	long spittleId = e.getSpittleId();
	Error error = new Error(4, "Spittle [" + spittleId + "] not found");
	return new ResponseEntity<Error>(error, HttpStatus.NOT_FOUND);
}

-define Exception:
public class SpittleNotFoundException extends RuntimeException {
	private long spittleId;
	public SpittleNotFoundException(long spittleId) {
		this.spittleId = spittleId;
	}
	public long getSpittleId() {
	return spittleId;
	}
}

- remove most of the error handling from the spittleById() method:
@RequestMapping(value="/{id}", method=RequestMethod.GET)
	public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
	Spittle spittle = spittleRepository.findOne(id);
	if (spittle == null) { throw new SpittleNotFoundException(id); }
	return new ResponseEntity<Spittle>(spittle, HttpStatus.OK);
}

- cleanup#1: spittleById() will return a Spittle and that the HTTP status will always be 200 (OK), you no longer need to use ResponseEntity and can replace it with @ResponseBody:
@RequestMapping(value="/{id}", method=RequestMethod.GET)
public @ResponseBody Spittle spittleById(@PathVariable long id) {
	Spittle spittle = spittleRepository.findOne(id);
	if (spittle == null) { throw new SpittleNotFoundException(id); }
	return spittle;
}

- cleanup#2: Knowing that the error handler method always returns an Error and always responds with an HTTP status code of 404 (Not Found), you can apply a similar cleanup:
@ExceptionHandler(SpittleNotFoundException.class)
@ResponseStatus(HttpStatus.NOT_FOUND)
public @ResponseBody Error spittleNotFound(SpittleNotFoundException e) {
    long spittleId = e.getSpittleId();
    return new Error(4, "Spittle [" + spittleId + "] not found");
}

- In some ways, you’ve gone full circle. In order to set the response status code, you began using ResponseEntity. But then you were able to use an exception handler and @ResponseStatus to eliminate the need for ResponseEntity and tighten up the code.

#Setting headers in the response
- when something was just created, and an HTTP status code communicates that to the client. HTTP 201 says that the request completed successfully <Test> <Test Done>
@RequestMapping(method=RequestMethod.POST, consumes="application/json")
@ResponseStatus(HttpStatus.CREATED)
public Spittle saveSpittle(@RequestBody Spittle spittle) {
	return spittleRepository.save(spittle);
}
- communicate the resource’s URL to the client in the Location header of the response
- HttpHeaders is a special implementation of MultiValueMap<String, String> with some convenient setter methods (such as setLocation()), for setting common HTTP headers.
@RequestMapping(method=RequestMethod.POST, consumes="application/json")
public ResponseEntity<Spittle> saveSpittle(@RequestBody Spittle spittle) {
	Spittle spittle = spittleRepository.save(spittle);
	HttpHeaders headers = new HttpHeaders();
	URI locationUri = URI.create("http://localhost:8080/spittr/spittles/" + spittle.getId());
	headers.setLocation(locationUri);
	ResponseEntity<Spittle> responseEntity = new ResponseEntity<Spittle>(spittle, headers, HttpStatus.CREATED)
	return responseEntity;
}

- Spring offers some help in the form of UriComponentsBuilder. It’s a builder class that lets you build up a UriComponents instance by specifying the various components of the URI (such as the host, port, path, and query) a piece at a time. From the UriComponents object that UriComponentsBuilder builds, you can obtain a URI suitable for setting the Location header.
@RequestMapping(method=RequestMethod.POST, consumes="application/json")
public ResponseEntity<Spittle> saveSpittle(@RequestBody Spittle spittle, UriComponentsBuilder ucb) {
Spittle spittle = spittleRepository.save(spittle);
	HttpHeaders headers = new HttpHeaders();
	URI locationUri = ucb.path("/spittles/")
							.path(String.valueOf(spittle.getId()))
							.build()
							.toUri();
	headers.setLocation(locationUri);
	ResponseEntity<Spittle> responseEntity =
	new ResponseEntity<Spittle>(
	spittle, headers, HttpStatus.CREATED)
	return responseEntity;
}
- The UriComponentsBuilder given to the handler method is preconfigured with known information such as the host, port, and servlet content. It obtains this foundational information from the request that the handler method is serving.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Consuming REST resources
总而言之，(RestTemplate)
1) Commonly, mobile and JavaScript applications are the clients of a REST API, but there’s no reason a Spring application can’t consume those resources, too.
2) 11 operations overloaded into 3 froms, 
2.1) One that takes a java.net.URI as the URL specification with no support for parameterized URLs (URI as parameters
2.2) One that takes a String URL specification with URL parameters specified as a Map (string URL + map of parameters )
2.3) One that takes a String URL specification with URL parameters specified as a variable argument list (string URL + varialbes parameters list )
3) getForObject() Sends an HTTP GET request, returning an object mapped from a response body
4) getForEntity() Sends an HTTP GET request, returning a ResponseEntity containing an object mapped from the response body, capable of retriving headers
5) postForObject() POSTs data to a URL, returning an object mapped from the response body
6) postForEntity() POSTs data to a URL, returning a ResponseEntity containing an object mapped from the response body, capable of retriving headers
7) postForLocation() POSTs data to a URL, returning the URL of the newly created resource, just return the url
8) exchange() Executes a specified HTTP method against a URL, returning a ResponseEntity containing an object mapped from the response body, capable of setting headers on the request
9) execute() Executes a specified HTTP method against a URL, returning an object mapped from the response body
10) headForHeaders() Sends an HTTP HEAD request, returning the HTTP headers for the specified resource URL
11) optionsForAllow() Sends an HTTP OPTIONS request, returning the Allow header for the specified URL
12) delete() Performs an HTTP DELETE request on a resource at a specified URL 
13) put() PUTs resource data to the specified URL

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#2 for get <Test> <Test Done>
- getForObject() Sends an HTTP GET request, returning an object mapped from a response body <Test>
<T> T getForObject(URI url, Class<T> responseType) throws RestClientException;
<T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException;
<T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException;

- Under the covers, getForObject() converts the response body into an object for you. It does this by relying on the same set of HTTP message converters from table 16.1 that Spring MVC uses for handler methods that are annotated with @ResponseBody.

- getForEntity() Sends an HTTP GET request, returning a ResponseEntity containing an object mapped from the response body <Test>
<T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException;
<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables) throws RestClientException;
<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException;

#3 for post <Test> <Test Done>
- postForObject() POSTs data to a URL, returning an object mapped from the response body
- postForEntity() POSTs data to a URL, returning a ResponseEntity containing an object mapped from the response body
- postForLocation() POSTs data to a URL, returning the URL of the newly created resource

# exchange <Test> <Test Done>
- exchange() Executes a specified HTTP method against a URL, returning a ResponseEntity containing an object mapped from the response body 
- getForEntity() and postForEntity() give you the resulting resource wrapped in a ResponseEntity from which you can retrieve response headers and status codes. But what if you want to set headers on the request sent to the server? That’s what RestTemplate’s exchange() methods are good for.
<T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType) throws RestClientException;
<T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException;
<T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException;

#execute
- execute() Executes a specified HTTP method against a URL, returning an object mapped from the response body

# headForHeaders()
- headForHeaders() Sends an HTTP HEAD request, returning the HTTP headers for the specified resource URL

#optionsForAllow()
optionsForAllow() Sends an HTTP OPTIONS request, returning the Allow header for the specified URL

#delete
delete() Performs an HTTP DELETE request on a resource at a specified URL 
#put
put() PUTs resource data to the specified URL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

9. Chapter9 Spring Security Web
总而言之，(Spring security - web)
1) security framework provides declarative security, authentication and authorization at both the web request level and at the method invocation level, relying on DI and AOP, uses servlet filters to secure web requests and AOP to secure method.
2) first step is configure a DelegatingFilterProxy intercept requests and delegate them to a bean whose ID is springSecurityFilterChain
3) springSecurityFilterChain bean is another special filter known as FilterChainProxy that chains together one or more additional filters. (authentication, authorization...)
4) DelegatingFilterProxy configured in xml: <filter-name>springSecurityFilterChain</filter-name><filter-class>	org.springframework.web.filter.DelegatingFilterProxy</filter-class>
5) DelegatingFilterProxy configured in java: create a new class that extends AbstractSecurityWebApplicationInitializer. 
6) Congiure secutiry: @Configuration, @EnableWebMvcSecurity, public class SecurityConfig extends WebSecurityConfigurerAdapter == security-context.xml
7) @EnableWebMvcSecurity configures a "Spring MVC argument resolver" so that handler methods can receive the authenticated user’s principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden CSRF token field on forms using Spring’s form-binding tag library.
8) override WebSecurityConfigurerAdapter’s three configure() methods:
8.1) configure(WebSecurity): Override to configure Spring Security’s filterchain.
8.2) configure(HttpSecurity): Override to configure how requests are secured by interceptors.
8.3) configure(AuthenticationManagerBuilder): Override to configure user-details services.
9) overide configure(AuthenticationManagerBuilder): several common user store situations—such as in-memory, relational database, and LDAP—are provided out of the box. you can also create and plug in custom user store implementations.
9.1) auth.inMemoryAuthentication().withUser("user").password("password").roles("USER").and()...
9.2) auth.jdbcAuthentication().dataSource(dataSource)
			.usersByUsernameQuery("select username, password, true from Spitter where username=?")
			.authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
			.passwordEncoder(new StandardPasswordEncoder("53cr3t"));
9.3) auth.ldapAuthentication().userSearchBase("ou=people").userSearchFilter("(uid={0})").groupSearchBase("ou=groups").groupSearchFilter("member={0}")
			.contextSource().url("ldap://habuma.com:389/dc=habuma,dc=com");
9.4) auth.userDetailsService(new SpitterUserService(spitterRepository)); public class SpitterUserService implements UserDetailsService {
		@Override
		public UserDetails loadUserByUsername(String username) 	throws UsernameNotFoundException {...}
	}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Spring Security basics
- Spring Security is a security framework that provides declarative security for Spring-based applications. 
- Spring Security provides a solution for authentication and authorization at both the web request level and at the method invocation level. 
- Sring Security takes full advantage of DI and AOP.
- To secure web requests and restrict access at the URL level, Spring Security uses servlet filters. Spring Security can also secure method invocations using Spring AOP
- commonly used modules include the Core and Configuration modules, the Web module, JSP tag library module.
- DelegatingFilterProxy is a special servlet filter that, by itself, doesn’t do much. Instead, it delegates to an implementation of javax.servlet.Filter that’s registered as a <bean> in the Spring application context
- Whether you configure DelegatingFilterProxy in web.xml or by subclassing AbstractSecurityWebApplicationInitializer, it will intercept requests coming
into the application and delegate them to a bean whose ID is springSecurityFilterChain.
- config In Xml: 
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>
		org.springframework.web.filter.DelegatingFilterProxy
	</filter-class>
</filter>

- configure DelegatingFilterProxy in Java with a WebApplicationInitializer, then all you need to do is create a new class that extends Abstract-
SecurityWebApplicationInitializer: SecurityWebInitializer == <filter-name>springSecurityFilterChain</filter-name> in xml

import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;
public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
- AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer, so it will be discovered by Spring and be used to register DelegatingFilterProxy with the web container
- As for the springSecurityFilterChain bean itself, it’s another special filter known as FilterChainProxy. It’s a single filter that chains together one or more additional filters.

#Writing a simple security configuration, SecurityConfig == security-context.xml
@Configuration
@EnableWebSecurity	//enables web security in any web application.
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}

- Spring Security must be configured in a bean that implements WebSecurityConfigurer or (for convenience) extends WebSecurityConfigurerAdapter. Any bean in the Spring application context that implements WebSecurityConfigurer can contribute to Spring Security configuration, but it’s often most convenient for the configuration class to extend WebSecurityConfigurerAdapter 
- @EnableWebSecurity is generally useful for enabling security in any web application. But if you happen to be developing a Spring MVC application, you should consider using @EnableWebMvcSecurity instead

@Configuration
@EnableWebMvcSecurity //enables spring mvc security
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}
- Among other things, the @EnableWebMvcSecurity annotation configures a "Spring MVC argument resolver" so that handler methods can receive the authenticated user’s principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden cross-site request forgery (CSRF) token field on forms using Spring’s form-binding tag library.

- You can configure web security by overriding WebSecurityConfigurerAdapter’s three configure() methods and setting behavior on the parameter passed in.
configure(WebSecurity): Override to configure Spring Security’s filterchain.
configure(HttpSecurity): Override to configure how requests are secured by interceptors.
configure(AuthenticationManagerBuilder): Override to configure user-details services.

- the default filter chain is fine for our needs, the default configure(HttpSecurity) effectively looks like this: <Test> <Test Done> default login page and default error shown
protected void configure(HttpSecurity http) throws Exception {
	http
	.authorizeRequests()
	.anyRequest().authenticated()
	.and()
	.formLogin().and()
	.httpBasic();
}
- The call to authorizeRequests() and anyRequest().authenticated() demands that all HTTP requests coming into the application be authenticated. It also configures Spring Security to support authentication via a form-based login (using a predefined login page) as well as HTTP Basic.
- Meanwhile, because you haven’t overridden the configure(AuthenticationManagerBuilder) method, there’s no user store backing the authentication process.
- need to add a bit more configuration to bend Spring Security to fit your application’s needs.
1) Configure a user store
2) Specify which requests should and should not require authentication, as well as what authorities they require
3) Provide a custom login screen to replace the plain default login screen

#Selecting user details services
- Several common user store situations—such as in-memory, relational database, and LDAP—are provided out of the box. But you can also create and plug in custom user store implementations.

#Working with an in-memory user store
- override the configure() method that takes an AuthenticationManagerBuilder as a parameter. AuthenticationManagerBuilder has several methods that can be used to configure Spring Security’s authentication support. 
- With the inMemoryAuthentication() method, you can enable and configure and optionally populate an in-memory user store. <Test> <Test Done>
@Configuration 
@EnableWebMvcSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.inMemoryAuthentication()
		.withUser("user").password("password").roles("USER").and()
		.withUser("admin").password("password").roles("USER", "ADMIN");
	}
}
- calling inMemoryAuthentication() will enable an in-memory user store.
- call the withUser() method to add a new user to the inmemory user store
- withUser() returns a UserDetailsManagerConfigurer.UserDetailsBuilder,which has several methods for further configuration of the user, including password() to set the user’s password and roles() to give the user one or more role authorities.
- the and() method is used to chain together multiple user configurations.
- all of the methods available from UserDetailsManagerConfigurer.UserDetailsBuilder:
accountExpired(boolean): Defines if the account is expired or not
accountLocked(boolean): Defines if the account is locked or not 
and(): Used for chaining configuration
authorities(GrantedAuthority…): Specifies one or more authorities to grant to the user
authorities(List<? extends GrantedAuthority>): Specifies one or more authorities to grant to the user
authorities(String…): Specifies one or more authorities to grant to the user
credentialsExpired(boolean): Defines if the credentials are expired or not 
disabled(boolean): Defines if the account is disabled or not 
password(String): Specifies the user’s password
roles(String…): Specifies one or more roles to assign to the user

#Authenticating against database tables 
@Autowired
DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.jdbcAuthentication()
	.dataSource(dataSource);
}

- Although this minimal configuration will work, it makes some assumptions about your database schema. default SQL queries that will be performed when looking up user details:
public static final String DEF_USERS_BY_USERNAME_QUERY = "select username,password,enabled from users where username = ?";
public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY = "select username,authority from authorities where username = ?";
public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = "select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id";

- customize sql: <Test> <Test Done>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.jdbcAuthentication()
	.dataSource(dataSource)
	.usersByUsernameQuery("select username, password, true from Spitter where username=?")
	.authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
}
- In this case, you’re only overriding the authentication and basic authorization queries. But you can also override the group authorities query by calling groupAuthoritiesByUsername() with a custom query.

#WORKING WITH ENCODED PASSWORDS <Test>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.jdbcAuthentication()
	.dataSource(dataSource)
	.usersByUsernameQuery("select username, password, true from Spitter where username=?")
	.authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?")
	.passwordEncoder(new StandardPasswordEncoder("53cr3t"));
}
- The passwordEncoder method accepts any implementation of Spring Security’s PasswordEncoder interface. Spring Security’s cryptography module includes
three such implementations: BCryptPasswordEncoder, NoOpPasswordEncoder, and StandardPasswordEncoder.
- No matter which password encoder you use, it’s important to understand that the password in the database is never decoded. Instead, the password that the user enters at login is encoded using the same algorithm and is then compared with the encoded password in the database.

#Applying LDAP-backed authentication
- simple configuration for LDAP authentication <Test>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.ldapAuthentication()
	.userSearchFilter("(uid={0})")
	.groupSearchFilter("member={0}");
}

- The userSearchFilter() and groupSearchFilter() methods are used to provide a filter for the base LDAP queries, which are used to search for users and groups. By default, the base queries for both users and groups are empty, indicating that the search will be done from the root of the LDAP hierarchy. <Test>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.ldapAuthentication()
	.userSearchBase("ou=people")
	.userSearchFilter("(uid={0})")
	.groupSearchBase("ou=groups")
	.groupSearchFilter("member={0}");
}

#CONFIGURING PASSWORD COMPARISON
- The default strategy for authenticating against LDAP is to perform a bind operation, authenticating the user directly to the LDAP server. 
- Another option is to perform a comparison operation. This involves sending the entered password to the LDAP directory and asking the server to compare the password against a user’s password attribute. Because the comparison is done within the LDAP server, the actual password remains secret.
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.ldapAuthentication()
	.userSearchBase("ou=people")
	.userSearchFilter("(uid={0})")
	.groupSearchBase("ou=groups")
	.groupSearchFilter("member={0}")
	.passwordCompare()	//authenticate by doing a password comparison
	.passwordEncoder(new Md5PasswordEncoder())	//specify an encryption strategy
	.passwordAttribute("passcode"); //specify the password attribute’s name
}

#REFERRING TO A REMOTE LDAP SERVER <Test>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.ldapAuthentication()
		.userSearchBase("ou=people")
		.userSearchFilter("(uid={0})")
		.groupSearchBase("ou=groups")
		.groupSearchFilter("member={0}")
		.contextSource()
			.url("ldap://habuma.com:389/dc=habuma,dc=com");
}

#CONFIGURING AN EMBEDDED LDAP SERVER <Test>
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
	.ldapAuthentication()
		.userSearchBase("ou=people")
		.userSearchFilter("(uid={0})")
		.groupSearchBase("ou=groups")
		.groupSearchFilter("member={0}")
		.contextSource()
			.root("dc=habuma,dc=com");
			.ldif("classpath:users.ldif"); 	//specify ldif location, if ignored, locate ldif from classpath
}

- When the LDAP server starts, it will attempt to load data from any LDIF files that it can find in the classpath. LDIF (LDAP Data Interchange Format) is a standard way of representing LDAP data in a plain text file. Each record is composed of one or more lines, each containing a name:value pair. Records are separated from each other by blank lines.
- ldif:
dn: ou=groups,dc=habuma,dc=com
objectclass: top
objectclass: organizationalUnit
ou: groups
dn: ou=people,dc=habuma,dc=com
objectclass: top
objectclass: organizationalUnit
ou: people
dn: uid=habuma,ou=people,dc=habuma,dc=com
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Craig Walls
sn: Walls
uid: habuma
userPassword: password
dn: uid=jsmith,ou=people,dc=habuma,dc=com
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: John Smith
sn: Smith
uid: jsmith
userPassword: password
dn: cn=spittr,ou=groups,dc=habuma,dc=com
objectclass: top
objectclass: groupOfNames
cn: spittr
member: uid=habuma,ou=people,dc=habuma,dc=com

#Using Active directory <Test>

#Configuring a custom user service
- Suppose that you need to authenticate against users in a non-relational database such as Mongo or Neo4j. In that case, you’ll need to implement a custom implementation of the UserDetailsService interface.
public interface UserDetailsService {
	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}

- an implementation of UserDetailsService that looks up a user from a given implementation of SpitterRepository. <Test> <Test Done>
public class SpitterUserService implements UserDetailsService {
	private final SpitterRepository spitterRepository;
	public SpitterUserService(SpitterRepository spitterRepository) {
		this.spitterRepository = spitterRepository;
	}
	@Override
	public UserDetails loadUserByUsername(String username) 	throws UsernameNotFoundException {
		Spitter spitter = spitterRepository.findByUsername(username);
		if (spitter != null) {
			List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();
			authorities.add(new SimpleGrantedAuthority("ROLE_SPITTER"));
			return new User(spitter.getUsername(), spitter.getPassword(), authorities);
		}
		throw new UsernameNotFoundException"User '" + username + "' not found.");
	}
}

- To use SpitterUserService to authenticate users, you can configure it in your security configuration with the userDetailsService() method:
@Autowired
SpitterRepository spitterRepository;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.userDetailsService(new SpitterUserService(spitterRepository));
}
- The userDetailsService() method (like jdbcAuthentication(), ldapAuthentication, and inMemoryAuthentication()) configures a configuration store. But instead of using one of Spring’s provided user stores, it takes any implementation of UserDetailsService.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#commons-lang包中对我们有用的类主要有:
1.StringUtils 该类主要提供对字符串的操作,对null是安全的,主要提供了字符串查找,替换,分割,去空白,去掉非法字符等等操作
2.ObjectUtils 主要是对null进行安全处理,可以设置为null时的默认返回值,比较相等时是调用对象的equals方法,因此需要对对象进行方法进行覆盖
3.SystemUtils 主要获取一些系统属性,例如工作目录等等
4.DateUtils/CalendarUtils 主要提供了对日期的操作,包括日期加减,日期格式化,日期比较,一定时间范围内日期的迭代等等
5.StopWatch 提供秒表的计时,暂停等功能
6. EqualsBuilder/HashCodeBuilder提供了方便的方法来覆盖equals() 和hashCode()方法
7.以Range结尾的类主要提供一些范围的操作,包括判断某些字符,数字等是否在这个范围以内
8.ArrayUtils 提供了数组的复制,查找,获取子数组,反转等功能

#Intercepting requests
总而言之 (spring security - intercepting request)
1）override the configure (HttpSecurity) method to configure intercept rules
2) use antMatchers() and regexMatchers() to define request pattern
3) use authenticated, hasRole, hasAuthority, access... for diffrent path, use anyRequest().permitAll() at the end
4) configure the most specific request path patterns first and the least specific ones (such as anyRequest()) last
5) Use access() to apply SpEL for declaring access requirements: .antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER') and hasIpAddress('192.168.1.2')")
6) Enforcing channel security: .requiresChannel().antMatchers("/spitter/form").requiresSecure();
7) Authenticating users with default login form: .formLogin()
8) Preventing CSRF: CSRF attack happens when one site tricks a user into submitting a request to another server, possibly having a negative outcome.
9) Spring Security implements CSRF protection with a synchronizer token. State-changing requests (for example, any request that is not GET, HEAD, OPTIONS, or TRACE) will be intercepted and checked for a CSRF token.
10) If you’re using JSP, <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />; if using Thymeleaf or spring form binding taglib, CSRF token will be added automatically.
11) disable csrf: .csrf().disable();

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- The key to fine-tuning security for each request is to override the configure (HttpSecurity) method.
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
		.antMatchers("/spitters/me").authenticated()
		.antMatchers(HttpMethod.POST, "/spittles").authenticated()
		.anyRequest().permitAll();
}
<Test> <Test Done>

- The path given to antMatchers() supports Ant-style wildcarding:
.antMatchers("/spitters/**").authenticated();

- specify multiple paths in a single call to antMatchers():
.antMatchers("/spitters/**", "/spittles/mine").authenticated();

- regexMatchers() method that accepts regular expressions to define request paths.
.regexMatchers("/spitters/.*").authenticated(); // equivalent to /spitters/**

#Configuration methods to define how a path is to be secured
access(String): Allows access if the given SpEL expression evaluates to true
anonymous(): Allows access to anonymous users
authenticated(): Allows access to authenticated users
denyAll(): Denies access unconditionally
fullyAuthenticated(): Allows access if the user is fully authenticated (not remembered)
hasAnyAuthority(String…): Allows access if the user has any of the given authorities
hasAnyRole(String…): Allows access if the user has any of the given roles
hasAuthority(String): Allows access if the user has the given authority
hasIpAddress(String): Allows access if the request comes from the given IP address
hasRole(String): Allows access if the user has the given role
not(): Negates the effect of any of the other access methods
permitAll(): Allows access unconditionally
rememberMe(): Allows access for users who are authenticated via remember-me

- require that the user not only be authenticated, but also have ROLE_SPITTER authority:
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
		.antMatchers("/spitters/me").hasAuthority("ROLE_SPITTER")
		.antMatchers(HttpMethod.POST, "/spittles")
		.hasAuthority("ROLE_SPITTER")
		.anyRequest().permitAll();
}

- use the hasRole() method to have the ROLE_ prefix applied automatically:
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
		.antMatchers("/spitter/me").hasRole("SPITTER")
		.antMatchers(HttpMethod.POST, "/spittles").hasRole("SPITTER")
		.anyRequest().permitAll();
}

- it’s important to configure the most specific request path patterns first and the least specific ones (such as anyRequest()) last. If not, then the least specific paths will trump the more specific ones.

#Securing with Spring Expressions
- Using the access() method, you can also use SpEL as a means for declaring access requirements.
.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER')")
- Spring Security extends the Spring Expression Language with several security-specific expressions
authentication: The user’s authentication object
denyAll: Always evaluates to false
hasAnyRole(list of roles): True if the user has any of the given roles
hasRole(role): True if the user has the given role
hasIpAddress(IP address): True if the request comes from the given IP address
isAnonymous(): True if the user is anonymous
isAuthenticated(): True if the user is authenticated
isFullyAuthenticated(): True if the user is fully authenticated (not authenticated with remember-me)
isRememberMe(): True if the user was authenticated via remember-me
permitAll: Always evaluates to true
principal: The user’s principal object

- you can do more than just limit access based on a user’s granted authorities.
.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER') and hasIpAddress('192.168.1.2')") <Test> <Test Done> <Test Fail>

#Enforcing channel security <Test> <Test Done>
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
		.antMatchers("/spitter/me").hasRole("SPITTER")
		.antMatchers(HttpMethod.POST, "/spittles").hasRole("SPITTER")
		.anyRequest().permitAll();
		.and()
		.requiresChannel()
		.antMatchers("/spitter/form").requiresSecure();
}

- Any time a request comes in for /spitter/form, Spring Security will see that it requires a secure channel (per the call to requiresSecure()) and automatically redirect the request to go over HTTPS.
- declare that the home page always be sent over HTTP by using requiresInsecure() instead of requiresSecure:
.antMatchers("/").requiresInecure();

#Authenticating users
- as soon as you override configure(HttpSecurity), you lose that simple login page. you can add it back: <Test> <Test Done>
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.formLogin()
		.and()
		.authorizeRequests()
		.antMatchers("/spitter/me").hasRole("SPITTER")
		.antMatchers(HttpMethod.POST, "/spittles").hasRole("SPITTER")
		.anyRequest().permitAll();
		.and()
		.requiresChannel()
		.antMatchers("/spitter/form").requiresSecure();
}

#Preventing cross-site request forgery
- CSRF attack happens when one site tricks a user into submitting a request to another server, possibly having a negative outcome.

- As you’ll recall, our SpittleController will create a new Spittle for a user when a POST request is submitted to /spittles. But what if that POST request comes from another website? And what if that POST request is the result of submitting the following form on that other site?
<form method="POST" action="http://www.spittr.com/spittles"> <Test> <Test Done>
	<input type="hidden" name="message" value="I'm stupid!" />
	<input type="submit" value="Click here to win a new car!" />
</form>

- Starting with Spring Security 3.2, CSRF protection is enabled by default. In fact, unless you take steps to work with CSRF protection or disable it, you’ll probably have trouble getting the forms in your application to submit successfully.
- Spring Security implements CSRF protection with a synchronizer token. State-changing requests (for example, any request that is not GET, HEAD, OPTIONS, or TRACE) will be intercepted and checked for a CSRF token.
- This means that any forms in your application must submit a token in a _csrf field. And that token must be the same as the one calculated and stored by the server so that it matches up when the form is submitted.

- Spring Security makes this easy for you by putting the token into the request under the request attributes. If you’re using Thymeleaf for your page template, you’ll get the hidden _csrf field automatically, as long as the <form> tag’s action attribute is prefixed to come from the Thymeleaf namespace:
<form method="POST" th:action="@{/spittles}">
...
</form>
- If you’re using JSP for page templates, you can do something very similar:
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
- using Spring’s form-binding tag library, the <sf:form> tag will automatically add the hidden CSRF token tag for you.

#Disable CSRF protection <Test> <Test Done>
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		...
		.csrf()
		.disable();
}

-  it’s generally not a good idea to disable CSRF protection. If you do, you leave your application open to a CSRF attack.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Custom login form
总而言之 (spring security - custom login form)
1) configure custom login form:
1.1）create a custom login page with <input type='text' name='username'> <input type='password' name='password'/> action='/login'
1.2) controller handler method to toute /login to the login page
1.3) In configure(HttpSecurity http) throws Exception {} http.formLogin().loginPage("/login")
2) Enabling HTTP Basic authentication: .httpBasic().realmName("Spittr")
3) Enabling remember-me: .rememberMe().tokenValiditySeconds(2419200).key("spittrKey"); include a remember-me parameter in the login page:
<input id="remember_me" name="remember-me" type="checkbox"/>
4) The token that’s stored in the cookie is made up of the username, password, an expiration date, and a private key—all encoded in an MD5 hash before being written to the cookie. 
5) Enabling logout: <a href="/logout">Logout</a>; .logout().logoutSuccessUrl("/").logoutUrl("/signout")

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- HTML source of the default login page:
<html>
	<head><title>Login Page</title></head>
	<body onload='document.f.username.focus();'>
		<h3>Login with Username and Password</h3>
		<form name='f' action='/spittr/login' method='POST'> //submit to /login
			<table>
				<tr><td>User:</td><td>
				<input type='text' name='username' value=''></td></tr>	//username
				<tr><td>Password:</td>
				<td><input type='password' name='password'/></td></tr>	//password
				<tr><td colspan='2'>
				<input name="submit" type="submit" value="Login"/></td></tr> 
				<input name="_csrf" type="hidden" value="6829b1ae-0a14-4920-aac4-5abbd7eeb9ee" />	//csrf
			</table>
		</form>
	</body>
</html>

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	    .formLogin()
	    .loginPage("/login")
	    .and()
	    .authorizeRequests()
	    .antMatchers("/spitter/me").authenticated()
	    .antMatchers(HttpMethod.POST, "/spittles").authenticated()
	    .anyRequest().permitAll();
	...
}

#Enabling HTTP Basic authentication <Test> <Test No effect>
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.formLogin()
		.loginPage("/login")
		.and()
		.httpBasic()
		.realmName("Spittr")
		.and()
		...
}

#Enabling remember-me functionality <Test> <Test Done>
- call rememberMe() on the HttpSecurity to turn on remember-me support:
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.formLogin()
		.loginPage("/login")
		.and()
		.rememberMe()
		.tokenValiditySeconds(2419200)
		.key("spittrKey")
		...
}

- By default, a remember-me token is stored in a cookie that’s valid for up to two weeks. But this example specifies that the token should stay valid
for up to four weeks (2,419,200 seconds). 
- The token that’s stored in the cookie is made up of the username, password, an expiration date, and a private key—all encoded in an MD5 hash before being written to the cookie. 
- By default, the private key is SpringSecured, but this example sets it to spitterKey to make it specific to the Spittr application.

- the login request will need to include a remember-me parameter:
<input id="remember_me" name="remember-me" type="checkbox"/>
<label for="remember_me" class="inline">Remember me</label>

#Logging out <Test> <Test Done>
- Logout is implemented as a servlet filter that (by default) intercepts requests to /logout. Therefore, adding logout to an application is as easy as adding the following link:
<a th:href="@{/logout}">Logout</a> or
<a href="/logout">Logout</a>

- When the user clicks on the link, the request for /logout will be handled by Spring Security’s LogoutFilter. 
- The user will be logged out and any remember-me tokens cleared. 
- After the logout is complete, the user’s browser will be redirected to /login?logout to give the user an opportunity to log in again.
- you can configure HttpSecurity to have the user redirected to some other page, such as the application’s home page: <Test> <Test Done>
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.formLogin()
		.loginPage("/login")
		.and()
		.logout()
		.logoutSuccessUrl("/")
		...
}
- you may want to also override the default path that LogoutFilter intercepts. <Test> <Test Done>
.logout()
	.logoutSuccessUrl("/")
	.logoutUrl("/signout")
- logout link is now /signout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Securing the view
总而言之 (spring security - securing view)
1) When rendering HTML to be served in the browser, you may want the view to reflect the security constraints and information.
2) declare the JSP tag library: <%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %>
2.1) <security:accesscontrollist>: Conditionally renders its body content if the user is granted authorities by an access control list
2.2) <security:authentication>: Renders details about the current authentication. e,g, Hello <security:authentication property="principal.username" />!
2.3) <security:authorize>: Conditionally renders its body content if the user is granted certain authorities or if a SpEL expression evaluates to true
<sec:authorize access="hasRole('ROLE_SPITTER')">, <security:authorize access="isAuthenticated() and principal.username=='habuma'">
3) restrict access based on url: <span sec:authorize-url="/admin">
4) Spring Security for Thymeleaf: Thymeleaf’s security dialect offers attributes that mirror much of Spring Security’s tag library
4.1) sec:authentication -  Renders properties of the authentication object. Similar to Spring Security’s <sec:authentication/> JSP tag.
4.2) sec:authorize - Conditionally renders content based on evaluation of an expression. Similar to Spring Security’s <sec:authorize/> JSP tag.
4.3) sec:authorize-acl - Conditionally renders content based on evaluation of an expression. Similar to Spring Security’s <sec:accesscontrollist/> JSP tag.
4.4) sec:authorize-expr - An alias for the sec:authorize attribute.
4.5) sec:authorize-url - Conditionally renders content based on evaluation of security rules associated with a given URL path. Similar to Spring Security’s
					<sec:authorize/> JSP tag when using the url attribute.
5)register the SpringSecurityDialect with the SpringTemplateEngine in your configuration: templateEngine.addDialect(new SpringSecurityDialect());
6) declare the security namespace in the templates: xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">
7) In thymeleaf template Hello <span sec:authentication="name">someone</span>; <span sec:authorize-url="/admin">

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- When rendering HTML to be served in the browser, you may want the view to reflect the security constraints and information.

#Using Spring Security’s JSP tag library
<security:accesscontrollist>: Conditionally renders its body content if the user is granted authorities by an access control list
<security:authentication>: Renders details about the current authentication 
<security:authorize>: Conditionally renders its body content if the user is granted certain authorities or if a SpEL expression evaluates to true

- declare the JSP tag library:
<%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %>

#ACCESSING AUTHENTICATION DETAILS <Test> <Test Done>
Hello <security:authentication property="principal.username" />!

- You can access several of the user’s authentication details using the <security:authentication> JSP tag
authorities: A collection of GrantedAuthority objects that represent the privileges granted to the user
credentials: The credentials that were used to verify the principal (commonly, this is the user’s password)
details: Additional information about the authentication (IP address, certificate serial number, session ID, and so on)
principal: The user’s principal
- assign it to a property named loginId: 
<security:authentication property="principal.username" var="loginId"/>
- The variable is created in page scope by default. But if you’d rather create it in some other scope, such as request or session (or any of the scopes available from javax.servlet.jsp.PageContext), you can specify it via the scope attribute.
<security:authentication property="principal.username" var="loginId" scope="request" />

#CONDITIONAL RENDERING <Test> <Test Done>
- Spring Security’s <security:authorize> JSP tag conditionally renders a portion of the view depending on the user’s granted authorities.
- use the <security:authorize> tag to display the spittle form if the user has ROLE_SPITTER authority
<sec:authorize access="hasRole('ROLE_SPITTER')">
	<s:url value="/spittles" var="spittle_url" />
	<sf:form modelAttribute="spittle" action="${spittle_url}">
	...
	</sf:form>
</sec:authorize>

- you have the full power of SpEL at your disposal：
<security:authorize access="isAuthenticated() and principal.username=='habuma'">
	<a href="/admin">Administration</a>
</security:authorize>

# restrict access based on url <Test> <Test Done>
- Adding a new call to the antMatchers() method in the security configuration will tighten security around the /admin URL:
.antMatchers("/admin")
.access("isAuthenticated() and principal.username=='admin'");
- the url attribute indirectly refers to the security constraints for a given URL pattern.
<security:authorize url="/admin">
	<spring:url value="/admin" var="admin_url" />
	<a href="${admin_url}">Admin</a>
</security:authorize>

#Working with Thymeleaf’s Spring Security dialect 
- Thymeleaf’s security dialect offers attributes that mirror much of Spring Security’s tag library
sec:authentication -  Renders properties of the authentication object. Similar to Spring Security’s <sec:authentication/> JSP tag.
sec:authorize - Conditionally renders content based on evaluation of an expression. Similar to Spring Security’s <sec:authorize/> JSP tag.
sec:authorize-acl - Conditionally renders content based on evaluation of an expression. Similar to Spring Security’s <sec:accesscontrollist/> JSP tag.
sec:authorize-expr - An alias for the sec:authorize attribute.
sec:authorize-url - Conditionally renders content based on evaluation of security rules associated with a given URL path. Similar to Spring Security’s
					<sec:authorize/> JSP tag when using the url attribute.

- Thymeleaf Extras Spring Security module is in your application’s classpath.
- register the SpringSecurityDialect with the SpringTemplateEngine in your configuration.
@Bean
public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) {
	SpringTemplateEngine templateEngine = new SpringTemplateEngine();
	templateEngine.setTemplateResolver(templateResolver);
	templateEngine.addDialect(new SpringSecurityDialect()); //Register the security dialect
	return templateEngine;
}
- declare the security namespace in the templates:
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:th="http://www.thymeleaf.org"
	xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">
	...
</html>

- Now you can use the Thymeleaf attributes however you see fit. e.g. render text saying “Hello” to the user if the user is authenticated: <Test>
<div sec:authorize="isAuthenticated()">
	Hello <span sec:authentication="name">someone</span>
</div>

- using sec:authorize-url attribute to conditionally render based on the authorizations associated with a given URL path: <Test>
<span sec:authorize-url="/admin">
	<a th:href="@{/admin}">Admin</a>
</span>

- Using a series of servlet filters, Spring Security can control access to web resources, including Spring MVC controllers. But thanks to Spring Security’s Java configuration model, you don’t need to deal with those filters directly. Web security can be declared concisely.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

10. Chapter 14 - Spring Security - securing methods
总而言之， (securing methods)
1) 3 ways to secure methods
1.1) Spring Security’s own @Secured
1.2) JSR-250’s @RolesAllowed
1.3) Expression-driven annotations, with @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter
2) create method security class with @EnableGlobalMethodSecurity(securedEnabled=true) and extends GlobalMethodSecurityConfiguration
3) When securedEnabled is true, a pointcut is created such that the Spring Security aspects will wrap bean methods that are annotated with @Secured.
4) annotated method with @Secured: @Secured({"ROLE_SPITTER", "ROLE_ADMIN"}) public void addSpittle(Spittle spittle) {...}
5) @EnableGlobalMethodSecurity(jsr250Enabled=true) and annotated method with @RolesAllowed
6) using the standard @RolesAllowed annotation may have implications when used in the context of other frameworks or APIs that process that annotation.
7) Using expression-driven annotations: Sometimes security constraints depend on more than just whether a user has privileges or not.
7.1) @EnableGlobalMethodSecurity(prePostEnabled=true)
7.2) @PreAuthorize： Restricts access to a method before invocation based on the result of evaluating an expression:
- @PreAuthorize("(hasRole('ROLE_SPITTER') and #spittle.message.length() <= 140) or hasRole('ROLE_PREMIUM')") 
7.3) @PostAuthorize Allows a method to be invoked, but throws a security exception if the expression evaluates to false: 
- @PostAuthorize("returnObject.spitter.username == principal.username")
7.4) @PostFilter Allows a method to be invoked, but filters the results of that method based on an expression
- @PostFilter( "hasRole('ROLE_ADMIN') || filterObject.spitter.username == principal.username")
7.5) @PreFilter Allows a method to be invoked, but filters input prior to entering the method
- @PreFilter( "hasRole('ROLE_ADMIN') || filterObject.spitter.username == principal.username")
8) permission evaluator: @PreFilter("hasPermission(targetObject, 'delete')"); public class SpittlePermissionEvaluator implements PermissionEvaluator {...
	public boolean hasPermission(Authentication authentication, Object target, Object permission) {...}}
9) register it with Spring Security for it to back the hasPermission() operation in the expression: expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Securing methods with annotations
1) Spring Security’s own @Secured
2) JSR-250’s @RolesAllowed
3) Expression-driven annotations, with @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter

#Restricting method access with @Secured
@Configuration
@EnableGlobalMethodSecurity(securedEnabled=true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()
			.withUser("user").password("password").roles("USER");
	}
}

- In addition to being annotated with @EnableGlobalMethodSecurity, you’ll notice that the configuration class extends GlobalMethodSecurityConfiguration. Much
like the WebSecurityConfigurerAdapter class that your web security configuration class extended in chapter 9, this class offers you the opportunity to configure the finer points of method-level security.
- @EnableGlobalMethodSecurity annotation, notice that its securedEnabled attribute is set to true. When securedEnabled is true, a pointcut is
created such that the Spring Security aspects will wrap bean methods that are annotated with @Secured.
@Secured("ROLE_SPITTER") <Test> <Test Done>
public void addSpittle(Spittle spittle) {
	// ...
}

@Secured({"ROLE_SPITTER", "ROLE_ADMIN"})
public void addSpittle(Spittle spittle) {
	// ...
}

- When the method is invoked by an unauthenticated user or by a user not possessing the required privileges, the aspect wrapping the method will throw one of Spring Security’s exceptions (probably a subclass of AuthenticationException or AccessDeniedException). These are unchecked exceptions,

#Using JSR-250’s @RolesAllowed with Spring Security <Test> <Test Done>
- using the standard @RolesAllowed annotation may have implications when used in the context of other frameworks or APIs that process that annotation.
@Configuration
@EnableGlobalMethodSecurity(jsr250Enabled=true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}

- restrict the invocation of a method based only on whether or not that user has been granted a specific privilege. No other factors can play a part in
the decision to allow the method to execute or not.

#Using expressions for method-level security
- Sometimes security constraints depend on more than just whether a user has privileges or not.
@PreAuthorize： Restricts access to a method before invocation based on the result of evaluating an expression
@PostAuthorize Allows a method to be invoked, but throws a security exception if the expression evaluates to false
@PostFilter Allows a method to be invoked, but filters the results of that method based on an expression
@PreFilter Allows a method to be invoked, but filters input prior to entering the method

- But first, you’ll need to enable them by setting @EnableGlobalMethodSecurity’s prePostEnabled attribute to true:

#PREAUTHORIZING METHOD ACCESS <Test> <test Done>
@PreAuthorize("(hasRole('ROLE_SPITTER') and #spittle.message.length() <= 140) or hasRole('ROLE_PREMIUM')")
public void addSpittle(Spittle spittle) {
	// ...
}

#POSTAUTHORIZING METHOD ACCESS <Test> <Test Done>
@PostAuthorize("returnObject.spitter.username == principal.username")
public Spittle getSpittleById(long id) {
	// ...
}

- Spring Security provides the returnObject variable in SpEL.
- unlike methods annotated with @PreAuthorize, @PostAuthorize-annotated methods will be executed first and intercepted afterward. That means that care should be taken to make sure that the method doesn’t have any side effects that would be undesirable if authorization fails.

#Filtering method inputs and outputs <Test> <Test Done>
- Sometimes it’s not the method that’s being secured, but rather the data being passed into or returned from that method.
@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
@PostFilter( "hasRole('ROLE_ADMIN') || filterObject.spitter.username == principal.username")
public List<Spittle> getOffensiveSpittles() {
	...
}

#PREFILTERING METHOD PARAMETERS <Test> <Test Done>
@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
@PreFilter( "hasRole('ROLE_ADMIN') || filterObject.spitter.username == principal.username")
public void deleteSpittles(List<Spittle> spittles) { ... }

#DEFINING A PERMISSION EVALUATOR （Custom codes for security) <Test> <Test Done>
@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
@PreFilter("hasPermission(targetObject, 'delete')")
public void deleteSpittles(List<Spittle> spittles) { 
	... 
}

- asks the question “Does the user have permission to delete the target object?” If so, the expression will evaluate to true and the Spittle will remain in the list passed to deleteSpittles(). If not, then it will be tossed out.
- hasPermission() function is a Spring Security–provided extension to SpEL, and it represents an opportunity for you, the developer, to plug in whatever logic you want to perform when it’s evaluated.

public class SpittlePermissionEvaluator implements PermissionEvaluator {
	private static final GrantedAuthority ADMIN_AUTHORITY = new GrantedAuthorityImpl("ROLE_ADMIN");
	public boolean hasPermission(Authentication authentication, Object target, Object permission) {
		if (target instanceof Spittle) {
			Spittle spittle = (Spittle) target;
			String username = spittle.getSpitter().getUsername();
			if ("delete".equals(permission)) {
				return isAdmin(authentication) || username.equals(authentication.getName());
			}
		}
		throw new UnsupportedOperationException("hasPermission not supported for object <" + target + "> and permission <" + permission + ">");
	}
	public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
		throw new UnsupportedOperationException();
	}
	private boolean isAdmin(Authentication authentication) {
		return authentication.getAuthorities().contains(ADMIN_AUTHORITY);
	}
}

- SpittlePermissionEvaluator implements Spring Security’s PermissionEvaluator interface, which demands that two different hasPermission() methods be implemented.
- Once the permission evaluator is ready, you need to register it with Spring Security for it to back the hasPermission() operation in the expression given to @PostFilter. To do that, you’ll need to replace the expression handler with one that’s configured to use your custom permission evaluator.
- By default, Spring Security is configured with a DefaultMethodSecurityExpressionHandler that’s given an instance of DenyAllPermissionEvaluator. always returns false from its hasPermission() methods
@Override
protected MethodSecurityExpressionHandler createExpressionHandler() {
	DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
	expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());
	return expressionHandler;
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

11. Chapter 10 - Spring JDBC
总而言之 (spring jdbc datasource)
1）Spring’s data-access philosophy is coding to interface
2) Spring’s data-access exception: 1) providing a consistent exception hierarchy that’s used across all of its supported persistence options. 2)provides several data-access exceptions, each descriptive of the problem for which they’re thrown 3)all of those exceptions are rooted with DataAccessException, an unchecked exception. 4) you must use one of Spring’s supported data-access templates to take advantage of Spring’s data-access exceptions
3) Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks.
4) Configuring a data source: Spring-supported data access you use, you’ll likely need to configure a reference to a data source
4.1) Data sources that are looked up by JNDI: using Java configuration, you can use JndiObjectFactoryBean to look up the DataSource from JNDI
4.2) Data sources that pool connections: 1) Apache Commons DBCP (http://jakarta.apache.org/commons/dbcp), 2) c3p0 (http://sourceforge.net/projects/c3p0/)
3) BoneCP (http://jolbox.com/). <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">, @Bean public BasicDataSource dataSource() {..}
4.3) Data sources that are defined by a JDBC driver:
4.4) embedded data source: public DataSource dataSource() { return new EmbeddedDatabaseBuilder()...build() }
5) Using profiles to select a data source:	configure each of these data sources in different profiles: 
	@Profile("development")
	@Bean
	public DataSource embeddedDataSource()

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Spring’s data-access philosophy
- coding to interfaces. interfaces are key to writing loosely coupled code and that they should be used at all layers of an application,
- factor database access into one or more components called data-access objects (DAOs) or repositories. repositories should expose their functionality through interfaces
- makes your service objects easily testable, because they’re not coupled to a specific data-access implementation. In fact, you could create mock implementations of these data-access interfaces. That would allow you to test your service object without ever having to connect to the database
- the data-access tier is accessed in a persistence technology–agnostic manner. - relevant data-access methods are exposed through the interface. This makes for a flexible application design and allows the chosen persistence framework to be swapped out with minimal impact on the rest of the application.
- If the implementation details of the data-access tier were to leak into other parts of the application, the entire application would become coupled with the data-access tier, leading to a rigid application design.

#Spring’s data-access exception hierarchy
- Spring helps you insulate your data-access tier from the rest of your application is by providing a consistent exception hierarchy that’s used across all of its supported persistence options.
- SQLException means something went wrong while trying to access a database. But there’s little about that exception that tells you what went wrong or how to deal with it.
- SQLException is treated as a one-size-fits-all exception for problems related to data access
- Some persistence frameworks offer a richer hierarchy of exceptions. Hibernate, for example, offers almost two dozen different exceptions, each targeting a specific data-access problem.
- What we need is a hierarchy of data-access exceptions that are descriptive but not directly associated with a specific persistence framework.

#SPRING’S PERSISTENCE PLATFORM–AGNOSTIC EXCEPTIONS
- Spring provides several data-access exceptions, each descriptive of the problem for which they’re thrown
- Spring throws a consistent set of exceptions, regardless of which persistence provider you choose.
- all of those exceptions are rooted with DataAccessException, an unchecked exception.
- To take advantage of Spring’s data-access exceptions, you must use one of Spring’s supported data-access templates.

#Spring's exception philosphy
- DataAccessException is just one example of Spring’s across-the-board philosophy of checked versus unchecked exceptions.
- Spring takes the stance that many exceptions are the result of problems that can’t be addressed in a catch block. 
- Instead of forcing developers to write catch blocks (which are often left empty), Spring promotes the use of unchecked exceptions. This leaves the decision of whether or not to catch an exception in your hands.

#Templating data access
- During language transportation process, you’re involved only when you need to be; the rest is taken care of. This mirrors a powerful design pattern:
the template method pattern.
- In software terms, a template method delegates the implementation-specific portions of the process to an interface. Different implementations of this interface define specific implementations of this portion of the process.
- Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks.
- Spring’s data-access template classes take responsibility for common data-access duties. For application-specific tasks, it calls back into a
custom callback object.
- As you can see, Spring’s template classes handle the fixed parts of data access—controlling transactions, managing resources, and handling exceptions.
- Meanwhile, the specifics of data access as they pertain to your application—creating statements, binding parameters, and marshaling result sets—are handled in the callback implementation.

- Spring comes with several data-access templates, each suitable for a different persistence mechanism.
jca.cci.core.CciTemplate - JCA CCI connections
jdbc.core.JdbcTemplate - JDBC connections
jdbc.core.namedparam.NamedParameterJdbcTemplate - JDBC connections with support for named parameters
jdbc.core.simple.SimpleJdbcTemplate - JDBC connections, simplified with Java 5 constructs (deprecated in Spring 3.1)
orm.hibernate3.HibernateTemplate -  Hibernate 3.x+ sessions
orm.ibatis.SqlMapClientTemplate - iBATIS SqlMap clients
orm.jdo.JdoTemplate - Java Data Object implementations
orm.jpa.JpaTemplate - Java Persistence API entity managers

#Configuring a data source
- Regardless of which form of Spring-supported data access you use, you’ll likely need to configure a reference to a data source:
1) Data sources that are defined by a JDBC driver
2) Data sources that are looked up by JNDI
3) Data sources that pool connections

#Using JNDI data sources
- App servers (Tomcat, WebSphere, JBoss) allow you to configure data sources to be retrieved via JNDI. 
- The benefit of configuring data sources in this way is that they can be managed completely external to the application, allowing the application to ask for a data source when it’s ready to access the database.
- Moreover, data sources managed in an application server are often pooled for greater performance and can be hot-swapped by system administrators.
<jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" />

- using Java configuration, you can use JndiObjectFactoryBean to look up the DataSource from JNDI:
@Bean
public JndiObjectFactoryBean dataSource() {
	JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
	jndiObjectFB.setJndiName("jdbc/SpittrDS");
	jndiObjectFB.setResourceRef(true);
	jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
	return jndiObjectFB;
}

#Using a pooled data source
- open source pooled data source options:
1) Apache Commons DBCP (http://jakarta.apache.org/commons/dbcp)
2) c3p0 (http://sourceforge.net/projects/c3p0/)
3) BoneCP (http://jolbox.com/)

- configure DBCP’s BasicDataSource in xml:
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
	p:driverClassName="org.h2.Driver"
	p:url="jdbc:h2:tcp://localhost/~/spitter"
	p:username="sa"
	p:password=""
	p:initialSize="5"
	p:maxActive="10" />

- In Java configuration:
@Bean
public BasicDataSource dataSource() {
	BasicDataSource ds = new BasicDataSource();
	ds.setDriverClassName("org.h2.Driver");
	ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
	ds.setUsername("sa");
	ds.setPassword("");
	ds.setInitialSize(5);
	ds.setMaxActive(10);
	return ds;
}

#BasicDataSource’s pool-configuration properties
- initialSize: The number of connections created when the pool is started.
- maxActive: The maximum number of connections that can be allocated from the pool at the same time. If 0, there’s no limit.
- maxIdle: The maximum number of connections that can be idle in the pool without extras being released. If 0, there’s no limit.
- maxOpenPreparedStatements: The maximum number of prepared statements that can be allocated from the statement pool at the same time. If 0,
								there’s no limit.
- maxWait: How long the pool will wait for a connection to be returned to the pool (when there are no available connections) before an
				exception is thrown. If 1, wait indefinitely.
- minEvictableIdleTimeMillis: How long a connection can remain idle in the pool before it’s eligible for eviction.
- minIdle The minimum number of connections that can remain idle in the pool without new connections being created.
- poolPreparedStatements: Whether or not to pool prepared statements (Boolean).

#Using JDBC driver-based data sources
Spring offers three such data-source classes to choose from (all in the org.springframework.jdbc.datasource package):
1) DriverManagerDataSource — Returns a new connection every time a connection is requested. Unlike DBCP’s BasicDataSource, the connections provided
by DriverManagerDataSource aren’t pooled.
2) SimpleDriverDataSource — Works much the same as DriverManagerDataSource except that it works with the JDBC driver directly to overcome class loading
issues that may arise in certain environments, such as in an OSGi container.
3) SingleConnectionDataSource — Returns the same connection every time a connection is requested. Although SingleConnectionDataSource isn’t exactly
a pooled data source, you can think of it as a data source with a pool of exactly one connection.

Configuring any of these data sources is similar to how you configured DBCP’s BasicDataSource.
@Bean
public DataSource dataSource() {
	DriverManagerDataSource ds = new DriverManagerDataSource();
	ds.setDriverClassName("org.h2.Driver");
	ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
	ds.setUsername("sa");
	ds.setPassword("");
	return ds;
}

In XML, the DriverManagerDataSource can be configured as follows:
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"
	p:driverClassName="org.h2.Driver"
	p:url="jdbc:h2:tcp://localhost/~/spitter"
	p:username="sa"
	p:password="" />

#Using an embedded data source
- An embedded database runs as part of your application instead of as a separate database server that your application connects to. 
- an embedded database is a perfect choice for development and testing purposes. That’s because it allows you to populate your database with test data that’s reset every time you restart your application or run your tests.

- Spring’s jdbc namespace makes configuring an embedded database simple.
<?xml version="1.0" encoding="UTF-8"?> 
<beans 	xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/jdbc
							http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd
							http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
	...
	<jdbc:embeddeddatabase id="dataSource" type="H2"> 
		<jdbc:script location="com/habuma/spitter/db/jdbc/schema.sql"/> 
		<jdbc:script location="com/habuma/spitter/db/jdbc/test-data.sql"/> 
	</jdbc:embedded-database>
	...
</beans>

- The <jdbc:embedded-database>’s type property is set to H2 to indicate that the embedded database should be an H2 database. (Be sure to have H2 in your application’s classpath.)  <Test>
- Alternatively, you may set type to DERBY to use an embedded Apache Derby database. <Test>
- In addition to setting up an embedded database, the <jdbc:embedded-database> element also exposes a data source that can be used like any of the other data-source beans you’ve seen.

in Java configuration:
@Bean <Test>
public DataSource dataSource() {
	return new EmbeddedDatabaseBuilder()
	.setType(EmbeddedDatabaseType.H2)
	.addScript("classpath:schema.sql")
	.addScript("classpath:test-data.sql")
	.build();
}

#Using profiles to select a data source
- For example, the <jdbc:embedded-database> element is great for development time. 
- But you may want to use DBCP’s BasicDataSource in your QA environment. 
- And perhaps you need to use <jee:jndi-lookup> in your production deployment.
- All you need to do is configure each of these data sources in different profiles: <Test>
@Configuration
public class DataSourceConfiguration {
	@Profile("development")
	@Bean
	public DataSource embeddedDataSource() {
		return new EmbeddedDatabaseBuilder()
			.setType(EmbeddedDatabaseType.H2)
			.addScript("classpath:schema.sql")
			.addScript("classpath:test-data.sql")
			.build();

	@Profile("qa")
	@Bean
	public DataSource Data() {
		BasicDataSource ds = new BasicDataSource();
		ds.setDriverClassName("org.h2.Driver");
		ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
		ds.setUsername("sa");
		ds.setPassword("");
		ds.setInitialSize(5);
		ds.setMaxActive(10);
		return ds;
	}

	@Profile("production")
	@Bean
	public DataSource dataSource() {
		JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
		jndiObjectFactoryBean.setJndiName("jdbc/SpittrDS");
		jndiObjectFactoryBean.setResourceRef(true);
		jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);
		return (DataSource) jndiObjectFactoryBean.getObject();
	}
}

- Using profiles, the data source is chosen at runtime, based on which profile is active.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Using JDBC with Spring
总而言之
1) there are 3 JDBC template classes: JdbcTemplate, NamedParameterJdbcTemplate, SimpleJdbcTemplate. JdbcTemplate should be used.
2) create a jdbcTemplate bean, wiring a dataSource. @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)
3) wire the jdbcTemplate bean into your repository and use it to access the database. 
@Repository
public class JdbcSpitterRepository implements SpitterRepository {
	private JdbcOperations jdbcOperations;
4) update: jdbcOperations.update(INSERT_SPITTER, spitter.getUsername()...}
5) queryForObject: return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, new SpitterRowMapper(), id);		
6) private static final class SpitterRowMapper implements RowMapper<Spitter>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Working with JDBC templates
- Spring abstracts away the boilerplate dataaccess code behind template classes:
1) JdbcTemplate—The most basic of Spring’s JDBC templates, this class provides simple access to a database through JDBC and indexed-parameter queries.
2) NamedParameterJdbcTemplate—This JDBC template class enables you to perform queries where values are bound to named parameters in SQL, rather than
indexed parameters.
3) SimpleJdbcTemplate—This version of the JDBC template takes advantage of Java 5 features such as autoboxing, generics, and variable parameter lists to simplify how a JDBC template is used.
- But starting with Spring 3.1, the decision became easier. SimpleJdbcTemplate has been deprecated and its Java 5 features have been rolled into JdbcTemplate.
- Moreover, you onlyneed NamedParameterJdbcTemplate when you want to work with named parameters in queries.
- That leaves good ol’ JdbcTemplate as your go-to option for most JDBC work

#INSERTING DATA USING JDBCTEMPLATE
1) All that a JdbcTemplate needs in order to do its work is a DataSource:
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
	return new JdbcTemplate(dataSource);
}

2) wire the jdbcTemplate bean into your repository and use it to access the database.
@Repository
public class JdbcSpitterRepository implements SpitterRepository {
	private JdbcOperations jdbcOperations;
	@Inject
	public JdbcSpitterRepository(JdbcOperations jdbcOperations) {
		this.jdbcOperations = jdbcOperations;
	}
	...
}

- Here JdbcSpitterRepository is annotated with @Repository, which qualifies it to be automatically created by component-scanning.
- JdbcOperations is an interface defining operations implemented by JdbcTemplate.
- By injecting a JdbcOperations instead of the concrete JdbcTemplate, JdbcSpitterRepository is able to remain loosely coupled to JdbcTemplate via the Jdbc-
Operations interface.
- With a JdbcTemplate at your repository’s disposal, you can greatly simplify the addSpitter() method <Test>
public void addSpitter(Spitter spitter) {
	jdbcOperations.update(INSERT_SPITTER,
	spitter.getUsername(),
	spitter.getPassword(),
	spitter.getFullName(),
	spitter.getEmail(),
	spitter.isUpdateByEmail());
}

- There’s no more connection or statement-creation code—and no more exception-handling code.
- Internally, JdbcTemplate catches any SQLExceptions that may be thrown. It then translates the generic SQLException into one of the more specific data-access exceptions and rethrows it.

#READING DATA WITH JDBCTEMPLATE <Test> <Test Done>
public Spitter findOne(long id) {
	return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, 			//Query for Spitter
											new SpitterRowMapper(),		//Map results to object
											id);						//sql statement parameters
}

private static final class SpitterRowMapper implements RowMapper<Spitter> {
	public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException {
		return new Spitter(
			rs.getLong("id"),
			rs.getString("username"),
			rs.getString("password"),
			rs.getString("fullName"),
			rs.getString("email"),
			rs.getBoolean("updateByEmail"));
	}
}

- This findOne() method uses JdbcTemplate’s queryForObject() method to query for a Spitter from the database. The queryForObject() method takes three parameters:
1) A String containing the SQL to be used to select the data from the database
2) A RowMapper object that extracts values from a ResultSet and constructs a domain object (in this case, a Spitter)
3) A variable argument list of values to be bound to indexed parameters of the query

#USING JAVA 8 LAMBDAS WITH JDBCTEMPLATE <Test> <Test Done>
- Because the RowMapper interface only declares the addRow() method, it fits the bill for a functional interface. This means that if you’re developing your application using Java 8, you can express the RowMapper implementation with a lambda instead of with a concrete class implementation. <Test>
public Spitter findOne(long id) {
		return jdbcOperations.queryForObject(
			SELECT_SPITTER_BY_ID,
			(rs, rowNum) -> {
				return new Spitter(
					rs.getLong("id"),
					rs.getString("username"),
					rs.getString("password"),
					rs.getString("fullName"),
					rs.getString("email"),
					rs.getBoolean("updateByEmail"));
			},
			id);
}

- Java coerces the lambda into a RowMapper for the sake of satisfying the parameter it’s being passed into.
- Alternatively, you can use Java 8 "method references" to define the mapping in a separate method: <Test> <Test Done>
public Spitter findOne(long id) {
	return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, this::mapSpitter, id);
}
private Spitter mapSpitter(ResultSet rs, int row) throws SQLException {
	return new Spitter(
		rs.getLong("id"),
		rs.getString("username"),
		rs.getString("password"),
		rs.getString("fullName"),
		rs.getString("email"),
		rs.getBoolean("updateByEmail"));
}
- In either event, you don’t have to explicitly implement the RowMapper interface. You must provide a lambda or method that takes the same parameters and returns the same type as if you had implemented RowMapper.

#USING NAMED PARAMETERS
- Named parameters let you give each parameter in the SQL an explicit name and refer to the parameter by that name when binding values to the statement.
private static final String SQL_INSERT_SPITTER = "insert into spitter (username, password, fullname) values (:username, :password, :fullname)";
- With named-parameter queries, the order of the bound values isn’t important. You can bind each value by name:
- NamedParameterJdbcTemplate can be declared in Spring in much the same way as the regular JdbcTemplate:
@Bean
public NamedParameterJdbcTemplate jdbcTemplate(DataSource dataSource) {
	return new NamedParameterJdbcTemplate(dataSource);
}
- Using named parameters with Spring JDBC templates: <Test> <Test Done>
private static final String INSERT_SPITTER = "insert into Spitter (username, password, fullname, email, updateByEmail) values (:username, :password, :fullname, :email, :updateByEmail)";
public void addSpitter(Spitter spitter) {
	Map<String, Object> paramMap = new HashMap<String, Object>();
	paramMap.put("username", spitter.getUsername());
	paramMap.put("password", spitter.getPassword());
	paramMap.put("fullname", spitter.getFullName());
	paramMap.put("email", spitter.getEmail());
	paramMap.put("updateByEmail", spitter.isUpdateByEmail());
	jdbcOperations.update(INSERT_SPITTER, paramMap);
}

12. Chapter11 - Persisting data with object-relational mapping
#more features than JDBC can offer: auto query generation, lazy loading, eager fetching, cascading
- be able to map object properties to database columns and have our statements and queries created for us, freeing us from typing an endless
string of question marks. 
- Lazy loading: As object graphs become more complex, you sometimes don’t want to fetch entire relationships immediately. To use a typical example, suppose
you’re selecting a collection of PurchaseOrder objects, and each of these objects contains a collection of LineItem objects. If you’re only interested in
PurchaseOrder attributes, it makes no sense to grab the LineItem data. That could be expensive. Lazy loading allows you to grab data only as it’s needed.
- Eager fetching: This is the opposite of lazy loading. Eager fetching allows you to grab an entire object graph in one query. In the cases where you know you need a PurchaseOrder object and its associated LineItems, eager fetching lets you get this from the database in one operation, saving you from costly round-trips.
- Cascading: Sometimes changes to a database table should result in changes to other tables as well. Going back to the purchase order example, when an Order
object is deleted, you also want to delete the associated LineItems from the database.

#orm frameworks
Spring provides support for Hibernate, iBATIS, Java Data Objects (JDO), and the Java Persistence API (JPA). provides integration points to the frameworks as well as some additional services:
1) Integrated support for Spring declarative transactions
2) Transparent exception handling
3) Thread-safe, lightweight template classes
4) DAO support classes
5) Resource management

#Integrating Hibernate with Spring
总而言之
1）declare HibernateSessionFactoryBean: set dataSource, hibernateProperties properties and packageToScan or mapper file locations
2) @Inject Hibernate SessionFactory into Repository and configuration bean
3) use that SessionFactory.getCurrentSession() to get the "current transaction’s session"
4) use currentSession().save(), get()....
5) declare PersistenceExceptionTranslationPostProcessor in configuration bean
6) declare transaction manager in configuration bean
7) any hibernate operation needs to be annotated with @Transactional

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Hibenrate provides caching, lazy loading, eager fetching, and distributed caching. (Java Persistence with Hibernate, Second Edition)

#Declaring a Hibernate session factory
- Spring SessionFactoryBean -> Hibernate SessionFactory -> Hibernate Session -> Respository -> DB
- the main interface for working with Hibernate is org.hibernate.Session. The Session interface provides basic data-access functionality such as the ability to save, update, delete, and load objects from the database.
- The standard way to get a reference to a Hibernate Session object is through an implementation of Hibernate’s SessionFactory interface. Among other
things, SessionFactory is responsible for opening, closing, and managing Hibernate Sessions.
- In Spring, the way to get a Hibernate SessionFactory is through one of Spring’s Hibernate sessionfactory beans. As of version 3.1, Spring comes with three sessionfactory beans to choose from:
1) org.springframework.orm.hibernate3.LocalSessionFactoryBean (Hibernate 3.2 or higher + mapping in xml)
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
	LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
	sfb.setDataSource(dataSource);
	sfb.setMappingResources(new String[] { "Spitter.hbm.xml" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}

2) org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean (Hibernate 3.2 or higher + mapping using annotation)
@Bean
public AnnotationSessionFactoryBean sessionFactory(DataSource ds) {
	AnnotationSessionFactoryBean sfb = new AnnotationSessionFactoryBean();
	sfb.setDataSource(ds);
	sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}

3) org.springframework.orm.hibernate4.LocalSessionFactoryBean (Hibernate 4) <Test> <Test Done>
- this new session factory bean added in Spring 3.1 is like a mashup of the Hibernate 3 LocalSessionFactoryBean and AnnotationSessionFactoryBean. it can be configured for either XML-based mapping or annotation-based mapping.

Here’s how you’d configure it for annotation-based mapping:
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
	LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
	sfb.setDataSource(dataSource);
	sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
	Properties props = new Properties();
	props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
	sfb.setHibernateProperties(props);
	return sfb;
}

- the dataSource and hibernateProperties properties specify where to find a database connection and what kind of database you’ll be dealing with. 
- But instead of listing Hibernate mapping files, you can use the packagesToScan property to tell Spring to scan one or more packages, looking for domain classes that are annotated for persistence with Hibernate. This includes classes that are annotated with JPA’s @Entity or @MappedSuperclass and Hibernate’s own @Entity annotation.

- you may also explicitly list all of your application’s persistent classes
sfb.setAnnotatedClasses(
	new Class<?>[] { Spitter.class, Spittle.class }
);

#Building Spring-free Hibernate
- The best practice now, however, is to take advantage of Hibernate contextual sessions and not use HibernateTemplate at all.
- wiring a Hibernate SessionFactory directly into your repository and using it to obtain a session
@Repository
public class HibernateSpitterRepository implements SpitterRepository {

	private SessionFactory sessionFactory;

	@Inject
	public HibernateSpitterRepository(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;		 
	}
	
	private Session currentSession() {
		return sessionFactory.getCurrentSession();
	}
	
	public long count() {
		return findAll().size();
	}

	public Spitter save(Spitter spitter) {
		Serializable id = currentSession().save(spitter); 
		return new Spitter((Long) id, 
				spitter.getUsername(), 
				spitter.getPassword(), 
				spitter.getFullName(), 
				spitter.getEmail(), 
				spitter.isUpdateByEmail());
	}

	public Spitter findOne(long id) {
		return (Spitter) currentSession().get(Spitter.class, id); 
	}

	public Spitter findByUsername(String username) {		
		return (Spitter) currentSession() 
				.createCriteria(Spitter.class) 
				.add(Restrictions.eq("username", username))
				.list().get(0);
	}

	public List<Spitter> findAll() {
		return (List<Spitter>) currentSession() 
				.createCriteria(Spitter.class).list(); 
	}
}
- you’re using the @Inject annotation to have Spring automatically inject a SessionFactory into HibernateSpitterRepository’s sessionFactory property. 
- in currentSession() method, you use that SessionFactory to get the "current transaction’s session".
- PersistenceExceptionTranslationPostProcessor is a bean post-processor that adds an adviser to any bean that’s annotated with @Repository so that any platform-specific exceptions are caught and then rethrown as one of Spring’s unchecked data-access  exceptions.
@Bean
public BeanPostProcessor persistenceTranslation() {
	return new PersistenceExceptionTranslationPostProcessor();
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Java Persistence API
总而言之
1) In spring, use container managed JPA
2) LocalContainerEntityManagerFactoryBean == LocalSessionFactoryBean (1. set dataSource, 2, set packageToScan and 3. set hibernate properties or JpaVendor Adapter)
3) EntityManagerFactory == SessionFactory 
5) @PesistenceUnit == @Inject
6) EntityManager == Session
7) entityManagerFactory.createEntityManager() == sessionFactory.getCurrentSession()
8) configure container managed JPA
8.1) decalre jpa vendor adapter (set hibernate properties, or other adapter properties)
8.2) decalre LocalContainerEntityManagerFactoryBean (1. set dataSource, 2, set packageToScan and 3. set JpaVendor Adapter)
8.3) in @Respository class, inject EntityManagerFactory with @PesistenceUnit or inject EntityManager with @PersistenceContext
8.4) em = entityManagerFactory.createEntityManager()
8.5) em.save(), em.get(), em.findAll()...
8.6) deaclre a PersistenceAnnotationBeanPostProcessor bean if <context:annotation-config> or <context:component-scan> is not used
8.7) declare a PersistenceExceptionTranslationPostProcessor so that jpa exceptions can be translated into Spring’s unified data-access exceptions.
8.8) declare transaction manager in configuration bean
8.9) any jpa repository operation needs to be annotated with @Transactional
9) configure hibernate
9.1) declare HibernateSessionFactoryBean: 1. set dataSource, 2. packageToScan or mapper file locations 3. hibernateProperties properties
9.2) in @Respository class, inject SessionFactory with @Inject
9.3) session = sessionFactory.getCurrentSession()
9.4) session.save(), session.get(), session.findAll()...
9.5) deaclre a PersistenceAnnotationBeanPostProcessor bean if <context:annotation-config> or <context:component-scan> is not used
9.6) declare a PersistenceExceptionTranslationPostProcessor so that jpa exceptions can be translated into Spring’s unified data-access exceptions.
9.7) declare transaction manager in configuration bean
9.8) any hibernate repository operation needs to be annotated with @Transactional

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Configuring an entity manager factory
- JPA-based applications use an implementation of EntityManagerFactory to get an instance of an EntityManager.
- two kinds of entity managers: 1) Application-managed vs. 2) Container-managed
- implement the same EntityManager interface. The key difference is in how the EntityManager is created and managed.
- LocalEntityManagerFactoryBean produces an application-managed EntityManagerFactory.
- LocalContainerEntityManagerFactoryBean produces a container-managed EntityManagerFactory.
- the intricate details of dealing with either form of EntityManagerFactory are hidden, leaving your data-access code to focus on its true purpose: data access.
- The only real difference between application-managed and container-managed entity manager factories, as far as Spring is concerned, is how each is configured in the Spring application context.

#CONFIGURING APPLICATION-MANAGED JPA <Test> <Test Done>
1) define a configuration file persistence.xml in the META-INF directory in the classpath. 
- Application-managed entity-manager factories derive most of their configuration information from a configuration file called persistence.xml. This file must appear in the META-INF directory in the classpath.
- The purpose of the persistence.xml file is to define one or more persistence units. A persistence unit is a grouping of one or more persistent classes that correspond to a single data source.
- persistence.xml enumerates one or more persistent classes along with any additional configuration such as data sources and XML-based mapping files.
<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
	<persistence-unit name="spitterPU">
		<class>com.habuma.spittr.domain.Spitter</class>
		<class>com.habuma.spittr.domain.Spittle</class>
		<properties>
			<property name="toplink.jdbc.driver" value="org.hsqldb.jdbcDriver" />
			<property name="toplink.jdbc.url" value= "jdbc:hsqldb:hsql://localhost/spitter/spitter" />
			<property name="toplink.jdbc.user" value="sa" />
			<property name="toplink.jdbc.password" value="" />
		</properties>
	</persistence-unit>
</persistence>

2) declares a LocalEntityManagerFactoryBean
@Bean
public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
	LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean();
	emfb.setPersistenceUnitName("spitterPU");
	return emfb;
}

#CONFIGURING CONTAINER-MANAGED JPA
1) declare a LocalContainerEntityManagerFactoryBean, set dataSource and jpaVendorAdapter:
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
	emfb.setDataSource(dataSource);
	emfb.setJpaVendorAdapter(jpaVendorAdapter);
	emfb.setPackagesToScan("com.habuma.spittr.domain");
	return emfb;
}

- The primary purpose of the persistence.xml file is to identify the entity classes in a persistence unit. But as of Spring 3.1, you can do that directly with LocalContainerEntityManagerFactoryBean by setting the packagesToScan property.
- persistence.xml is no longer required, all configuration is in LocalContainerEntityManagerFactoryBean

2) configure a HibernateJpaVendorAdapter (or other JPA vendor adapter):
@Bean
public JpaVendorAdapter jpaVendorAdapter() {
	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
	adapter.setDatabase("HSQL");
	adapter.setShowSql(true);
	adapter.setGenerateDdl(false);
	adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
	return adapter;
}

- Spring comes with a handful of JPA vendor adapters to choose from:
1) EclipseLinkJpaVendorAdapter
2) HibernateJpaVendorAdapter
3) OpenJpaVendorAdapter
4) TopLinkJpaVendorAdapter (deprecated in Spring 3.1)

#PULLING AN ENTITYMANAGERFACTORY FROM JNDI
- if you’re deploying in application servers, an EntityManagerFactory may have already been created for you and may be waiting in JNDI to be retrieved. In that case, you can use the <jee:jndilookup> element from Spring’s jee namespace to nab a reference to the EntityManagerFactory:
<jee:jndi-lookup id="emf" jndi-name="persistence/spitterPU" />

- Java configuration:
@Bean
public JndiObjectFactoryBean entityManagerFactory() {}
	JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
	jndiObjectFB.setJndiName("jdbc/SpittrDS");
	return jndiObjectFB;
}

#Writing a JPA-based repository
- template-based JPA has been set aside in favor of a pure JPA approach. This is analogous to the Hibernate contextual sessions
- LocalContainerEntityManagerFactoryBean == LocalSessionFactoryBean (1. set dataSource, 2, set packageToScan and 3. set hibernate properties or JpaVendor Adapter)
- EntityManagerFactory == SessionFactory
- EntityManager == Session
- entityManagerFactory.createEntityManager() == sessionFactory.getCurrentSession()

@Repository
@Transactional
public class JpaSpitterRepository implements SpitterRepository {
	
	@PersistenceUnit
	private EntityManagerFactory emf;
	
	public void addSpitter(Spitter spitter) {
		emf.createEntityManager().persist(spitter);
	}
	
	public Spitter getSpitterById(long id) {
		return emf.createEntityManager().find(Spitter.class, id);
	}

	public void saveSpitter(Spitter spitter) {
		emf.createEntityManager().merge(spitter);
	}
	...
}

- EntityManagerFactory property is annotated with @PersistenceUnit so that Spring can inject the EntityManagerFactory into the repository.
- use the EntityManagerFactory to create an EntityManager and then use that EntityManager to perform operations against the database.
- each method ends up calling createEntityManager(). Aside from presenting a troubling code duplication situation, it also means a new EntityManager is created every time one of the repository methods is called.
- The problem is that an EntityManager isn’t thread-safe and generally shouldn’t be injected into a shared singleton bean like your repository

@Repository
@Transactional
public class JpaSpitterRepository implements SpitterRepository {
	@PersistenceContext
	private EntityManager em;
	
	public void addSpitter(Spitter spitter) {
		em.persist(spitter);
	}
	
	public Spitter getSpitterById(long id) {
		return em.find(Spitter.class, id);
	}
	
	public void saveSpitter(Spitter spitter) {
		em.merge(spitter);
	}
	...
}

- @PersistenceContext doesn’t inject an EntityManager—at least, not exactly. Instead of giving the repository a real EntityManager, it gives a proxy to a
real EntityManager. That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. Thus, you know that you’re always working with an entity manager in a thread-safe way.
- In order for Spring to understand @PersistenceContext/@PersistenceUnit and inject an EntityManagerFactory or EntityManager, Spring’s PersistenceAnnotationBeanPostProcessor must be configured. If you’re already using <context:annotation-config> or <context:component-scan>, then you’re good to go because those configuration elements automatically register a PersistenceAnnotationBeanPostProcessor bean.
@Bean
public PersistenceAnnotationBeanPostProcessor paPostProcessor() {
	return new PersistenceAnnotationBeanPostProcessor();
}

- declare a PersistenceExceptionTranslationPostProcessor so that jpa exceptions can be translated into Spring’s unified data-access exceptions.
@Bean
public BeanPostProcessor persistenceTranslation() {
	return new PersistenceExceptionTranslationPostProcessor();
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Automatic JPA repositories with Spring Data <Test> <Test Done>

总而言之 (spring data default methods)
1）the db operation methods in repository are boilerplate，the domain types will be different, but the methods are fairly common across all kinds of repositories.
2）Spring Data JPA lets you just writing the repository interface without the implementation.
3）extends one of spring data interfaces: JpaRepository, CRUDRepository, PagingAndSortingRepository
public interface SpitterRepository extends JpaRepository<Spitter, Long> {}
4) JpaRepository is parameterized such that it knows this is a repository for persisting Spitter objects and that Spitters have an ID of type Long.
5) JpaRepository inherits 18 methods for performing common persistence operations, such as saving, deleting, and finding by its ID.
6) @EnableJpaRepositories in configuration class. @EnableJpaRepositories(basePackages="com.habuma.spittr.db")
7) @EnableJpaRepositories scans its base package for any interfaces that extend Spring Data JPA’s Repository interface. 
8) When it finds any interface extending Repository, it automatically (at application startup time) generates an implementation of that interface.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- the db operation methods in repository are boilerplate. the domain types will be different, but the methods are fairly common across all kinds of repositories.
- Spring Data JPA lets you just writing the repository interface without the implementation.
public interface SpitterRepository extends JpaRepository<Spitter, Long> {
}
- The key to writing a Spring Data JPA repository is to extend one of a handful of interfaces. Here, SpitterRepository extends Spring Data JPA’s JpaRepository 
- JpaRepository is parameterized such that it knows this is a repository for persisting Spitter objects and that Spitters have an ID of type Long. 
- It also inherits 18 methods for performing common persistence operations, such as saving a Spitter, deleting a Spitter, and finding a Spitter by its ID.
- To ask Spring Data to create an implementation of SpitterRepository, you need to add a single element to your Spring configuration. The following listing shows the XML configuration:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xsi:schemaLocation="http://www.springframework.org/schema/data/jpa
		http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd">
		
		<jpa:repositories base-package="com.habuma.spittr.db" />
		...
</beans>

- The <jpa:repositories> element holds all the magic of Spring Data JPA. Much like the <context:component-scan> element, <jpa:repositories> is given a basepackage to scan. 
- But where <context:component-scan> scans a package (and its subpackages) for classes that are annotated with @Component, <jpa:repositories> scans its base package for any interfaces that extend Spring Data JPA’s Repository interface.
- When it finds any interface extending Repository, it automatically (at application startup time) generates an implementation of that interface.

- use @EnableJpaRepositories in your Java configuration class.
@Configuration
@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
public class JpaConfiguration {
	...
}

- SpitterRepository interface extends JpaRepository. JpaRepository extends the marker Repository interface (albeit indirectly). Therefore, SpitterRepository transitively extends the Repository interface that repository-scanning is looking for.
- When Spring Data finds it, it creates an implementation of SpitterRepository, including 18 methods inherited from JpaRepository, PagingAndSortingRepository, and CrudRepository.
- repository implementation is generated at application startup time, as the Spring application context is being created. It isn’t the product of build-time code generation. Nor is it created at the time any of the interface’s methods are called.
- if you need something more than those 18 methods, Spring Data JPA provides a few ways to add custom methods to a repository. such as defining a custom query method.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Defining query methods <Test>
总而言之 (Spring data method query)
- if custom query other than the 18 default queries are needed, specify a method in the repository interface, use the method signature to indicate the implementation
- Repository methodname = verb + subject(optional) + By + predicate. e.g. findByUsername, readSpittersByFirstnameOrLastnameOrderByLastname
- verb: get, read, find, and count. get, read, and find verbs are synonymous
- subject： optional and ignored except for sstarts with the "Distinct"
- predicate: conditions that constrain the results. Each condition must reference a property and may also specify a comparison operation. 
1) Spitter findByUsername(String username) //Spitter indicate return one object <Test> <Test Done>
2) List<Spitter> readByFirstnameOrLastname(String first, String last);	//List indicates return a collection, firstname=? or lastname=? <Test> <Test Done>
3) List<Spitter> readByFirstnameOrLastnameOrderByLastnameAsc(String first, String last); //Orderby
4) List<Spitter> readByFirstnameOrLastnameOrderByLastnameAscFirstnameDesc(String first, String last); //orderby lastname and firstname
5) List<Pet> findPetsByBreedIn(List<String> breed) //breed in List
6) int countProductsByDiscontinuedTrue() //discounted=true
7) List<Order> findByShippingDateBetween(Date start, Date end) //ShippingDate between start and end

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- need a custom query method of looking up a Spitter object given a username
public interface SpitterRepository extends JpaRepository<Spitter, Long> {
	Spitter findByUsername(String username);
}
- nothing else needs to be done to implement findByUsername(). The method signature tells Spring Data JPA everything it needs to know in order to create
an implementation for the method.
- When creating the repository implementation, Spring Data will examine any methods in the repository interface, parse the method name, and attempt to understand the method’s purpose in the context of the persisted object. In essence, Spring Data defines a sort of miniature domain-specific language (DSL) where persistence details are expressed in repository method signatures.
- The method name, findByUsername, makes it clear that this method should find Spitters by matching their username property with the username passed in as a parameter to the method.
- because the signature defines the method as returning a single Spitter and not a collection, it knows that it should look for only one Spitter whose username matches.
- Repository methods = verb + subject(optional) + By + predicate. In the case of find-By-Username(), the verb is find and the predicate is Username; the subject isn’t specified and is implied to be a Spitter.
- Spring Data allows for four verbs in the method name: get, read, find, and count. The get, read, and find verbs are synonymous; all three result in repository methods that query for data and return objects.
- The count verb, on the other hand, returns a count of matching objects, rather than the objects themselves.
- There is one exception to the subject being ignored. If the subject starts with the word Distinct, then the generated query will be written to ensure a distinct result set.
- The predicate is the most interesting part of the method name. It specifies the properties that will constrain the result set.
- Within the predicate, you’ll find one or more conditions that constrain the results. Each condition must reference a property and may also specify a comparison operation.
e.g. username -> username = ?
FirstnameOrLastname -> firstname = ? or lastname = ?
FirstnameOrLastnameOrderByLastname -> firstname = ? or lastname = ? Orderby lastname
- If the comparison operator is left off, it’s implied to be an equals operation. But you may choose any other comparison operations
IsAfter, After, IsGreaterThan, GreaterThan
IsGreaterThanEqual, GreaterThanEqual
IsBefore, Before, IsLessThan, LessThan
IsLessThanEqual, LessThanEqual
IsBetween, Between
IsNull, Null
IsNotNull, NotNull
IsIn, In
IsNotIn, NotIn
IsStartingWith, StartingWith, StartsWith
IsEndingWith, EndingWith, EndsWith
IsContaining, Containing, Contains
IsLike, Like
IsNotLike, NotLike
IsTrue, True
IsFalse, False
Is, Equals
IsNot, Not
- The values that the properties will be compared against are the parameters of the method.
List<Spitter> readByFirstnameOrLastname(String first, String last);
- When dealing with String properties, the condition may also include IgnoringCase or IgnoresCase to perform the comparison with no regard for whether the characters are uppercase or lowercase. to ignore case on the firstname and lastname properties, you can write the method signature like this:
List<Spitter> readByFirstnameIgnoringCaseOrLastnameIgnoresCase(String first, String last);
- use AllIgnoringCase or AllIgnoresCase after all the conditions to ignore case for all conditions:
List<Spitter> readByFirstnameOrLastnameAllIgnoresCase(String first, String last);
- the parameter names are irrelevant, but they must be ordered to match up with the method name’s comparators.
- sort the results by adding OrderBy at the end of the method name.
List<Spitter> readByFirstnameOrLastnameOrderByLastnameAsc(String first, String last);
- To sort by multiple properties, add them to the OrderBy class.
List<Spitter> readByFirstnameOrLastnameOrderByLastnameAscFirstnameDesc(String first, String last);
- the conditional parts are separated by either And or Or. 
- a few more method signatures that adhere to the method-naming conventions:
List<Pet> findPetsByBreedIn(List<String> breed)
int countProductsByDiscontinuedTrue()
List<Order> findByShippingDateBetween(Date start, Date end)
- by carefully constructing a repository method signature using a mix of property names and keywords, you can makeSpring Data JPA generate an implementation method to query for almost anything you can imagine.
- Spring Data’s mini-DSL has its limits, and sometimes it isn’t convenient or even possible to express the desired query in a method name.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Declaring custom queries
总而言之 (Spring Data - custom query) 
1) if it’s difficult to express the query in a method name, you can use @Query annotation to provide the sql directly. Spring data will generate the implementation.
@Query("select s from Spitter s where s.email like '%gmail.com'") 	<Test> <Test Done>
List<Spitter> findAllGmailSpitters();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Suppose you want to create a repository method to find all Spitters whose email address is a Gmail address
List<Spitter> findAllGmailSpitters();
- this method name doesn’t adhere to Spring Data’s method-naming conventions. When Spring Data attempts to generate an implementation for this method, it can’t match the contents of the method name with the Spitter metamodel and throws an exception
- In situations where the desired data can’t be adequately expressed in the method name, you can use the @Query annotation to provide Spring Data with the query that should be performed.

@Query("select s from Spitter s where s.email like '%gmail.com'")
List<Spitter> findAllGmailSpitters();
- You still don’t write the implementation of the findAllGmailSpitters() method. You only give the query, hinting to Spring Data JPA about how it should implement the method.
- The @Query annotation is handy for adding custom query methods to a Spring Data JPA-enabled interface. But it’s limited to a single JPA query.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Mixing in custom functionality
总而言之 (Spring Data JPA mix Spring JPA) <Test> <Test Done>
1）In case query is too complex to expresss in method name or using @Query annotation, you can use mix the Impl class with Spring Data.
2) define an interface with the needed methods: public interface SpitterSweeper{ int eliteSweep(); }
3) Define a Impl class in ordinary spring JPA way. 
public class SpitterRepositoryImpl implements SpitterSweeper {
	@PersistenceContext
	private EntityManager em;
4) make sure SpitterSweeper interface method is declared in the SpitterRepository interface
public interface SpitterRepository extends JpaRepository<Spitter, Long>, SpitterSweeper
5) When Spring Data JPA generates the implementation for a repository interface, it also looks for a class whose name is the same as the interface’s name postfixed with Impl, i.e. SpitterRepositoryImpl. If the class exists, Spring Data JPA merges its methods with those generated by Spring Data JPA.
6) you can configure the postfix to something other tahn Impl:
@EnableJpaRepositories(basePackages="com.habuma.spittr.db", repositoryImplementationPostfix="Helper")

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- It’s likely that at some point you’ll want functionality in your repository that can’t be described with Spring Data’s method-naming conventions or even with a query given in the @Query annotation.
- When Spring Data JPA generates the implementation for a repository interface, it also looks for a class whose name is the same as the interface’s name postfixed with Impl. If the class exists, Spring Data JPA merges its methods with those generated by Spring Data JPA. For the SpitterRepository interface, the class it looks for is named SpitterRepositoryImpl.
- suppose you need a method in your SpitterRepository that updates all Spitters who have posted 10,000 or more Spittles, setting them to Elite status.
- There’s no good way to declare such a method using Spring Data JPA’s methodnaming conventions or with @Query.
public class SpitterRepositoryImpl implements SpitterSweeper {
	@PersistenceContext
	private EntityManager em;
	public int eliteSweep() {
		String update = "UPDATE Spitter spitter " +
			"SET spitter.status = 'Elite' " +
			"WHERE spitter.status = 'Newbie' " +
			"AND spitter.id IN (" +
			"SELECT s FROM Spitter s WHERE (" +
			" SELECT COUNT(spittles) FROM s.spittles spittles) > 10000" +
			")";
		return em.createQuery(update).executeUpdate();
	}
}

- SpitterRepositoryImpl doesn’t implement the SpitterRepository interface. Spring Data JPA is still responsible for implementing that interface. 
- Instead, SpitterRepositoryImpl implements SpitterSweeper, which looks like this (the only thing that ties it into your Spring Data-enabled repository is its name):
public interface SpitterSweeper{
	int eliteSweep();
}
- make sure the eliteSweep() method is declared in the SpitterRepository interface
public interface SpitterRepository extends JpaRepository<Spitter, Long>, SpitterSweeper {
	....
}
- The Impl postfix is only the default, though. If you’d prefer to use some other postfix, you need to specify it when configuring @EnableJpaRepositories by setting the repositoryImplementationPostfix attribute:
@EnableJpaRepositories(basePackages="com.habuma.spittr.db", repositoryImplementationPostfix="Helper")
in xml:
<jpa:repositories base-package="com.habuma.spittr.db" repository-impl-postfix="Helper" />
- With the postfix set to Helper, Spring Data JPA will look for a class named SpitterRepositoryHelper to match up with the SpitterRepository interface.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

13. MyBatis (自己总结的)
# simple mapping
1) Configuration class
@Configuration
@MapperScan(basePackages = "spittr.data.mybatis")	//scan for mapper
public class MyBatisDataConfig {
	//declare dataSource
	
	@Bean
    public DataSourceTransactionManager transactionManager() {			//same transaction manager as spring jdbc
        return new DataSourceTransactionManager(dataSource());
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource());
        return sqlSessionFactoryBean;
    }
}

- additional configuration can be applied to SqlSessionFactoryBean
@Bean
public SqlSessionFactoryBean sqlSessionFactory() throws Exception {
    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource());
    sqlSessionFactoryBean.setTypeAliasesPackage("spittr.domain"); 
    sqlSessionFactoryBean.setConfigLocation(new PathMatchingResourcePatternResolver().getResource("classpath:mybatis-config.xml"));
    sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
    return sqlSessionFactoryBean;
}

- package to scan for domain objects: sqlSessionFactoryBean.setTypeAliasesPackage("spittr.domain"); 

- Set locations of MyBatis mapper files that are going to be merged into the SqlSessionFactory configuration at runtime:
sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"))
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
<mapper namespace="org.seckill.dao.SeckillDao">
	<update id="reduceNumber">
		update 
			seckill
		set
			number=number-1
		where seckill_id=#{seckillId}
		and start_time <![CDATA[ <= ]]> #{killTime}
		and end_time >= #{killTime}
		and number > 0;
	</update>
	
	<select id="queryById" resultType="Seckill" parameterType="long">
		select seckill_id,name,number,start_time, end_time, create_time
		from seckill
		where seckill_id = #{seckillId}	
	</select>
	
	<select id="queryAll" resultType="Seckill">
		select seckill_id,name,number,start_time, end_time, create_time
		from seckill
		order by create_time desc
		limit #{offset}, #{limit}		
	</select>
</mapper>

- Set the location of the MyBatisSqlSessionFactory config file: 
sqlSessionFactoryBean.setConfigLocation(new PathMatchingResourcePatternResolver().getResource("classpath:mybatis-config.xml"));
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<settings>
		<setting name="useGeneratedKeys" value="true"/>
		<setting name="useColumnLabel" value="true"/>
		<setting name="mapUnderscoreToCamelCase" value="true"/>	
	</settings>
</configuration>


2) Define mapper interface
public interface MyBatisSpitterMapper {

    @Select("SELECT * FROM Spitter WHERE username=#{user}")
    Spitter findByUsername(@Param("user") String username);
    
    @Select("select * from Spitter s where s.email like '%gmail.com'")
    List<Spitter> findAllGmailSpitters();
}

- @Select, @Update, @Delete annotation followed by sql
- @Param match the method parameter to sql parameter

3) autowire mapper in Service class and execute the interface method:
@Autowire
MyBatisSpitterMapper myBatisSpitterMapper;
List<Spitter> spitterList = myBatisSpitterMapper.findAllGmailSpitters();

#complex mapping
- If sql is complex or result set mapping to object is not straightforward, it is better to use mapper.xml file.
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
<mapper namespace="org.seckill.dao.SuccessKilledDao">
	<insert id="insertSuccessKilled">
		insert ignore into success_killed(seckill_id, user_phone, state)
		values (#{seckillId},#{userPhone},0)
	</insert>
	<select id="queryByIdWithSeckill" resultType="SuccessKilled">
		select 
			sk.seckill_id,
			sk.user_phone,
			sk.create_time,
			sk.state,
			s.seckill_id "seckill.seckill_id",
	 		s.name "seckill.name",
	 		s.number "seckill.number",
	 		s.start_time "seckill.start_time",
	 		s.end_time "seckill.end_time",
	 		s.create_time "seckill.create_time"	
		from success_killed sk
		inner join seckill s on sk.seckill_id = s.seckill_id
		where sk.seckill_id = #{seckillId} 
		and sk.user_phone = #{userPhone}	
	</select>
</mapper>

- declare a SqlSessionFactoryBean with more configuration
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="configLocation" value="classpath:mybatis-config.xml"/>
		<property name="typeAliasesPackage" value="org.seckill.entity"/>
		<property name="mapperLocations" value="classpath:mapper/*.xml"/>	
</bean>

- typeAliasesPackage: SuccessKilled + org.seckill.entity = org.seckill.entity.SuccessKilled

- declare a MapperScannerConfigurer bean scan basepackage for mapper class. 
- can be replaced with MapperScan(basePackages="org.seckill.dao") if using java config
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
		<property name="basePackage" value="org.seckill.dao"/>
</bean>

- <property name="configLocation" value="classpath:mybatis-config.xml"/>
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<settings>
		<setting name="useGeneratedKeys" value="true"/>				//??
		<setting name="useColumnLabel" value="true"/>				//use column label to map to object field
		<setting name="mapUnderscoreToCamelCase" value="true"/>		//first_name map to firstName
	</settings>
</configuration>

#use mybatis-generator
- compile time generator, generate code during build.
- generate mapper xml + pojo domain object + mapper interface for each database table.
- mapper interface contains 6 generic methods
- mapper xml contains resultMap mapping to domain object and sql mapping to mapper interface methods.
- If additional sql are needed, you can add method to mapper interface and add sql statement to the mapper xml.


13. chapter 12 working with NoSQL database
总而言之 (Spring Data Mongo configuration and MongoTemplate)
1) documents is in denormalized structures, it collects the information into one place rather than spread the data across multiple tables, nodes, or entities.
2) documents generally documents are standalone entities. Databases finely tuned to work with documents are known as document databases.
3) configure a MongoClient bean: 
@EnableMongoRepositories(basePackages="orders.db"); //Enable MongoDB repositories generation
@Bean public MongoFactoryBean mongo() {...}; 			//MongoFactoryBean bean, like a dataSource
@Bean public MongoOperations mongoTemplate(Mongo mongo) {...}	//MongoTemplate
4) Annotating model types: @Document public class Order { @Id private String id; @Field("client") private String customer; ... }
5) Inject mongoTemplate to DAO: @Autowired MongoOperations mongoOperations;
6) execute db operations using mongoOperations:
long orderCount = mongoOperations.getCollection("order").count();
mongoOperations.save(order);
String id = "599a6170b4d673ae450389d3";
Order order = mongoOperations.findById(id, Order.class);
List<Order> chucksOrders = mongoOperations.find(Query.query(Criteria.where("client").is("Chuck Wagon")), Order.class);
List<Order> chucksWebOrders = mongoOperations.find(Query.query(Criteria.where("customer").is("Chuck Wagon").and("type").is("WEB")), Order.class);
mongoOperations.remove(order);

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Spring Data also supports several NoSQL databases, including MongoDB, Neo4j, and Redis.
- includes support for automatic repositories, but also template-based data access and mapping annotations.

#Persisting documents with MongoDB
- Some data are best represented as documents. 
- rather than spread the data across multiple tables, nodes, or entities, it may make more sense to collect the information into denormalized structures (known as documents).
- Although two or more of these documents may be related to each other, generally documents are standalone entities. e.g. college student transcripts
- Databases finely tuned to work with documents in this way are known as document databases.

#What document databases aren’t good for
- Document databases aren’t general-purpose databases and they have a very narrow set of problems that they address well.
- Document databases aren’t well-tuned for storing data where there’s any significant degree of relationships. A social network, for example, represents how different users of an application relate to each other and isn’t best kept in a document database. 
- Even though it’s not impossible to store relation-rich data in a document database, you’ll find more challenge than benefit in doing so.

#Spring Data MongoDB brings MongoDB to Spring applications in three ways:
1) Annotations for object-to-document mapping
2) Template-based database access with MongoTemplate
3) Automatic runtime repository generation

#configure Spring Data MongoDB.
- First, you’ll need to configure a MongoClient bean to be able to access the MongoDB database. 
- You’ll also need a MongoTemplate bean to be able to perform template-based data access against the database.
- Optionally, but desirably, you’ll want to enable Spring Data MongoDB’s automatic repository generation.
- simple Spring Data MongoDB configuration class that addresses these needs:

@Configuration
@EnableMongoRepositories(basePackages="orders.db")				//Enable MongoDB repositories generation
public class MongoConfig {
	@Bean
	public MongoFactoryBean mongo() {							//MongoFactoryBean bean, like a dataSource, generate 
		MongoFactoryBean mongo = new MongoFactoryBean();
		mongo.setHost("localhost");
		return mongo;
	}

	@Bean
	public MongoOperations mongoTemplate(Mongo mongo) {			//MongoTemplate bean. ref to Mongo instance and db name		
		return new MongoTemplate(mongo, "OrdersDB");			
	}
}

- you enabled Spring Data’s automatic JPA repository generation with the @EnableJpaRepositories annotation. 
- Similarly, the @EnableMongoRepositories annotation does the same thing for MongoDB.
- The first @Bean method uses MongoFactoryBean to declare a Mongo instance. This bean will bridge Spring Data MongoDB to the database, like what a DataSource does with a relational database.
- The other @Bean method declares a MongoTemplate bean. It’s constructed giving it a reference to the Mongo instance and the name of the database.
- Even if you never use MongoTemplate directly, you’ll need this bean because the automatically generated repositories will use it under the covers.
- Rather than declare those beans directly, the configuration class could extend AbstractMongoConfiguration and override its getDatabaseName() and mongo()
methods.
@Configuration
@EnableMongoRepositories("orders.db")
public class MongoConfig extends AbstractMongoConfiguration {
	@Override
	protected String getDatabaseName() {		//Specify database name
		return "OrdersDB";
	}
	
	@Override
	public Mongo mongo() throws Exception {		//Create a Mongo client
		return new MongoClient();
	}
}
- This new configuration class is equivalent to the one in above.
- The most noticeable difference is that this configuration doesn’t directly declare a MongoTemplate bean, although one is implicitly created.
- If your MongoDB server is running on a different server, you can specify that when you create MongoClient:
public Mongo mongo() throws Exception {
	return new MongoClient("mongodbserver");
}
- if your MongoDB server is listening on a port other than the default (27017)
public Mongo mongo() throws Exception {
	return new MongoClient("mongodbserver", 37017);
}
- if server have authentication enabled. In that case, you’ll need to provide your application’s credentials in order to access the database
@Autowired
private Environment env;

@Override
public Mongo mongo() throws Exception {
	MongoCredential credential = MongoCredential.createMongoCRCredential(		//Create MongoDB credential
		env.getProperty("mongo.username"), "OrdersDB",
		env.getProperty("mongo.password").toCharArray());						//Create MongoClient
		return new MongoClient(new ServerAddress("localhost", 37017), Arrays.asList(credential));
}

Spring Data MongoDB can also be configured in XML:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:mongo="http://www.springframework.org/schema/data/mongo"
	xsi:schemaLocation="
		http://www.springframework.org/schema/data/mongo
		http://www.springframework.org/schema/data/mongo/spring-mongo.xsd
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd">

	<mongo:repositories base-package="orders.db" />
	<mongo:mongo />
	<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
			<constructor-arg ref="mongo" />
			<constructor-arg value="OrdersDB" />
	</bean>
</beans>

#Annotating model types for MongoDB persistence
- you’ll need to map your Java domain types for document persistence using Spring Data MongoDB’s object-to-document mapping annotations.
- When working with JPA, you had to map your Java entity types to relational tables and columns. The JPA specification provides for several annotations to support object-torelational mapping, and some JPA implementations, such as Hibernate, add their own mapping annotations as well.
- MongoDB, however, doesn’t come with its own object-to-document mapping annotations. Spring Data MongoDB seized the opportunity to fill that gap with a handful of annotations that you can use to map your Java types to MongoDB documents.
@Document: Identifies a domain object to be mapped to a MongoDB document
@Id: Indicates that a field is the ID field
@DbRef: Indicates that a field is intended to reference another document, possibly in another database
@Field: Defines custom metadata for a document field
@Version: Identifies a property to be used as a version field

- The @Document and @Id annotations are analogous to JPA’s @Entity and @Id annotations.
- You’ll use these two annotations often and on every Java type that will be stored as a document in the MongoDB database.
@Document
public class Order {
	@Id
	private String id;
	
	@Field("client")
	private String customer;
	
	private String type;
	
	private Collection<Item> items = new LinkedHashSet<Item>();
	
	//...getter/setter
}

- Order is annotated with @Document, enabling it to be persisted using MongoTemplate, an automatically generated repository, or both.
- Its id property is annotated with @Id to designate it as the ID of the document.
- the customer property is annotated with @Field so that when the document is persisted, the customer property will be mapped to a field named client.
- no other properties are annotated. Unless they’re marked as transient, all fields of the Java object will be persisted as fields of the document.
- unless otherwise indicated with @Field, the document fields will have the same names as their Java property counterparts.

- items property is a collection of line items in this order. In a traditional relational database setting, those items would probably be kept in a separate database table, referenced with a foreign key, and the items field might be annotated for JPA with @OneToMany.
- In the case of the relationship between a purchase order and its line items, the line items are merely a nested part of the same order document. Therefore, there’s no need for any annotations to designate the relationship.
- the Item class itself isn’t annotated at all:
package orders;
public class Item {
	private Long id;
	private Order order;
	private String product;
	private double price;
	private int quantity;
	//...getter/setter
}
- It’s not necessary to annotate Item with @Document, nor is it necessary to annotate one of its fields with @Id. That’s because you’ll never persist an Item as an independent document. It will always be a member of the Order document’s Item list and a nested element in that document. 

#Accessing MongoDB with MongoTemplate
- inject MongoTemplate wherever it will be used:
@Autowired
MongoOperations mongo;
- injecting MongoTemplate into a property whose type is MongoOperations. MongoOperations is an interface that MongoTemplate implements, and it’s good form to not work with the concrete implementation directly, especially when it’s injected.

- MongoOperations exposes several useful methods for working with a MongoDB document database.
long orderCount = mongo.getCollection("order").count(); <Test> <Test Done>

Order order = new Order();
... // set properties and add line items
mongo.save(order, "order"); //The first parameter to save() is the newly created Order; the second is the name of the document store to save it to. <Test> <Test Done>

String orderId = ...;
Order order = mongo.findById(orderId, Order.class); <Test> <Test Done>

- More advanced queries require that you construct a Query object and pass it to the find() method. find all orders whose client field is equal to “Chuck
Wagon”:
List<Order> chucksOrders = mongo.find(Query.query(Criteria.where("client").is("Chuck Wagon")), Order.class); <Test> <Test Done>

- get all of Chuck’s orders that were placed over the web:
List<Order> chucksWebOrders = mongo.find(Query.query(Criteria.where("customer").is("Chuck Wagon").and("type").is("WEB")), Order.class); <Test> <Test Done>

mongo.remove(order);	<Test> <Test Done>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Writing a MongoDB repository
总而言之，（Spring Data MongoDB repository)
1）enabled Spring Data MongoDB repositories with @EnableMongoRepositories
2) create an interface and extend MongoRepository: public interface OrderRepository extends MongoRepository<Order, String> {}
3) The MongoRepository interface has two parameters. The first is the type of @Document-annotated object that this repository deals with. The second is the type of the @Id-annotated property.
4) OrderRepository extends MongoRepository, it transitively extends the Repository marker interface, any interface that extends Repository will have an implementation automatically generated at runtime.
5) OrderRepository inherits several useful methods for CRUD operations on Order documents: count(), delete(), exists(), findAll(), FindOne(ID), save(S)...
6) Inject OrderRepository into Service class and operate on db using OrderRepository
- Order savedOrder = orderRepository.save(order);
- Order foundOrder = orderRepository.findOne(savedOrder.getId());
- orderRepository.delete(savedOrder.getId());

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Spring Data MongoDB can automatically generate a repository implementation for you at runtime.
- enabled Spring Data MongoDB repositories with @EnableMongoRepositories, 
- create an interface that you can generate the repository implementation. Instead of extending JpaRepository, however, you’ll need to extend MongoRepository. The OrderRepository interface in the following listing extends MongoRepository to provide basic CRUD operations for Order documents.

public interface OrderRepository extends MongoRepository<Order, String> {
}
- The MongoRepository interface has two parameters. The first is the type of @Document-annotated object that this repository deals with. The second is the type of the @Id-annotated property.
- OrderRepository extends MongoRepository, it transitively extends the Repository marker interface
- any interface that extends Repository will have an implementation automatically generated at runtime.
- In this case, however, instead of a JPA repository that interacts with a relational database, OrderRepository will be implemented to read and write
data to a MongoDB document database.
- OrderRepository inherits several useful methods for CRUD operations on Order documents.
long count(); Returns a count of the documents for the repository type
void delete(Iterable<? extends T); Deletes all documents associated with the given objects
void delete(T); Deletes the document associated with the given object
void delete(ID); Deletes a document by its ID
void deleteAll(); Deletes all documents for the given repository type 
boolean exists(Object); Returns true if a document associated with the given object exists
boolean exists(ID); Returns true if a document exists for the given ID
List<T> findAll(); Returns all documents for the repository type
List<T> findAll(Iterable<ID>); Returns all documents for the given document IDs
List<T> findAll(Pageable); Returns a paged and sorted list of documents for the repository type
List<T> findAll(Sort); Returns a sorted list of all documents for the given document ID
T findOne(ID); Returns a single document for the given ID
save(Iterable<S>); Saves all documents in the given Iterable
save(S); Saves a single document for the given object
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#ADDING CUSTOM QUERY METHODS
总而言之 (Spring Data Mongo auto custom query + manual custom query)
1）The provided CRUD operations are generally useful, but you may need the repository to provide methods beyond what comes out of the box. e.g. findByProperty not primary key id, conditional query...
2) like Spring Data JPA, Spring Data MongoDB supports a method-naming convention that helps Spring Data to automatically generate implementations for the methods.
3) create methods in OrderRepository interface following the method-naming convention, implementation will be generated automatically:
public interface OrderRepository extends MongoRepository<Order, String> {
	List<Order> findByCustomer(String c);
	List<Order> findByCustomerLike(String c);
	List<Order> findByCustomerAndType(String c, String t);
	List<Order> findByCustomerLikeAndType(String c, String t);
}
4) Inject OrderRepository into Service class and operate on db using OrderRepository
- List<Order> chucksOrders = orderRepository.findByCustomer("Chuck Wagon");
- List<Order> chuckLikeOrders = orderRepository.findByCustomerLike("Chuck");
- List<Order> chucksWebOrders = orderRepository.findByCustomerAndType("Chuck Wagon", "WEB");
- List<Order> chucksPhoneOrders = orderRepository.findByCustomerAndType("Chuck Wagon", "PHONE");
5) In case the method-naming convention becomes too complicated, you can explicitly write a query, for MongoDB, @Query takes a JSON query string instead of a JPA query.
@Query("{'customer': 'Chuck Wagon', 'type' : ?0}")
List<Order> findChucksOrders(String t);
6) the type property is mapped to ?0. This indicates that the type property should be equal to the zeroth parameter to the query method. If there were more parameters, they could be referred to with ?1, ?2, and so forth.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- The CRUD operations are generally useful, but you may need the repository to provide methods beyond what comes out of the box.
- Spring Data JPA supports a method-naming convention that helps Spring Data to automatically generate implementations for the methods that follow that convention. As it turns out, the very same convention works with Spring Data MongoDB.
public interface OrderRepository extends MongoRepository<Order, String> {				<Test> <Test Done>
	List<Order> findByCustomer(String c);
	List<Order> findByCustomerLike(String c);
	List<Order> findByCustomerAndType(String c, String t);
	List<Order> findByCustomerLikeAndType(String c, String t);
}

- The find query verb is flexible. If you’d prefer, you can use get as the query verb
List<Order> getByCustomer(String c);
List<Order> readByCustomer(String c);
int countByCustomer(String c);

#SPECIFYING QUERIES <Test> <Test Done>
- @Query annotation can be used to specify a custom query for a repository method. @Query works equally well with MongoDB as it does with JPA. The only material difference is that for MongoDB, @Query takes a JSON query string instead of a JPA query.
- finds all orders of a given type for the customer whose name is “Chuck Wagon”.
@Query("{'customer': 'Chuck Wagon', 'type' : ?0}")
List<Order> findChucksOrders(String t);

- the type property is mapped to ?0. This indicates that the type property should be equal to the zeroth parameter to the query method. If there were more parameters, they could be referred to with ?1, ?2, and so forth.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#MIXING IN CUSTOM REPOSITORY BEHAVIOR <Test> <Test Done>
总而言之 (Spring Data Mongo - mixing custom impementation into auto generated repository)
1) When db operation is so complex that method-naming convention and @Query annotation cannot meet the needs, you can use mixing repository
2) create an intermediary interface that declares the custom methods:  
public interface OrderOperations {
	List<Order> findOrdersByType(String t);
}
3) create an implementation class for the custom methods: fall back to MongoOperations to use Query and Criteria.
public class OrderRepositoryImpl implements OrderOperations {
	@Autowired
	private MongoOperations mongo;		//Inject MongoOperations 
	
	public List<Order> findOrdersByType(String t) {
		String type = t.equals("NET") ? "WEB" : t;
		Criteria where = Criteria.where("type").is(t);		//create query
		Query query = Query.query(where);					
		return mongo.find(query, Order.class);				//perform query
	}
}
4) make automatic repository interface to extend the intermediary interface. 
public interface OrderRepository extends MongoRepository<Order, String>, OrderOperations { ... }
5) When Spring Data MongoDB generates the repository implementation, it scans the basePackage "spittr.data.mongo" and found OrderRepository which imeplemneted the MongoRepository interface, it will generate the implementation based on the method-naming convention or @Query, then it will look for OrderRepositary + Impl and mix it into the automatically generated implementation.
6) you can configure Spring Data MongoDB to look for a class with a different suffix in its name:
@EnableMongoRepositories(basePackages="orders.db", repositoryImplementationPostfix="Stuff")

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- to mix fully custom methods into an otherwise automatically generated repository. For JPA, that involved 1)creating an intermediary interface that declares the custom method(s), 2) an implementation class for those custom methods, and 3) changing the automatic repository interface to extend the intermediary
interface. The steps are the same for a Spring Data MongoDB repository.
- Suppose that you need a method that finds all Order objects where the document’s type property matches a given value.
- First, define the intermediary interface:
public interface OrderOperations {
	List<Order> findOrdersByType(String t);
}
- implementation might look like:
public class OrderRepositoryImpl implements OrderOperations {
	@Autowired
	private MongoOperations mongo;		//Inject MongoOperations 
	
	public List<Order> findOrdersByType(String t) {
		String type = t.equals("NET") ? "WEB" : t;
		Criteria where = Criteria.where("type").is(t);		//create query
		Query query = Query.query(where);					
		return mongo.find(query, Order.class);				//perform query
	}
}

- change OrderRepository to extend the intermediary OrderOperations interface:
public interface OrderRepository extends MongoRepository<Order, String>, OrderOperations {
	...
}
- The thing that ties all of this together is the fact that the implementation class is named OrderRepositoryImpl.
- This is the same name as the OrderRepository interface, with an “Impl” suffix.
- When Spring Data MongoDB generates the repository implementation, it will look for this class and mix it into the automatically generated implementation.
- you can configure Spring Data MongoDB to look for a class with a different suffix in its name.
@Configuration
@EnableMongoRepositories(basePackages="orders.db", repositoryImplementationPostfix="Stuff")
public class MongoConfig extends AbstractMongoConfiguration {
	...
}
in xml: <mongo:repositories base-package="orders.db" repository-impl-postfix="Stuff" />
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Working with graph data in Neo4j
总而言之
1）graph databases store data in several fine-grained nodes that are connected with each other through relationships.
2) A node in a graph database typically represents a concept in the database, having properties that describe the state of the node. Relationships connect
two nodes and may carry properties of their own.
3) because data is structured as a graph, it’s possible to traverse relationships to discover things about your data that would be difficult or even impossible with other kinds of databases.
4) Spring Data Neo4j provides annotations for mapping Java types to nodes and relationships, template-oriented Neo4j access, and automatic generation of repository implementations.
5) Configuring Spring Data Neo4j
5.1) declare a GraphDatabaseService bean and enable automatic Neo4j repository generation
@Configuration
@EnableNeo4jRepositories(basePackages="orders.db")		//Enable automatic repositories
public class Neo4jConfig extends Neo4jConfiguration {
	public Neo4jConfig() {								//Set model base package
		setBasePackage("orders");
	}
	
	@Bean(destroyMethod="shutdown")
	public GraphDatabaseService graphDatabaseService() {
		return new GraphDatabaseFactory().newEmbeddedDatabase("/tmp/graphdb");		//Configure embedded database
	}
}
5.2) Annotating graph entities
*@NodeEntity: Declares a Java type as a node entity
*@RelationshipEntity: Declares a Java type as a relationship entity
*@StartNode: Declares a property as the start node of a relationship entity
*@EndNode: Declares a property as the end node of a relationship entity
@Fetch: Declares a property on an entity to be eagerly loaded
*@GraphId: Declares a property as the ID field of an entity (the field must be a Long)
@GraphProperty: Explicitly declares a property
@GraphTraversal: Declares a property to automatically provide an iterable that’s built by following a graph traversal
@Indexed: Declares a property to be indexed
@Labels: Declares the labels for an @NodeEntity
@Query: Declares a property to automatically provide an iterable that’s built by executing a given Cypher query
@QueryResult: Declares a Java class or interface as being able to hold the results of a query
*@RelatedTo: Declares a simple relationship between the current @NodeEntity and another @NodeEntity via a property
@RelatedToVia: Declares a field on an @NodeEntity as referencing an
@RelationshipEntity: that the node belongs to 
@RelationshipType: Declares a field as the type of a relationship entity
@ResultColumn: Declares a property on an @QueryResult-annotated type to capture a specific field from a query result
5.3) autowire Neo4jTemplate and operate on Neo4j db:
@Autowired 
private Neo4jOperations neo4j;
neo4j.count(Order.class) <Test> <Test Done>
neo4j.save(order) <Test> <Test Failed> not in tx

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Whereas document databases store data in coarse-grained documents, graph databases store data in several fine-grained nodes that are connected with each other through relationships.
- A node in a graph database typically represents a concept in the database, having properties that describe the state of the node. Relationships connect
two nodes and may carry properties of their own.
- At their simplest, graph databases are more general purpose than document databases, potentially being a schemaless alternative to relational databases.
- because data is structured as a graph, it’s possible to traverse relationships to discover things about your data that would be difficult or even impossible with other kinds of databases.
- Spring Data Neo4j offers many of the same capabilities as Spring Data JPA and Spring Data MongoDB, albeit targeting the Neo4j graph database. It provides annotations for mapping Java types to nodes and relationships, template-oriented Neo4j access, and automatic generation of repository implementations.

#Configuring Spring Data Neo4j
- declare a GraphDatabaseService bean and enable automatic Neo4j repository generation.
@Configuration
@EnableNeo4jRepositories(basePackages="orders.db")		//Enable automatic repositories
public class Neo4jConfig extends Neo4jConfiguration {
	public Neo4jConfig() {								//Set model base package
		setBasePackage("orders");
	}
	
	@Bean(destroyMethod="shutdown")
	public GraphDatabaseService graphDatabaseService() {
		return new GraphDatabaseFactory().newEmbeddedDatabase("/tmp/graphdb");		//Configure embedded database
	}
}

- @EnableNeo4jRepositories annotation enables Spring Data Neo4j to automatically generate Neo4j repository implementations. 
- Its basePackages is set so that it scans the orders.db package for interfaces that extend (directly or indirectly) the marker Repository interface.
- Neo4jConfig extends Neo4jConfiguration, which provides convenient methods for configuring Spring Data Neo4j.
- setBasePackage() is called from Neo4jConfig’s constructor to tell Spring Data Neo4j that it can find model classes in the orders package.
- the graphDatabaseService() method uses GraphDatabaseFactory to create an embedded Neo4j database.
- With Neo4j, an embedded database shouldn’t be confused with an in-memory database. “Embedded” means that the database engine is running within the same JVM as a part of your application rather than as a separate server. The data is still persisted to the filesystem (at /tmp/graphdb in this case).

- you might want to configure a GraphDatabaseService that references a remote Neo4j server.
- If you have the spring-data-neo4j-rest library in your application’s classpath, you can configure SpringRestGraphDatabase, which accesses a remote Neo4j database over a RESTful API
@Bean(destroyMethod="shutdown")
public GraphDatabaseService graphDatabaseService() {
	return new SpringRestGraphDatabase("http://graphdbserver:7474/db/data/");
}

- if the remote database require authentication,, you provide your application’s credentials when creating the SpringRestGraphDatabase:
@Bean(destroyMethod="shutdown")
public GraphDatabaseService graphDatabaseService(Environment env) {
	return new SpringRestGraphDatabase("http://graphdbserver:7474/db/data/",
		env.getProperty("db.username"), env.getProperty("db.password"));
}

- XML configuration:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:neo4j="http://www.springframework.org/schema/data/neo4j"
	xsi:schemaLocation=" http://www.springframework.org/schema/beans
						http://www.springframework.org/schema/beans/spring-beans.xsd
						http://www.springframework.org/schema/data/neo4j
						http://www.springframework.org/schema/data/neo4j/spring-neo4j.xsd">

	<neo4j:config storeDirectory="/tmp/graphdb" base-package="orders" /> 	//Configure Neo4j database details
	<neo4j:repositories base-package="orders.db" />		//Enable repository generation
</beans>

- The <neo4j:config> element configures the details of how to access the database. In this case, it configures Spring Data Neo4j to work with an embedded database. 
- the storeDirectory attribute specifies the path in the filesystem where the data will be persisted. 
- the base-package attribute sets the package where the model classes are defined.
- To configure Spring Neo4j to access a remote Neo4j server, all you need to do is 1)declare a SpringRestGraphDatabase bean and 2) set <neo4j:config>’s graphDatabaseService attribute:

<neo4j:config base-package="orders" graphDatabaseService="graphDatabaseService" />
<bean id="graphDatabaseService" class= "org.springframework.data.neo4j.rest.SpringRestGraphDatabase">
	<constructor-arg value="http://graphdbserver:7474/db/data/" />
	<constructor-arg value="db.username" />
	<constructor-arg value="db.password" />
</bean>

#Annotating graph entities
- Neo4j defines two kinds of entities: nodes and relationships. Node entities typically represent the things in your application, whereas relationship entities define how those things are related.
- Spring Data Neo4j provides several annotations that you can apply to domain types and their fields for persistence in Neo4j.
@NodeEntity: Declares a Java type as a node entity
@RelationshipEntity: Declares a Java type as a relationship entity
@StartNode: Declares a property as the start node of a relationship entity
@EndNode: Declares a property as the end node of a relationship entity
@Fetch: Declares a property on an entity to be eagerly loaded
@GraphId: Declares a property as the ID field of an entity (the field must be a Long)
@GraphProperty: Explicitly declares a property
@GraphTraversal: Declares a property to automatically provide an iterable that’s built by following a graph traversal
@Indexed: Declares a property to be indexed
@Labels: Declares the labels for an @NodeEntity
@Query: Declares a property to automatically provide an iterable that’s built by executing a given Cypher query
@QueryResult: Declares a Java class or interface as being able to hold the results of a query
@RelatedTo: Declares a simple relationship between the current @NodeEntity and another @NodeEntity via a property
@RelatedToVia: Declares a field on an @NodeEntity as referencing an
@RelationshipEntity: that the node belongs to 
@RelationshipType: Declares a field as the type of a relationship entity
@ResultColumn: Declares a property on an @QueryResult-annotated type to capture a specific field from a query result

@NodeEntity							//Orders are nodes
public class Order {
	@GraphId
	private Long id;				//The graph ID
	
	private String customer;
	private String type;
	
	@RelatedTo(type="HAS_ITEMS")	//Relationship to items
	private Set<Item> items = new LinkedHashSet<Item>();
	...
}

- the id property is annotated with @GraphId. All entities in Neo4j must have a graph ID. This is roughly analogous to the @Id-annotated properties of a JPA @Entity or a MongoDB @Document. it is required that the @GraphId-annotated property be a Long.
- The customer and type properties remain annotation-free. Unless they are transient, they’ll be properties on the node in the database.
- The items property is annotated with @RelatedTo, indicating that an Order is related to a Set of Item.
- The type attribute essentially labels the relationship. It can be given any value, but it’s commonly given human-readable text that briefly describes
the nature of the relationship.

@NodeEntity					//Items are nodes
public class Item {
	@GraphId               //Item's graphID
	private Long id;
	private String product;
	private double price;
	private int quantity;
	...
}

- In the current data model, we’ve combined the concepts of a line item and a product into the Item class. When you think about it, however, an order is
related to one or more products. The relationship between an order and a product constitutes a line item of the order.
- In this new model, the quantity of products in the order is a property of the line item, now that a line item must carry a quantity value, you’re going to need to define a class that represents a line item, such as LineItem in the next listing.

@RelationshipEntity(type="HAS_LINE_ITEM_FOR")		//LineItem is a relationship
public class LineItem {
	@GraphId                                        //LineItem's graphId
	private Long id;
	
	@StartNode										//the start node	
	private Order order;
	
	@EndNode										//the end node
	private Product product;
	private int quantity;
	...
}
- LineItem is annotated with @RelationshipEntity
- all entities, both node entities and relationship entities, must have a graph ID and it must be of type Long.

#Working with Neo4jTemplate
- autowire Neo4jTemplate:
@Autowired
private Neo4jOperations neo4j;
- Neo4jTemplate defines several dozen methods, including methods for saving nodes, deleting nodes, and creating relationships between nodes.
- save an object as a node:
Order order = ...;
Order savedOrder = neo4j.save(order);
- fetching by id:
Order order = neo4j.findOne(42, Order.class);
- retrieve all objects of a given type, The EndResult returned here is an Iterable, enabling it to be used in for-each looping and anywhere else an Iterable may be used:
EndResult<Order> allOrders = neo4j.findAll(Order.class);
- long orderCount = count(Order.class);
- neo4j.delete(order);
- One of the most interesting methods provided by Neo4jTemplate is the createRelationshipBetween() method:
Order order = ...;
Product prod = ...;
LineItem lineItem = neo4j.createRelationshipBetween(order, prod, LineItem.class, "HAS_LINE_ITEM_FOR", false);
lineItem.setQuantity(5);
neo4j.save(lineItem);
- The final parameter is a boolean that indicates whether or not duplicate relationships are allowed between the two node entities.
- The Neo4jTemplate offers a straightforward way to work with nodes and relationships in a Neo4j graph database. But it requires that you write your own repository implementations that delegate to Neo4jTemplate.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Creating automatic Neo4j repositories <Test>
总而言之
1) added @EnableNeo4jRepositories to your configuration
2) write the Repository interfaces extends GraphRepository, Spring Data Neo4j will daefault generate implementation automatically:
public interface OrderRepository extends GraphRepository<Order> {}
3) GraphRepository is parameterized with Order, the type of entity that the repository works with.
4) @Autowired private OrderRepository orderRepository;
5) use OrderRepository to operate on neo4j db:
	orderRepository.count();
	Order savedOrder = orderRepository.save(order);
	Order foundOrder = orderRepository.findOne(savedOrder.getId());
6) following method naming convention, add additional methods to OrderRepository, Spring Data Neo4j will generate implementation automatically
	orderRepository.deleteAll(	);
	List<Order> chucksOrders = orderRepository.findByCustomer("Chuck Wagon"	);
	List<Order> chuckLikeOrders = orderRepository.findByCustomerLike("Chuck.*"	);
	List<Order> chucksWebOrders = orderRepository.findByCustomerAndType("Chuck Wagon", "WEB"	);
	List<Order> chucksPhoneOrders = orderRepository.findByCustomerAndType("Chuck Wagon", "PHONE");
	orderRepository.delete(savedOrder.getId());
7) When neither the naming convention nor the @Query methods meet your needs, you always have the option of mixing in custom repository logic.
7.1) start by defining an intermediary interface: public interface OrderOperations { List<Order> findSiAOrders(); }
7.2) make OrderRepository to extend OrderOperations in addition to GraphRepository: 
public interface OrderRepository extends GraphRepository<Order>, OrderOperations {...}
7.3) write the implementation
public class OrderRepositoryImpl implements OrderOperations {		
	private final Neo4jOperations neo4j;
	...
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Spring Data Neo4j supports automatic repository generation.
- added @EnableNeo4jRepositories to your configuration
- write the Repository interfaces extends GraphRepository:
public interface OrderRepository extends GraphRepository<Order> {}
- GraphRepository is parameterized with Order, the type of entity that the repository works with. Because Neo4j requires that graph IDs be of type Long,
there’s no need to specify the ID type when extending GraphRepository.
- Out of the box, you get several common CRUD operations, much like what JpaRepository and MongoRepository provide.
long count(); Returns a count of how many entities of the target type are in the database
void delete(Iterable<? extends T>); Deletes several entities
void delete(Long id); Deletes a single entity given its ID
void delete(T); Deletes a single entity
void deleteAll(); Deletes all entities of the target type
boolean exists(Long id); Checks for the existence of an entity given its ID
EndResult<T> findAll(); Retrieves all entities of the target type
Iterable<T> findAll(Iterable<Long>); Retrieves all entities of the target type for the given IDs
Page<T> findAll(Pageable); Retrieves a paged and sorted list of all entities of the target type
EndResult<T> findAll(Sort); Retrieves a sorted list of all entities of the target type
EndResult<T> findAllBySchemaPropertyValue(String, Object); Retrieves all entities where a given property matches the given value
Iterable<T> findAllByTraversal(N, TraversalDescription); Retrieves all entities obtained by following a graph traversal starting at a given node
T findBySchemaPropertyValue(String, Object); Finds a single entity where a given property matches a given value
T findOne(Long); Finds a single entity given its ID 
EndResult<T> query(String, Map<String,Object>); Finds all entities that match a given Cypher query
Iterable<T> save(Iterable<T>); Saves several entities
S save(S); Saves a single entity

e.g.
Order savedOrder = orderRepository.save(order);
- When the entity is saved, the save() method returns the saved entity, which now should have its @GraphId-annotated property populated if it was null before.
Order order = orderRepository.findOne(4L);
EndResult<Order> allOrders = orderRepository.findAll();
delete(order);
delete(order);

#ADDING QUERY METHODS <Test> <Test Done>
public interface OrderRepository extends GraphRepository<Order> {
	List<Order> findByCustomer(String customer);
	List<Order> findByCustomerAndType(String customer, String type);
}

#SPECIFYING CUSTOM QUERIES <Test> 
- When the naming convention doesn’t meet your needs, you also have the option of annotating a method with @Query to specify your own query.
- With Spring Data JPA, you used it to specify a JPA query for a repository method. 
- With Spring Data MongoDB, you used it to specify a JSON-matching query.
- When using Spring Data Neo4j, however, you must specify a Cypher query:
@Query("match (o:Order)-[:HAS_ITEMS]->(i:Item) where i.product='Spring in Action' return o")
List<Order> findSiAOrders();
- find all Order nodes that are related to an Item whose product property is equal to “Spring in Action”.

#MIXING IN CUSTOM REPOSITORY BEHAVIOR
- When neither the naming convention nor the @Query methods meet your needs, you always have the option of mixing in custom repository logic.
- start by defining an intermediary interface:
public interface OrderOperations {
	List<Order> findSiAOrders();
}
- make OrderRepository to extend OrderOperations in addition to GraphRepository:
public interface OrderRepository extends GraphRepository<Order>, OrderOperations {
	...
}
- write the implementation
public class OrderRepositoryImpl implements OrderOperations {		//Implement intermediate interface
	private final Neo4jOperations neo4j;
	
	@Autowired
	public OrderRepositoryImpl(Neo4jOperations neo4j) {				//Inject Neo4jOperations
		this.neo4j = neo4j;
	}
	
	public List<Order> findSiAOrders() { 
		Result<Map<String, Object>> result = neo4j.query(			//Perform query
		"match (o:Order)-[:HAS_ITEMS]->(i:Item) where i.product='Spring in Action' return o")
		EndResult<Order> endResult = result.to(Order.class);		//Convert to EndResult<Order>
		return IteratorUtil.asList(endResult);						//Convert to a List<Order>
	}
}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Working with key-value data in Redis
总而言之
1）Redis is a special kind of database known as a key-value store. key-value stores share a lot in common with hash maps. To call them persistent hash maps would not be too great of an oversimplification.
2）configure the connection factory as a bean
@Bean
public RedisConnectionFactory redisCF() { 
	return new JedisConnectionFactory();
}
3）configure a RedisTemplate
@Bean
public RedisTemplate<String, Product> redisTemplate(RedisConnectionFactory cf) {
	RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
	redis.setConnectionFactory(cf);
	return redis;
}
4) saving, fetching, and deleting key-value entries. <Test> <Test Done>
4.1) sub-APIs for working with simple values
redis.opsForValue().set(product.getSku(), product);
Product found = redis.opsForValue().get(product.getSku());
4.2) sub-APIs for working with list
redis.opsForList().rightPush("cart", product);
redis.opsForList().rightPush("cart", product2);
redis.opsForList().rightPush("cart", product3);
redis.opsForList().size("cart").longValue();
Product first = redis.opsForList().leftPop("cart");
Product last = redis.opsForList().rightPop("cart");
List<Product> products = redis.opsForList().range("cart", 2, 12);
4.3) sub-APIs for working with set
redis.opsForSet().add("cart", product);
redis.opsForSet().size("cart").longValue();
Set<Product> diff = redis.opsForSet().difference("cart1", "cart2");
Set<Product> union = redis.opsForSet().union("cart1", "cart2");
Set<Product> isect = redis.opsForSet().intersect("cart1", "cart2");
Product random = redis.opsForSet().randomMember("cart1");
4.4) sub-APIs for working with operations bound to a given key.
BoundListOperations<String, Product> cart = redis.boundListOps("cart");
cart.rightPush(product);
cart.rightPush(product2);
cart.rightPush(product3);
Product first = cart.leftPop();
Product last = cart.rightPop();

5) Redis key and value serializers
5.1) When an entry is saved to the "Redis key-value store", both the key and the value are serialized using a "Redis serializer". 
- domain object nedds to mark with Serializable interface, this is not required by ConcurrentHashMap and EhCache. 
- private static final long serialVersionUID = 1L; for what??
- all of these serializers implement the RedisSerializer interface, you can always create your own serializer.
	GenericToStringSerializer—Serializes using a Spring conversion service
	JacksonJsonRedisSerializer—Serializes objects to JSON using Jackson 1
	Jackson2JsonRedisSerializer—Serializes objects to JSON using Jackson 2
	JdkSerializationRedisSerializer—Uses Java serialization (used by RedisTemplate, keys and values are serialized through Java.)
	OxmSerializer—Serializes using marshalers and unmarshalers from Spring’s O/X mapping, for XML serialization
	StringRedisSerializer—Serializes String keys and values (used by StringRedisTemplate by default)

5.2) suppose that when using RedisTemplate, you want to serialize Product values to JSON with String keys. <Test> <Test Done>
- set RedisTemplate to always use StringRedisSerializer when serializing key values. 
- also specify that it should use Jackson2JsonRedisSerializer only when serializing Product values.
@Bean
public RedisTemplate<String, Product>redisTemplate(RedisConnectionFactory cf) {
	RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
	redis.setConnectionFactory(cf);
	redis.setKeySerializer(new StringRedisSerializer());
	redis.setValueSerializer(new Jackson2JsonRedisSerializer<Product>(Product.class));
	return redis;
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Redis is a special kind of database known as a key-value store. 
- key-value stores share a lot in common with hash maps. To call them persistent hash maps would not be too great of an oversimplification.
- there aren’t too many kinds of queries that you can perform against a hash map ... or a key-value store. You can store a value at a particular key, and you can fetch the value for a particular key. That’s about it.
- Consequently, Spring Data’s automatic repository support doesn’t make a lot of sense when applied to Redis. On the other hand, Spring Data’s other key feature, template-oriented data access, can come in handy when working with Redis.

#Connecting to Redis
- A Redis connection factory produces connections to a Redis database server. 
- Spring Data Redis comes with connection factories for four Redis client implementations:
	JedisConnectionFactory
	JredisConnectionFactory
	LettuceConnectionFactory
	SrpConnectionFactory
- configure the connection factory as a bean

@Bean
public RedisConnectionFactory redisCF() {
	return new JedisConnectionFactory();
}
- Instantiating the connection factory via its default constructor results in a connection factory that creates its connections for localhost, port 6379, and with no password.
- If your Redis server is running on a different host or port, you can set those properties when you create the connection factory:
@Bean
public RedisConnectionFactory redisCF() {
	JedisConnectionFactory cf = new JedisConnectionFactory();
	cf.setHostName("redis-server");
	cf.setPort(7379);
	return cf;
}

if your Redis server is configured to require authorization from clients:
@Bean
public RedisConnectionFactory redisCF() {
	JedisConnectionFactory cf = new JedisConnectionFactory();
	cf.setHostName("redis-server");
	cf.setPort(7379);
	cf.setPassword("foobared");
	return cf;
}

#Working with RedisTemplate
- Using RedisConnection, you can store and read data. 
RedisConnectionFactory cf = ...;
RedisConnection conn = cf.getConnection();
conn.set("greeting".getBytes(), "Hello World".getBytes());

byte[] greetingBytes = conn.get("greeting".getBytes());
String greeting = new String(greetingBytes);

- Spring Data Redis offers two templates:
	RedisTemplate
	StringRedisTemplate

- RedisTemplate is a class that greatly simplifies Redis data access, enabling you to persist keys and values of any type, not just byte arrays. 
- In recognition of the fact that keys and values are frequently Strings, StringRedisTemplate extends RedisTemplate to have a String focus.

construct a RedisTemplate:
RedisConnectionFactory cf = ...;
RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
redis.setConnectionFactory(cf);

- If you know that you’ll be working with both String values and String keys, then you should consider using StringRedisTemplate instead of RedisTemplate:
RedisConnectionFactory cf = ...;
StringRedisTemplate redis = new StringRedisTemplate(cf);

- if you’ll be using RedisTemplate or StringRedisTemplate frequently, you might consider configuring them as beans to be injected where they’re needed.
@Bean
public RedisTemplate<String, Product> redisTemplate(RedisConnectionFactory cf) {
	RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
	redis.setConnectionFactory(cf);
	return redis;
}

@Bean
public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory cf) {
	return new StringRedisTemplate(cf);
}

- Once you have a RedisTemplate (or StringRedisTemplate), you can start saving, fetching, and deleting key-value entries. Most of the operations provided by RedisTemplate are available via the sub-APIs:

#WORKING WITH SIMPLE VALUES
- save a Product to a RedisTemplate<String, Product> where the key is the value of the sku property
redis.opsForValue().set(product.getSku(), product);

- fetch a product whose sku is 123456
Product product = redis.opsForValue().get("123456");

#WORKING WITH LISTS
- add a value to the end of a list entry
redis.opsForList().rightPush("cart", product);
- inserts a value at the beginning
redis.opsForList().leftPush("cart", product);
- fetch an item from a list, have the side effect of removing the popped items from the list
Product first = redis.opsForList().leftPop("cart");
Product last = redis.opsForList().rightPop("cart");
- simply retrieve the value (perhaps even from the middle of the list), you can use the range() method
List<Product> products = redis.opsForList().range("cart", 2, 12);

#PERFORMING OPERATIONS ON SETS
- add an item to a set entry:
redis.opsForSet().add("cart", product);
- difference, intersection, and union.
List<Product> diff = redis.opsForSet().difference("cart1", "cart2");
List<Product> union = redis.opsForSet().union("cart1", "cart2");
List<Product> isect = redis.opsForSet().isect("cart1", "cart2");
- remove items: 
redis.opsForSet().remove(product);
- fetch a random element from the set:
Product random = redis.opsForSet().randomMember("cart");

- you’re storing Product objects in a list entry whose key is cart; suppose that you want to pop an item from the right end of the list and then add three new items to the end of the list.

#BINDING TO A KEY
BoundListOperations<String, Product> cart = redis.boundListOps("cart");
Product popped = cart.rightPop();
cart.rightPush(product1);
cart.rightPush(product2);
cart.rightPush(product3);

#Setting key and value serializers
- When an entry is saved to the "Redis key-value store", both the key and the value are serialized using a Redis serializer
	GenericToStringSerializer—Serializes using a Spring conversion service
	JacksonJsonRedisSerializer—Serializes objects to JSON using Jackson 1
	Jackson2JsonRedisSerializer—Serializes objects to JSON using Jackson 2
	JdkSerializationRedisSerializer—Uses Java serialization
	OxmSerializer—Serializes using marshalers and unmarshalers from Spring’s O/X mapping, for XML serialization
	StringRedisSerializer—Serializes String keys and values

- All of these serializers implement the RedisSerializer interface, so if there’s not one to suit your needs, you can always create your own serializer.
- RedisTemplate uses JdkSerializationRedisSerializer, which means that keys and values are serialized through Java.
- StringRedisTemplate uses StringRedisSerializer by default, essentially converting the String values to and from byte arrays.
- you may find it helpful to plug in a different serializer. For example, suppose that when using RedisTemplate, you want to serialize Product values to JSON with String keys.
@Bean
public RedisTemplate<String, Product>redisTemplate(RedisConnectionFactory cf) {
	RedisTemplate<String, Product> redis = new RedisTemplate<String, Product>();
	redis.setConnectionFactory(cf);
	redis.setKeySerializer(new StringRedisSerializer());
	redis.setValueSerializer(new Jackson2JsonRedisSerializer<Product>(Product.class));
	return redis;
}

- set RedisTemplate to always use StringRedisSerializer when serializing key values. 
- also specify that it should use Jackson2JsonRedisSerializer only when serializing Product values.

- The Spring Data project enables developers to use these databases in their Spring applications and to use abstractions that are reasonably consistent across the various database choices.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 13 - Caching data
总而言之
1）Caching is a way to store frequently needed information so that it’s readily available when needed.
2）Spring doesn’t implement a cache solution, it offers declarative support for caching that integrates with several popular caching implementations.
3) Cache managers enables integration with one of several popular caching implementations.
4) Spring 3.1 comes with five cache-manager implementations: SimpleCacheManager, NoOpCacheManager, ConcurrentMapCacheManager, CompositeCacheManager, 	EhCacheCacheManager
5) Spring 3.2 introduced another cache manager for working with JCache (JSR-107) based cache providers.
6) Spring Data offers two more cache managers: RedisCacheManager (from Spring Data Redis), GemfireCacheManager (from Spring Data GemFire)
7) ConcurrentMapCacheManager is a simple cache manager uses a java.util.concurrent.ConcurrentHashMap as its cache store. Its simplicity makes it a tempting choice for development, testing, or basic applications.
7.1）Enable caching using ConcurrentMapCacheManager <Test> <Test Done>
@Configuration
@EnableCaching												//Enable caching
public class CachingConfig {
	@Bean
	public CacheManager cacheManager() {					//Declare a cache manager
		return new ConcurrentMapCacheManager();
	}
}
8) Ehcache is one of the most popular cache providers, Spring offer a cache manager EhCacheCacheManager that integrates with Ehcache. <Test> <Test Done> 
8.1) configure EhCacheCacheManager bean
@Configuration
@EnableCaching
public class CachingConfig {
	@Bean
	public EhCacheCacheManager cacheManager(CacheManager cm) {		//Configure EhCacheCacheManager, inject an Ehcache CacheManager
		return new EhCacheCacheManager(cm);
	}
	
	@Bean
	public EhCacheManagerFactoryBean ehcache() {												//EhCacheManagerFactoryBean, generates an Ehcache CacheManager
		EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
		ehCacheFactoryBean.setConfigLocation(new ClassPathResource("com/habuma/spittr/cache/ehcache.xml"));
		return ehCacheFactoryBean;
}

8.2) configure Echache, ehcache.xml
<ehcache>
	<cache name="spittleCache" maxBytesLocalHeap="50m" timeToLiveSeconds="100">
	</cache>
</ehcache>

9) Spring Data Redis offers RedisCacheManager, an implementation of CacheManager. RedisCacheManager works with a Redis server via a RedisTemplate: <Test> <Test Done>
@Configuration
@EnableCaching
public class CachingConfig {
	@Bean
	public CacheManager cacheManager(RedisTemplate redisTemplate) {
		return new RedisCacheManager(redisTemplate);
	}
	
	@Bean
	public JedisConnectionFactory redisConnectionFactory() {
		JedisConnectionFactory jedisConnectionFactory =
		new JedisConnectionFactory();
		jedisConnectionFactory.afterPropertiesSet();
		return jedisConnectionFactory;
	}
	
	@Bean
	public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory redisCF) {
		RedisTemplate<String, String> redisTemplate = new RedisTemplate<String, String>();
		redisTemplate.setConnectionFactory(redisCF);
		redisTemplate.afterPropertiesSet();
		return redisTemplate;
	}
}

10) CompositeCacheManager is configured with one or more cache managers and iterates over them all as it tries to find a previously cached value. create a CompositeCacheManager bean that iterates over a JCacheCacheManager, an EhCacheCacheManager, and a RedisCacheManager. <Test> <Test Done>
@Bean
public CacheManager cacheManager(net.sf.ehcache.CacheManager cm, javax.cache.CacheManager jcm) {
	CompositeCacheManager cacheManager = new CompositeCacheManager();
	List<CacheManager> managers = new ArrayList<CacheManager>();
	managers.add(new JCacheCacheManager(jcm));
	managers.add(new EhCacheCacheManager(cm))
	managers.add(new RedisCacheManager(redisTemplate()));
	cacheManager.setCacheManagers(managers);
	return cacheManager;
}

11) Spring+Hibernate+Ehcache integration <Test> <Failed> paritialy, everytime the session open, if will fire the sql at least once.
- 大量数据流动是web应用性能问题常见的原因，而缓存被广泛的用于优化数据库应用。cache被设计为通过保存从数据库里load的数据来减少应用和数据库之间的数据流动。数据库访问只有当检索的数据不在cache里可用时才必要。
- hibernate可以用两种不同的对象缓存：first-level cache 和 second-level cache。first-level cache和Session对象关联，而second-level cache是和Session Factory对象关联。
- hibernate默认使用基于每个事务的first-level cache。Hibernate用first-level cache主要是减少在一个事务内的sql查询数量。 例如，如果一个对象在同一个事务内被修改多次， hibernate将只生成一个包括所有修改的 UPDATE SQL语句。
- second-level cache在Session Factory级的不同事务之间保持load的对象，这些对象对整个应用可用，不只是对当前用户正在运行的查询。这样，每次查询将返回已经load在缓存 里的对象，避免一个或更多潜在的数据库事务。 
11.1) HibernateSessionFactoryBean
@Bean
public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
    LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
    sfb.setDataSource(dataSource);
    sfb.setPackagesToScan(new String[] { "spittr.domain" });
    Properties props = new Properties();
    props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
    props.setProperty("hibernate.cache.use_second_level_cache", "true");
    props.setProperty("hibernate.cache.use_query_cache", "true");
    props.setProperty("hibernate.cache.region.factory_class", "org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory");
    props.setProperty("hibernate.show_sql", "true");
    sfb.setHibernateProperties(props);
    return sfb;
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Stateless components tend to scale better, but they also tend to ask the same question over and over again. 
- Because they’re stateless, they discard any answer they were given once their current task is complete, and they have to ask the question again
the next time that same answer is needed.
- Sometimes it takes a little while to fetch or calculate the answer to the question being asked. Maybe you must fetch data from the database, invoke a remote service, or perform a complex calculation. That’s time and resources spent arriving at the answer.
- If that answer isn’t likely to change frequently (or at all), then it’s wasteful to go through the same channel to fetch it again. it makes sense to ask once and remember that answer
- Caching is a way to store frequently needed information so that it’s readily available when needed.
- Spring doesn’t implement a cache solution, it offers declarative support for caching that integrates with several popular caching implementations.

#Enabling cache support
- Spring’s cache abstraction comes in two forms:
	Annotation-driven caching
	XML-declared caching
- declarative caching: @Cacheable, @CacheEvict
- enable Spring’s support for annotation-driven caching:
@Configuration
@EnableCaching												//Enable caching
public class CachingConfig {
	@Bean
	public CacheManager cacheManager() {					//Declare a cache manager
		return new ConcurrentMapCacheManager();
	}
}
- xml config:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/cache
			http://www.springframework.org/schema/cache/spring-cache.xsd">
		
	<cache:annotation-driven />
	<bean id="cacheManager" class="org.springframework.cache.concurrent.ConcurrentMapCacheManager" />
</beans>

- Under the covers, @EnableCaching and <cache:annotation-driven> work the same way. They create an aspect with pointcuts that trigger off of Spring’s caching annotations.
- Depending on the annotation used and the state of the cache, that aspect will fetch a value from the cache, add a value to the cache, or remove a value from the cache.
- Cache managers are the heart of Spring’s cache abstraction, enabling integration with one of several popular caching implementations.
- ConcurrentMapCacheManager is a simple cache manager uses a java.util.concurrent.ConcurrentHashMap as its cache store. Its simplicity
makes it a tempting choice for development, testing, or basic applications.
- But because its cache storage is memory-based and thus tied to the lifecycle of the application, it’s probably not an ideal choice for larger production applications. 

#Configuring a cache manager
- Spring 3.1 comes with five cache-manager implementations
	SimpleCacheManager
	NoOpCacheManager
	ConcurrentMapCacheManager
	CompositeCacheManager
	EhCacheCacheManager

- Spring 3.2 introduced another cache manager for working with JCache (JSR-107) based cache providers.
- Outside of the core Spring Framework, Spring Data offers two more cache managers:
	RedisCacheManager (from Spring Data Redis)
	GemfireCacheManager (from Spring Data GemFire)
- Although the of cache manager will have implications for how your data is cached, it will have no bearing on the way you declare caching rules in Spring.

#CACHING WITH EHCACHE
- Ehcache is one of the most popular cache providers, Spring offer a cache manager EhCacheCacheManager that integrates with Ehcache. 

1) configure EhCacheCacheManager bean
@Configuration
@EnableCaching
public class CachingConfig {
	@Bean
	public EhCacheCacheManager cacheManager(CacheManager cm) {		//Configure EhCacheCacheManager, inject an Ehcache CacheManager
		return new EhCacheCacheManager(cm);
	}
	
	@Bean
	public EhCacheManagerFactoryBean ehcache() {												//EhCacheManagerFactoryBean, generates an Ehcache CacheManager
		EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
		ehCacheFactoryBean.setConfigLocation(new ClassPathResource("com/habuma/spittr/cache/ehcache.xml"));
		return ehCacheFactoryBean;
}

- The cacheManager() method creates an instance of EhCacheCacheManager by passing in an instance of an Ehcache CacheManager.
- This particular bit of injection can be confusing because both Spring and Ehcache define a CacheManager type. 
- To be clear, Ehcache’s CacheManager is being injected into Spring’s EhCacheCacheManager (which implements Spring’s CacheManager implementation).
- So that you’ll have an Ehcache CacheManager to inject, you must also declare a CacheManager bean. To make that easy, Spring provides an EhCacheManagerFactoryBean that generates an Ehcache CacheManager.
- The ehcache() method creates and returns an instance of EhCacheManagerFactoryBean. Because it’s a factory bean (that is, it implements Spring’s FactoryBean interface), the bean that is registered in the Spring application context isn’t an instance of EhCacheManagerFactoryBean but rather is an
instance of CacheManager, suitable for injection into EhCacheCacheManager.

2) configure Echache
- There’s more to Ehcache configuration than the beans you’ll configure in Spring.
- Ehcache defines its own configuration schema for XML, and you’ll configure caching specifics in an XML file that adheres to that schema.
- In the course of creating the EhCacheManagerFactoryBean, you need to tell it where the Ehcache configuration XML is located.
- Here you call the setConfigLocation() method, passing a ClassPathResource to specify the location of the Ehcache XML configuration relative to the
root of the classpath.
- The contents of the ehcache.xml file vary from application to application, but you need to declare at least a minimal cache.
- declares a cache named spittleCache with 50 MB of maximum heap storage and a time-to-live of 100 seconds:
<ehcache>
	<cache name="spittleCache" maxBytesLocalHeap="50m" timeToLiveSeconds="100">
	</cache>
</ehcache>
- Consult Ehcache’s documentation at http://ehcache.org/documentation/configuration for details on how to fine-tune your Ehcache configuration.

#USING REDIS FOR CACHING
- Spring Data Redis offers RedisCacheManager, an implementation of CacheManager.
- RedisCacheManager works with a Redis server via a RedisTemplate to store cache entries in Redis.
@Configuration
@EnableCaching
public class CachingConfig {
	@Bean
	public CacheManager cacheManager(RedisTemplate redisTemplate) {
		return new RedisCacheManager(redisTemplate);
	}
	
	@Bean
	public JedisConnectionFactory redisConnectionFactory() {
		JedisConnectionFactory jedisConnectionFactory =
		new JedisConnectionFactory();
		jedisConnectionFactory.afterPropertiesSet();
		return jedisConnectionFactory;
	}
	
	@Bean
	public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory redisCF) {
		RedisTemplate<String, String> redisTemplate = new RedisTemplate<String, String>();
		redisTemplate.setConnectionFactory(redisCF);
		redisTemplate.afterPropertiesSet();
		return redisTemplate;
	}
}

#WORKING WITH MULTIPLE CACHE MANAGERS
- If you’re having trouble pinning down which cache manager to use, or if you have valid technical reasons for choosing more than one cache manager, you can try Spring’s CompositeCacheManager.
- CompositeCacheManager is configured with one or more cache managers and iterates over them all as it tries to find a previously cached value.
- create a CompositeCacheManager bean that iterates over a JCacheCacheManager, an EhCacheCacheManager, and a RedisCacheManager.
@Bean
public CacheManager cacheManager(net.sf.ehcache.CacheManager cm, javax.cache.CacheManager jcm) {
	CompositeCacheManager cacheManager = new CompositeCacheManager();
	List<CacheManager> managers = new ArrayList<CacheManager>();
	managers.add(new JCacheCacheManager(jcm));
	managers.add(new EhCacheCacheManager(cm))
	managers.add(new RedisCacheManager(redisTemplate()));
	cacheManager.setCacheManagers(managers);
	return cacheManager;
}
- When it’s time to look for a cache entry, CompositeCacheManager starts with JCacheCacheManager to check the JCache implementation, then turns to Ehcache by
checking with EhCacheCacheManager, and finally consults with RedisCacheManager to check Redis for the cache entry.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Annotating methods for caching
总而言之 (caching annotation)
1）Spring’s caching annotations.
1.1) @Cacheable:  Indicates that Spring should look in a cache for the method’s return value before invoking the method. If the value is found, the cached value is returned. If not, then the method is invoked and the return value is put in the cache.
1.2) @CachePut: Indicates that Spring should put the method’s return value in a cache. The cache isn’t checked prior to method invocation, and the method is always invoked.
1.3) @CacheEvict: Indicates that Spring should evict one or more entries from a cache.
1.4) @Caching: A grouping annotation for applying multiples of the other caching annotations at once.

2) @Cacheable and @CachePut share a common set of attributes:
value: String[]: The name(s) of the cache(s) to use
condition: String: A SpEL expression that, if it evaluates to false, results in caching not being applied to the method call 
key: String: A SpEL expression to calculate a custom cache key
unless: String: A SpEL expression that, if it evaluates to true, prevents the return value from being put in the cache

3) @Cacheable - simple form <Test> <Test Done>
@Cacheable("spittleCache")
public Spittle findOne(long id) {
	try {
		return jdbcTemplate.queryForObject(
			SELECT_SPITTLE_BY_ID,
			new SpittleRowMapper(),
			id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		}
}

4) Both @Cacheable and @CachePut have a key attribute that lets you replace the default key with one derived from a SpEL expression. Spring exposes several pieces of metadata that come in handy when you’re writing SpEL expressions for caching:
#root.args: The arguments passed in to the cached method, as an array
#root.caches: The caches this method is executed against, as an array
#root.target: The target object
#root.targetClass: The target object’s class; a shortcut for #root.target.class
#root.method: The cached method
#root.methodName: The cached method’s name; a shortcut for #root.method.name
#result: The return value from the method call (not available with @Cacheable)
#Argument: The name of any method argument (such as #argName) or argument index (such as #a0 or #p0) 

5) @CachePut with custom key 	<Test> <Test Done>
@CachePut(value="spittleCache", key="#result.id")
Spittle save(Spittle spittle)

6) unless attribute:  prevent an object from being placed in the cache, but the cache is still searched when the method is called, and if a match is found, it’s returned. suppose you don’t want to cache any Spittle objects whose message property contains the text “NoCache”: <Test> <Test Done>
@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')") 	
Spittle findOne(long id);

7) condition attribute: if condition’s expression evaluates to false, then caching is disabled for the duration of the method invocation. The cache isn’t searched, nor is the return value placed in the cache. suppose you don’t want caching to be applied to any Spittle whose ID is less than 10. <Test> <Test Done>
@Cacheable(value="spittleCache", unless="#result.message.contains('NoCache')", condition="#id >= 10")
Spittle findOne(long id);

8) if an @CacheEvict annotated method is called, one or more entries are removed from the cache. Unlike @Cacheable and @CachePut, @CacheEvict can be used on void methods. <Test> <Test Done>
@CacheEvict("spittleCache")
void remove(long spittleId);

9) @CacheEvict attributes:
value: String[]: The name(s) of the cache(s) to use.
key: String: A SpEL expression to calculate a custom cache key.
condition: String: A SpEL expression that, if it evaluates to false, results in caching not being applied to the method call.
allEntries: boolean: If true, all entries in the specified cache(s) should be removed.
beforeInvocation: boolean: If true, the entries are removed from the cache before the method is invoked. If false (the default), the entries are removed after a successful method invocation.

10) XML config:
<aop:config>
	<aop:advisor advice-ref="cacheAdvice" pointcut= "execution(* com.habuma.spittr.db.SpittleRepository.*(..))"/> 	//Bind cache advice to a pointcut
</aop:config>

<cache:advice id="cacheAdvice">
	<cache:caching cache="spittleCache" >
		<cache:cacheable method="findRecent" />					//Make cacheable
		<cache:cacheable method="findOne" />					//Make cacheable
		<cache:cacheable method="findBySpitterId" />			//Make cacheable
		<cache:cache-put method="save" key="#result.id" />		//Populate cache on save
		<cache:cache-evict method="remove" />					//Remove from cache
	</cache:caching>
</cache:advice>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Spring’s caching abstraction is largely built around aspects. When you enable caching in Spring, an aspect is created that triggers off one or more
of Spring’s caching annotations.
1) @Cacheable:  Indicates that Spring should look in a cache for the method’s return value before invoking the method. If the value is found, the cached value is returned. If not, then the method is invoked and the return value is put in the cache.
2) @CachePut: Indicates that Spring should put the method’s return value in a cache. The cache isn’t checked prior to method invocation, and the method is always invoked.
3) @CacheEvict: Indicates that Spring should evict one or more entries from a cache.
4) @Caching: A grouping annotation for applying multiples of the other caching annotations at once.

- All the annotations in can be placed either on a method or on a class.
- @Cacheable and @CachePut annotations can both populate a cache. They work in slightly different ways
- @Cacheable looks for an entry in the cache first, preempting the method invocation if a matching entry is found. If no matching entry is found, the method is invoked and the value returned is put in the cache.
- @CachePut never checks for a matching value in the cache, always allows the target method to be invoked, and adds the returned value to the cache.

@Cacheable and @CachePut share a common set of attributes:
value: String[]: The name(s) of the cache(s) to use
condition: String: A SpEL expression that, if it evaluates to false, results in caching not being applied to the method call 
key: String: A SpEL expression to calculate a custom cache key
unless: String: A SpEL expression that, if it evaluates to true, prevents the return value from being put in the cache

- consider the findOne() method from SpittleRepository. Once it’s initially saved, a Spittle isn’t likely to change. 
- If any particular Spittle is popular and is requested frequently, it’s a waste of time and resources to fetch it from the database repeatedly. 
- By annotating the findOne() method with @Cacheable, you can make sure the Spittle is cached and avoid unnecessary trips to the database.

@Cacheable("spittleCache")
public Spittle findOne(long id) {
	try {
		return jdbcTemplate.queryForObject(
			SELECT_SPITTLE_BY_ID,
			new SpittleRowMapper(),
			id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		}
}

- When findOne() is called, the caching aspect intercepts the call and looks for a previously returned value in the cache named spittleCache.
- The cache key is the id parameter passed to the findOne() method. If a value is found for that key, the found value will be returned and the method won’t be invoked. 
- if no value is found, then the method will be invoked and the returned value will be put in the cache, ready for the next time findOne() is called.
- the @Cacheable annotation is placed on the implementation of findOne() in JdbcSpittleRepository. That will work, but the caching is confined to only the JdbcSpittleRepository implementation.
- you might consider placing the annotation on the method declaration in SpittleRepository instead of the implementation: <Test> <Test Done>
@Cacheable("spittleCache")
Spittle findOne(long id);
- When you annotate the interface method, the @Cacheable annotation will be inherited by all implementations.

#PUTTING VALUES IN THE CACHE
- Whereas @Cacheable conditionally invokes a method, depending on whether the desired value is already in the cache, @CachePut applies a more linear flow to methods that it annotates.
- An @CachePut-annotated method is always invoked and its return value is placed in the cache. This offers a handy way to preload a cache before anyone
comes asking.
- For example, when a brand-new Spittle is saved via the save() method on SpittleRepository, there’s a high likelihood that it will soon be asked for.
- you can annotate the save() method with @CachePut like this:
@CachePut("spittleCache")
Spittle save(Spittle spittle);
- When save() is called, it does whatever it needs to do to save the Spittle. Then the returned Spittle is placed in the spittleCache cache.

#CUSTOMIZING THE CACHE KEY
- the default cache key is based on the parameters to the method. Because the only parameter to save() is a Spittle, it’s used as the cache key.
- the default cache key isn’t what you want in this case. You need the cache key to be the ID of the newly saved Spittle, not the Spittle itself. So, you need to specify a key other than the default key. 
- Both @Cacheable and @CachePut have a key attribute that lets you replace the default key with one derived from a SpEL expression.
- Spring exposes several pieces of metadata that come in handy when you’re writing SpEL expressions for caching. 
#root.args: The arguments passed in to the cached method, as an array
#root.caches: The caches this method is executed against, as an array
#root.target: The target object
#root.targetClass: The target object’s class; a shortcut for #root.target.class
#root.method: The cached method
#root.methodName: The cached method’s name; a shortcut for #root.method.name
#result: The return value from the method call (not available with @Cacheable)
#Argument: The name of any method argument (such as #argName) or argument index (such as #a0 or #p0)

- you can reference the id property by setting the key attribute to #result.id:
@CachePut(value="spittleCache", key="#result.id")
Spittle save(Spittle spittle);

#CONDITIONAL CACHING 
- @Cacheable and @CachePut offer two attributes for conditional caching: unless and condition.
- If the unless attribute’s SpEL expression evaluates to true, then the data returned from the cached method isn’t placed in the cache.
- if the condition attribute’s SpEL expression evaluates to false, then caching is effectively disabled for the method.
- The unless attribute can only prevent an object from being placed in the cache. But the cache is still searched when the method is called, and if a match is found, it’s returned.
- On the other hand, if condition’s expression evaluates to false, then caching is disabled for the duration of the method invocation. The cache isn’t searched, nor is the return value placed in the cache.
- suppose you don’t want to cache any Spittle objects whose message property contains the text “NoCache”. To prevent such Spittles from being cached, you can set the unless attribute like this:
@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')")
Spittle findOne(long id);
- you may not want values added to the cache or fetched from the cache under certain conditions. suppose you don’t want caching to be applied to any Spittle whose ID is less than 10.
@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')" condition="#id >= 10")
Spittle findOne(long id);
-If findOne() is called with any value less than 10 as the parameter, the cache will not be searched, nor will the returned Spittle be placed in the cache. It will be as if there is no @Cacheable annotation on the method.
- the unless attribute expression can refer to the return value by referring to #result. This is possible and useful because unless doesn’t start doing its job until a value is returned from the cached method.
- On the other hand, condition has the job of disabling caching on the method. Therefore, it can’t wait until the method has completed to decide if it needs to shut down caching. This means its expression must be evaluated on the way into the method and that you can’t refer to the return value with #result.

#Removing cache entries
- if an @CacheEvict annotated method is called, one or more entries are removed from the cache.
- Any time a cached value is no longer valid, you should make sure it’s removed from the cache so that future cache hits won’t return stale or otherwise nonexistent data.
- One such case is when data is deleted.
@CacheEvict("spittleCache")
void remove(long spittleId);
- Unlike @Cacheable and @CachePut, @CacheEvict can be used on void methods.
- @Cacheable and @CachePut require a non-void return value, which is the item to place in the cache.
- @CacheEvict is only removing items from the cache, it can be placed on any method, even a void one.
- @CacheEvict has several attributes:
value: String[]: The name(s) of the cache(s) to use.
key: String: A SpEL expression to calculate a custom cache key.
condition: String: A SpEL expression that, if it evaluates to false, results in caching not being applied to the method call.
allEntries: boolean: If true, all entries in the specified cache(s) should be removed.
beforeInvocation: boolean: If true, the entries are removed from the cache before the method is invoked. If false (the default), the entries are removed after a successful method invocation.

#Declaring caching in XML
- reasons to use xml config for caching:
1) You don’t feel comfortable putting Spring-specific annotations in your source code.
2) You want to apply caching to beans for which you don’t own the source code.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/aop
		http://www.springframework.org/schema/aop/spring-aop.xsd
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/cache
		http://www.springframework.org/schema/cache/spring-cache.xsd">

	<!-- Caching configuration will go here -->
</beans>

- cache namespace defines the configuration elements for declaring caching in a Spring XML configuration file:
<cache:annotation-driven>: Enables annotation-driven caching. Equivalent to @EnableCaching in Java configuration.
<cache:advice>: Defines caching advice. Paired with <aop:advisor> to apply advice to a pointcut.
<cache:caching>: Defines a specific set of caching rules within the caching advice.
<cache:cacheable>: Designates a method as being cacheable. Equivalent to the @Cacheable annotation.
<cache:cache-put>: Designates a method as populating (but not considering) the cache. Equivalent to the @CachePut annotation.
<cache:cache-evict>: Designates a method as evicting one or more entries from the cache. Equivalent to the @CacheEvict annotation.

<aop:config>
	<aop:advisor advice-ref="cacheAdvice" pointcut= "execution(* com.habuma.spittr.db.SpittleRepository.*(..))"/> 	//Bind cache advice to a pointcut
</aop:config>

<cache:advice id="cacheAdvice">
	<cache:caching>
		<cache:cacheable cache="spittleCache" method="findRecent" />				//Make cacheable
		<cache:cacheable cache="spittleCache" method="findOne" />					//Make cacheable
		<cache:cacheable cache="spittleCache" method="findBySpitterId" />			//Make cacheable
		<cache:cache-put cache="spittleCache" method="save" key="#result.id" />		//Populate cache on save
		<cache:cache-evict cache="spittleCache" method="remove" />					//Remove from cache
	</cache:caching>
</cache:advice>

<bean id="cacheManager" class="org.springframework.cache.concurrent.ConcurrentMapCacheManager"/>

- an <aop:advisor> that references the advice whose ID is cacheAdvice. This element matches the advice with a pointcut, thus establishing a complete aspect.
- the aspect’s pointcut is triggered on the execution of any method of the SpittleRepository interface. If such a method is called on any bean in the Spring application context, the aspect’s advice will be invoked.
- The <cache:cacheable> elements each declare a method from the pointcut as being cacheable. It’s the XML equivalent to the @Cacheable annotation.
- <cache:cache-put> is Spring’s XML equivalent to the @CachePut annotation.
- the <cache:cache-evict> element is Spring’s XML alternative to the @CacheEvict annotation.
- the <cache:advice> element has a cache-manager attribute to specify the bean that serves as the cache manager. By default it’s cacheManager, which coincides with the <bean> declared at the end of listing 13.7, so there’s no need to explicitly set it.
- you can specify the cache name in the <cache:caching> annotation to remove that duplication of cache="spittleCache":
<cache:advice id="cacheAdvice">
	<cache:caching cache="spittleCache" >
		<cache:cacheable method="findRecent" />				//Make cacheable
		<cache:cacheable method="findOne" />					//Make cacheable
		<cache:cacheable method="findBySpitterId" />			//Make cacheable
		<cache:cache-put method="save" key="#result.id" />		//Populate cache on save
		<cache:cache-evict method="remove" />					//Remove from cache
	</cache:caching>
</cache:advice>

- <cache:caching> shares several attributes with <cache:cacheable>, <cache:cacheput>, and <cache:cache-evict>, including these:
cache—Specifies the cache to store values in and retrieve values from.
condition—A SpEL expression that, if it evaluates to false, disables caching for the method.
key—A SpEL expression used to derive the cache key. (Defaults to the method’s parameters.)
method—The name of the method to be cached.

- <cache:cacheable> and <cache:cache-put> have an unless attribute.
- The <cache:cache-evict> element offers a few unique attributes:
	all-entries—If true, all entries in the cache are removed. If false, only the entry matching the key is removed.
	before-invocation—If true, the cache entry (or entries) are removed before the method is invoked. If false, they’re removed after the method is invoked.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 15 Working with remote services
总而言之 （Spring remoting basics）
1）Remoting is a conversation between a client application and a service. 
2) remote procedure call (RPC) is a remote call from client to a remote service, On the surface, an RPC is similar to a call to a method on a local object. Both are synchronous operations, blocking execution in the calling code until the called procedure is complete.
3) Spring supports RPC via several remoting technologies.
3.1) Remote Method Invocation(RMI) - Accessing/exposing Java-based services when network constraints such as firewalls aren’t a factor.
3.2) Hessian or Burlap - Accessing/exposing Java-based services over HTTP when network constraints are a factor. Hessian is a binary protocol, whereas Burlap is XML-based 
3.3) HTTP invoker - Accessing/exposing Spring-based services when network constraints are a factor and you desire Java serialization over XML or proprietary
serialization.
3.4) JAX-RPC and JAX-WS - Accessing/exposing platform-neutral, SOAP-based web services.
3.5) JMS
4) common remoting machnism:
4.1) Server side: In all models, services can be configured into your application as Spring-managed beans, and exported as remote services using remote exporters.
4.2) Client side: The client makes calls to the proxy as if the proxy were providing the service functionality. The proxy communicates with the remote service on behalf of the client. It handles the details of connecting and making remote calls to the remote service.
4.3) Exception: if the call to the remote service results in a java.rmi.RemoteException, the proxy handles that exception and rethrows it as an unchecked RemoteAccessException.
4.4) any beans passed to or returned from remote calls may need to implement java.io.Serializable

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Several remoting technologies are available to you as a Java developer:
Remote Method Invocation (RMI)
Caucho’s Hessian and Burlap
Spring’s own HTTP-based remoting
Web services with JAX-RPC and JAX-WS

#An overview of Spring remoting
- Remoting is a conversation between a client application and a service. The remote application exposes the functionality through a remote service.
- The conversation between the other applications and Spittr begins with a remote procedure call (RPC) from the client applications. 
- On the surface, an RPC is similar to a call to a method on a local object. Both are synchronous operations, blocking execution in the calling code until the called procedure is complete.
- RPC is when execution flow is handed off from one application to another application, theoretically on a different machine in a remote location over the network.
- Spring supports RPC via several remoting technologies.
1) Remote Method Invocation(RMI) - Accessing/exposing Java-based services when network constraints such as firewalls aren’t a factor.
2) Hessian or Burlap - Accessing/exposing Java-based services over HTTP when network constraints are a factor. Hessian is a binary protocol, whereas Burlap is
XML-based 
3) HTTP invoker - Accessing/exposing Spring-based services when network constraints are a factor and you desire Java serialization over XML or proprietary
serialization.
4) JAX-RPC and JAX-WS - Accessing/exposing platform-neutral, SOAP-based web services.

- In all models, services can be configured into your application as Spring-managed beans.
- In Spring, remote services are proxied so that they can be wired into client code as if they were any other Spring bean.
- Spring-managed beans can be exported as remote services using remote exporters.
- The client makes calls to the proxy as if the proxy were providing the service functionality. The proxy communicates with the remote service on behalf of the client. It handles the details of connecting and making remote calls to the remote service.
- if the call to the remote service results in a java.rmi.RemoteException, the proxy handles that exception and rethrows it as an unchecked RemoteAccessException.
- any beans passed to or returned from remote calls may need to implement java.io.Serializable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
总而言之 （Spring RMI） <Test> <Test Done>
1）Create Service interface and ServiceImpl
2) Server side: 
2.1) RmiServiceExporter exports any Spring-managed bean as an RMI service. RmiServiceExporter wraps the bean in an adapter class. The adapter class is then bound to the RMI registry and proxies requests to the service class：
@Autowired
SpittleService spittleService;

@Bean
	public RmiServiceExporter rmiExporter(SpitterService spitterService) {
	RmiServiceExporter rmiExporter = new RmiServiceExporter();
	rmiExporter.setService(spitterService);
	rmiExporter.setServiceName("SpitterService");
	rmiExporter.setServiceInterface(SpitterService.class);
	return rmiExporter;
}

2.2) By default, RmiServiceExporter attempts to bind to an RMI registry on port 1099 of the local machine. If no RMI registry is found at that port, RmiServiceExporter will start one. If you’d rather bind to an RMI registry at a different port or host, you can specify that with the registryPort and registryHost properties.

3) Client Side: Spring’s RmiProxyFactoryBean is a factory bean that creates a proxy to an RMI service.
@Bean
public RmiProxyFactoryBean spitterService() {
	RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
	rmiProxy.setServiceUrl("rmi://localhost/SpitterService");
	rmiProxy.setServiceInterface(SpitterService.class);
	return rmiProxy;
}

4) RMI's disadvantages:
4.1) First, RMI has difficulty working across firewalls. That’s because RMI uses arbitrary ports for communication
4.2) Another thing to consider is that RMI is Java-based. That means both the client and the service must be written in Java. 
4.3) And because RMI uses Java serialization, the types of the objects being sent across the network must have the exact same version of the Java runtime on both sides of the call.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#RMI
- developing and accessing RMI services is tedious, involving several steps, both programmatic and manual. Spring simplifies the RMI model by providing a proxy factory bean that enables you to wire RMI services into your Spring application as if they were local JavaBeans.
- Spring also provides a remote exporter that makes short work of converting your Spring-managed beans into RMI services.

#Exporting an RMI service
- Tradtional way to write an RMI service
1 Write the service implementation class with methods that throw java.rmi.RemoteException.
2 Create the service interface to extend java.rmi.Remote.
3 Run the RMI compiler (rmic) to produce client stub and server skeleton classes.
4 Start an RMI registry to host the services.
5 Register the service in the RMI registry.

- Instead of writing RMI-specific classes with methods that throw RemoteException, you write a POJO that performs the functionality of your service. Spring handles the rest.
- The RMI service that you’ll create exposes the methods from the SpitterService interface.
public interface SpitterService {
	List<Spittle> getRecentSpittles(int count);
	void saveSpittle(Spittle spittle);
	void saveSpitter(Spitter spitter);
	Spitter getSpitter(long id);
	void startFollowing(Spitter follower, Spitter followee);
	List<Spittle> getSpittlesForSpitter(Spitter spitter);
	List<Spittle> getSpittlesForSpitter(String username);
	Spitter getSpitter(String username);
	Spittle getSpittleById(long id);
	void deleteSpittle(long id);
	List<Spitter> getAllSpitters();
}

- RmiServiceExporter exports any Spring-managed bean as an RMI service. 
- RmiServiceExporter turns POJOs into RMI services by wrapping them in a service adapter and binding the service adapter to the RMI registry and proxies requests to the service class—SpitterServiceImpl..
- The simplest way to use RmiServiceExporter to expose SpitterServiceImpl as an RMI service is to configure it in Spring with the following @Bean method:

@Bean
public RmiServiceExporter rmiExporter(SpitterService spitterService) {
	RmiServiceExporter rmiExporter = new RmiServiceExporter();
	rmiExporter.setService(spitterService);
	rmiExporter.setServiceName("SpitterService");
	rmiExporter.setServiceInterface(SpitterService.class);
	return rmiExporter;
}

- the spitterService bean is wired into the service property to indicate that the RmiServiceExporter is to export the bean as an RMI service. 
- The serviceName property names the RMI service. 
- the serviceInterface property specifies the interface that the service implements.
- By default, RmiServiceExporter attempts to bind to an RMI registry on port 1099 of the local machine. If no RMI registry is found at that port, RmiServiceExporter will start one.
- you can specify that with the registryPort and registryHost properties.
@Bean
public RmiServiceExporter rmiExporter(SpitterService spitterService) {
	RmiServiceExporter rmiExporter = new RmiServiceExporter();
	rmiExporter.setService(spitterService);
	rmiExporter.setServiceName("SpitterService");
	rmiExporter.setServiceInterface(SpitterService.class);
	rmiExporter.setRegistryHost("rmi.spitter.com");
	rmiExporter.setRegistryPort(1199);
	return rmiExporter;
}

#Wiring an RMI service
- Traditionally, RMI clients must use the RMI API’s Naming class to look up a service from the RMI registry.
try {
	String serviceUrl = "rmi:/spitter/SpitterService";
	SpitterService spitterService =	(SpitterService) Naming.lookup(serviceUrl);
	...
}
catch (RemoteException e) { ... }
catch (NotBoundException e) { ... }
catch (MalformedURLException e) { ... }

- Spring’s RmiProxyFactoryBean is a factory bean that creates a proxy to an RMI service. Using RmiProxyFactoryBean to reference an RMI SpitterService
@Bean
public RmiProxyFactoryBean spitterService() {
	RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
	rmiProxy.setServiceUrl("rmi://localhost/SpitterService");
	rmiProxy.setServiceInterface(SpitterService.class);
	return rmiProxy;
}

- the service is named SpitterService and is hosted on the local machine. Meanwhile, the interface that the service provides is specified with the serviceInterface property.

- RmiProxyFactoryBean produces a proxy object that talks to remote RMI services on behalf of the client. The client talks to the proxy through the service’s interface as if the remote service were a local POJO.
- use @Autowired to wire the service proxy into the client:
@Autowired
SpitterService spitterService;

- invoke methods on it as if it were a local bean:
public List<Spittle> getSpittles(String userName) {
	Spitter spitter = spitterService.getSpitter(userName);
	return spitterService.getSpittlesForSpitter(spitter);
}

- client code doesn’t even know it’s dealing with an RMI service. It’s given a SpitterService object via injection, without any concern for where it comes from.
- First, RMI has difficulty working across firewalls. That’s because RMI uses arbitrary ports for communication
- Another thing to consider is that RMI is Java-based. That means both the client and the service must be written in Java. And because RMI uses Java serialization, the types of the objects being sent across the network must have the exact same version of the Java runtime on both sides of the call.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Exposing remote services with Hessian and Burlap
总而言之，<Test> <Test Failed>
1) Hessian and Burlap are two solutions enable lightweight remote services over HTTP. Each aims to simplify web services by keeping both its API and its communication protocols as simple as possible.
2) Hessian, like RMI, uses binary messages to communicate between client and service. But unlike other binary remoting technologies (such as RMI), the binary message is portable to languages other than Java, including PHP, Python, C++, and C#.
3) Burlap is an XML-based remoting technology, which automatically makes it portable to any language that can parse XML. Unlike other XML-based remoting technologies (such as SOAP and XML-RPC), Burlap’s message structure is as simple as possible and doesn’t require an external definition language (such as WSDL or IDL).
4) The only difference is that Hessian messages are binary and Burlap messages are XML. Because Hessian messages are binary, they’re more bandwidth-friendly. If human readability is important to you (for debugging purposes), Burlap’s XML messages may be preferable.
4) Server side: 
4.1) configure a HessianServiceExporter. 
@Autowired
SpittleService spittleService;
@Bean
public HessianServiceExporter hessianExportedSpitterService(SpitterService service) {
	HessianServiceExporter exporter = new HessianServiceExporter();
	exporter.setService(spittleService);
	exporter.setServiceInterface(SpittleService.class);
	return exporter;
}
4.2) Configure a URL handler in your Spring configuration to dispatch Hessian service URLs to the appropriate Hessian service bean.
- requests to /spittle.service will ultimately be handled by the hessianExportedSpitterService bean (which is a proxy to SpitterServiceImpl).
- mappings.setProperty("/**", "defaultServletHttpRequestHandler") is to direct routing request to static resources to Servlet container's default servlet.
@Bean
public HandlerMapping httpInvokerMapping() {
    SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
    Properties mappings = new Properties();
    mappings.setProperty("/**", "defaultServletHttpRequestHandler");
    mappings.setProperty("/spittle.service", "hessianExportedSpitterService");
    mapping.setMappings(mappiangs);
    return mapping;
}

4.3) for the purposes of handling Hessian services, that DispatcherServlet needs a servlet mapping that catches *.service URLs, if you’re configuring DispatcherServlet by extending AbstractDispatcherServletInitializer or AbstractAnnotationConfigDispatcherServletInitializer:
@Override
protected String[] getServletMappings() {
	return new String[] { "/", "*.service" };
}
4.4) @Import(HessianServiceConfig.class) in WebConfig

5) Client Side:
5.1) the only difference between wiring the client side of an RMI-based service that of a Hessian-based service is to use HessianProxyFactoryBean instead of RmiProxyFactoryBean.
@Bean
public HessianProxyFactoryBean spitterService() {
	HessianProxyFactoryBean proxy = new HessianProxyFactoryBean();
	proxy.setServiceUrl("http://localhost:8080/spittle.service");
	proxy.setServiceInterface(SpittleService.class);
	return proxy;
}
5.2) In RemotingClientTest: @ContextConfiguration(classes= HessianClientConfig.class)

@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)
@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的<bean>，作用为：注册bean对象

6) Burlap <Test> <Test Done>
6.1) Service Side:
@Configuration
@ComponentScan(basePackages = "spittr.service")
public class BurlapServiceConfig {
    @Autowired
    SpittleService spittleService;

    @Bean
    public BurlapServiceExporter burlapExportedSpittleService() {
        BurlapServiceExporter exporter = new BurlapServiceExporter();
        exporter.setService(spittleService);
        exporter.setServiceInterface(SpittleService.class);
        return exporter;
    }

    @Bean
    public HandlerMapping httpInvokerMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        Properties mappings = new Properties();
        mappings.setProperty("/**", "defaultServletHttpRequestHandler");
        mappings.setProperty("spittle.service", "burlapExportedSpittleService");
        mapping.setMappings(mappings);
        return mapping;
    }
}
6.2) Client side:
@Configuration
public class BurlapClientConfig {
    @Bean
    public BurlapProxyFactoryBean spittleService() {
        BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
        proxy.setServiceUrl("http://localhost:8080/spittle.service");
        proxy.setServiceInterface(SpittleService.class);
        return proxy;
    }
}

7) Hessian and Burlap vs. RMI
7.1) Because both Hessian and Burlap are based on HTTP, they don’t suffer from the same firewall issues as RMI.
7.2) But RMI has both Hessian and Burlap beat when it comes to serializing objects that are sent in RPC messages. Whereas Hessian and Burlap both use a proprietary serialization mechanism, RMI uses Java’s own serialization mechanism. If your data model is complex, the Hessian/Burlap serialization model may not be sufficient.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Hessian and Burlap are two solutions provided by Caucho Technology that enable lightweight remote services over HTTP. 
- Each aims to simplify web services by keeping both its API and its communication protocols as simple as possible.
- Hessian, like RMI, uses binary messages to communicate between client and service. But unlike other binary remoting technologies (such as RMI), the binary message is portable to languages other than Java, including PHP, Python, C++, and C#.
- Burlap is an XML-based remoting technology, which automatically makes it portable to any language that can parse XML.
- Unlike other XML-based remoting technologies (such as SOAP and XML-RPC), Burlap’s message structure is as simple as possible and doesn’t require an external definition language (such as WSDL or IDL).
- The only difference is that Hessian messages are binary and Burlap messages are XML. Because Hessian messages are binary, they’re more bandwidth-friendly. If human readability is important to you (for debugging purposes), Burlap’s XML messages may be preferable

#EXPORTING A HESSIAN SERVICE
- To expose the Spitter service bean as an RMI service, you had to configure an RmiServiceExporter bean in the Spring configuration. Similarly, to expose
the Spitter service as a Hessian service, you need to configure another exporter bean. This time it’ll be a HessianServiceExporter.
- HessianServiceExporter is a Spring MVC controller that exports a POJO as a Hessian service by receiving Hessian requests and translating them into calls to the POJO.

@Bean
public HessianServiceExporter hessianExportedSpitterService(SpitterService service) {
	HessianServiceExporter exporter = new HessianServiceExporter();
	exporter.setService(service);
	exporter.setServiceInterface(SpittleService.class);
	return exporter;
}

- the service property is wired with a reference to the bean that implements the service. Here, that’s a reference to the spitterService bean. The serviceInterface is set to indicate that SpitterService is the interface the service implements.
- Another major difference between RmiServiceExporter and HessianServiceExporter is that because Hessian is HTTP-based, HessianServiceExporter is implemented
as a Spring MVC controller.
- perform two additional configuration steps:
1) Configure a Spring DispatcherServlet in web.xml, and deploy your application as a web application. for the purposes of handling Hessian services, that DispatcherServlet needs a servlet mapping that catches *.service URLs:
1.1) If you’re configuring DispatcherServlet in Java by implementing WebApplicationInitializer,
ServletRegistration.Dynamic dispatcher = container.addServlet("appServlet", new DispatcherServlet(dispatcherServletContext));
		dispatcher.setLoadOnStartup(1);
		dispatcher.addMapping("/");
		dispatcher.addMapping("*.service");
1.2) Or, if you’re configuring DispatcherServlet by extending AbstractDispatcherServletInitializer or AbstractAnnotationConfigDispatcherServletInitializer
@Override
protected String[] getServletMappings() {
	return new String[] { "/", "*.service" };
}

2) Configure a URL handler in your Spring configuration to dispatch Hessian service URLs to the appropriate Hessian service bean.
- requests to /spitter.service will ultimately be handled by the hessianSpitterService bean (which is a proxy to SpitterServiceImpl).
@Bean
public HandlerMapping hessianMapping() {
	SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
	Properties mappings = new Properties();
	mappings.setProperty("/spitter.service", "hessianExportedSpitterService");
	mapping.setMappings(mappings);
	return mapping;
}

#EXPORTING A BURLAP SERVICE
- BurlapServiceExporter is virtually identical to HessianServiceExporter in every way, except that it uses an XML-based protocol instead of a binary protocol.
@Bean
public BurlapServiceExporter burlapExportedSpitterService(SpitterService service) {
	BurlapServiceExporter exporter = new BurlapServiceExporter();
	exporter.setService(service);
	exporter.setServiceInterface(SpitterService.class);
	return exporter;
}

- the only differences between this bean and its Hessian counterpart are the bean method and the exporter class. Configuring a Burlap service is otherwise the
same as configuring a Hessian service. This includes the need to set up a URL handler and a DispatcherServlet.

#Accessing Hessian/Burlap services
- That’s because the only difference between wiring the client side of an RMI-based service and wiring the client side of a Hessian-based service is that you’ll use Spring’s HessianProxyFactoryBean instead of RmiProxyFactoryBean.
@Bean
public HessianProxyFactoryBean spitterService() {
	HessianProxyFactoryBean proxy = new HessianProxyFactoryBean();
	proxy.setServiceUrl("http://localhost:8080/Spitter/spitter.service");
	proxy.setServiceInterface(SpitterService.class);
	return proxy;
}

- as with RmiProxyFactoryBean, serviceUrl indicates the URL of the service. Because Hessian is HTTP-based, it’s set to an HTTP URL here (determined in part by the URL mapping you defined earlier).
- HessianProxyFactoryBean and BurlapProxyFactoryBean produce proxy objects that talk to a remote service over HTTP (Hessian in binary, Burlap in XML).

- wiring a Burlap service into the client is equally uninteresting. The only difference is that you use BurlapProxyFactoryBean instead of HessianProxyFactoryBean:

@Bean
public BurlapProxyFactoryBean spitterService() {
	BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
	proxy.setServiceUrl("http://localhost:8080/Spitter/spitter.service");
	proxy.setServiceInterface(SpitterService.class);
	return proxy;
}

- Because both Hessian and Burlap are based on HTTP, they don’t suffer from the same firewall issues as RMI.
- But RMI has both Hessian and Burlap beat when it comes to serializing objects that are sent in RPC messages. Whereas Hessian and Burlap both use a proprietary serialization mechanism, RMI uses Java’s own serialization mechanism. If your data model is complex, the Hessian/Burlap serialization model may not be sufficient.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Using Spring’s HttpInvoker
总而言之 (Spring HttpInvoker) <Test> <Test Done>
1）Spring’s HTTP invoker offers RPC over HTTP (like Hessian/Burlap) while at the same time using Java serialization of objects (like RMI).
2) Create Service interface and ServiceImpl
3) Server side:
3.1) Exposing beans as HTTP services
@Autowired
SpittleService spittleService;

@Bean
public HttpInvokerServiceExporter httpExportedSpittleService(SpittleService spittleService) {
    HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
    exporter.setService(spittleService);
    exporter.setServiceInterface(SpittleService.class);
    return exporter;
}
3.2) set up a URL handler to map an HTTP URL to the service
@Bean
public HandlerMapping httpInvokerMapping() {
    SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
    Properties mappings = new Properties();
    mappings.setProperty("/spittle.service", "httpExportedSpittleService");
    mapping.setMappings(mappings);
    return mapping;
}
4) Client side:
4.1) HttpInvokerProxyFactoryBean is a proxy factory bean that produces a proxy for remoting with a Spring-specific HTTP-based protocol.
@Bean
public HttpInvokerProxyFactoryBean spittleService() {
    HttpInvokerProxyFactoryBean proxy = new HttpInvokerProxyFactoryBean();
    proxy.setServiceUrl("http://localhost:8080/spittle.service");
    proxy.setServiceInterface(SpittleService.class);
    return proxy;
}
5) 注意： <mvc:default-servlet-handler/>自己创建的SimpleUrlHandlerMapping导致后来我们自定义的SimpleUrlHandlerMapping失效(应该是没有引用), 出现404错误，正常情况下直接输入endpoint会出500错误。 xml config可以通过调换次序解决，java config整合defaultHandler和ExportedService到SimpleUrlHandlerMapping中解决:
@Bean
public DefaultServletHttpRequestHandler defaultServletHttpRequestHandler() {
    return new DefaultServletHttpRequestHandler();
}

@Bean
public HandlerMapping httpInvokerMapping() {
    SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
    Properties mappings = new Properties();
    mappings.setProperty("/spittle.service", "httpExportedSpittleService");
    mappings.setProperty("/**", "defaultServletHttpRequestHandler");
    mapping.setMappings(mappings);
    return mapping;
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Exposing beans as HTTP services

- Spring’s HTTP invoker offers RPC over HTTP (like Hessian/Burlap) while at the same time using Java serialization of objects (like RMI).

#Exposing beans as HTTP services
- To export a bean as an RMI service, you used RmiServiceExporter. 
- To export it as a Hessian service, you used HessianServiceExporter. 
- And to export it as a Burlap service, you used BurlapServiceExporter. 
- to export an HTTP invoker service, you’ll need to use HttpInvokerServiceExporter.

@Bean
public HttpInvokerServiceExporter httpExportedSpitterService(SpitterService service) {
	HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
	exporter.setService(service);
	exporter.setServiceInterface(SpitterService.class);
	return exporter;
}
- The only material difference is the class name: HttpInvokerServiceExporter.
- HttpInvokerServiceExporter works much like HessianServiceExporter and BurlapServiceExporter. It’s a Spring MVC controller that receives requests from a client through DispatcherServlet and translates those requests into method calls on the service implementation POJO.
- Because HttpInvokerServiceExporter is a Spring MVC controller, you need to set up a URL handler to map an HTTP URL to the service, just like with the Hessian and Burlap exporters:
@Bean
public HandlerMapping httpInvokerMapping() {
	SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
	Properties mappings = new Properties();
	mappings.setProperty("/spitter.service", "httpExportedSpitterService");
	mapping.setMappings(mappings);
	return mapping;
}	

#Accessing services via HTTP
- HttpInvokerProxyFactoryBean is a proxy factory bean that produces a proxy for remoting with a Spring-specific HTTP-based protocol.
@Bean
public HttpInvokerProxyFactoryBean spitterService() {
	HttpInvokerProxyFactoryBean proxy = new HttpInvokerProxyFactoryBean();
	proxy.setServiceUrl("http://localhost:8080/Spitter/spitter.service");
	proxy.setServiceInterface(SpitterService.class);
	return proxy;
}
- HttpInvoker has one significant limitation that you should keep in mind: it’s a remoting solution offered by the Spring Framework only.
- This means both the client and the service must be Spring-enabled applications. This also implies, at least for now, that both the client and the service must be Java-based. And because Java serialization is being used, both sides must have the same version of the classes as well as the same version of the Java runtime (much like RMI).
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#Publishing and consuming web services
总而言之 (Spring Web Services) <Test>
1) at the center of SOA is the idea that applications can and should be designed to lean on a common set of core services instead of reimplementing the same functionality for each application.
2) Spring supports publishing and consuming SOAP web services using the "Java API for XML Web Services" (JAX-WS)
3) Creating Spring-enabled JAX-WS endpoints:
3.1) Spring provides a JAX-WS service exporter, SimpleJaxWsServiceExporter.  but it may not be the best choice in all situations.
3.2) SimpleJaxWsServiceExporter requires that the JAX-WS runtime support publishing of endpoints to a specified address.
3.3) The JAX-WS runtime that ships with Sun’s JDK 1.6 is compatible with SimpleJaxWsServiceExporter, but other JAX-WS implementations including the reference implementation of JAX-WS may not.
3.4) If you’ll be deploying to a JAX-WS runtime that doesn’t support publishing to a specified address, you’ll have write your JAX-WS endpoints in a more conventional way.
4) AUTOWIRING JAX-WS ENDPOINTS IN SPRING 
4.1) In JAX-WS programming model, a class that’s annotated with @WebService is considered a web service endpoint, and its methods—annotated with @WebMethod—are the operations.
4.2) if the endpoint’s lifecycle is managed by the JAX-WS runtime and not by Spring, extending SpringBeanAutowiringSupport to wiring JAX-WS endpoints is 
@WebService(serviceName="SpitterService")
public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {		//Enable autowiring
	@Autowired
	SpitterService spitterService;						//Autowire SpitterService
	
	@WebMethod
	public void addSpittle(Spittle spittle) {			//Delegate to SpitterService
		spitterService.saveSpittle(spittle);
	}
	
	@WebMethod
	public void deleteSpittle(long spittleId) {			//Delegate to SpitterService
		spitterService.deleteSpittle(spittleId);
	}
	
	@WebMethod
	public List<Spittle> getRecentSpittles(int spittleCount) {			//Delegate to SpitterService
		return spitterService.getRecentSpittles(spittleCount);
	}
	
	@WebMethod
	public List<Spittle> getSpittlesForSpitter(Spitter spitter) {			//Delegate to SpitterService
		return spitterService.getSpittlesForSpitter(spitter);
	}
}
4.3) EXPORTING STANDALONE JAX-WS ENDPOINTS
- But under the right circumstances, it’s possible to export a Spring-managed bean as a JAX-WS endpoint.
- Spring’s SimpleJaxWsServiceExporter publishes all beans annotated with JAX-WS annotations as service endpoints in a JAX-WS runtime.
@Bean
public SimpleJaxWsServiceExporter jaxWsExporter() {
	return new SimpleJaxWsServiceExporter();
}
- Because SimpleJaxWsServiceEndpoint’s base address defaults to http://localhost:8080/, and SpitterServiceEndpoint is annotated with @Web-
Service (serviceName="SpitterService"), the matchup of these two beans results in a web service at http://localhost:8080/SpitterService.
- you can set the base address to something else:
@Bean
public SimpleJaxWsServiceExporter jaxWsExporter() {
	SimpleJaxWsServiceExporter exporter = new SimpleJaxWsServiceExporter();
	exporter.setBaseAddress("http://localhost:8888/services/");
}
4.4) Client side:
@Bean
public JaxWsPortProxyFactoryBean spitterService() {
	JaxWsPortProxyFactoryBean proxy = new JaxWsPortProxyFactoryBean();
	proxy.setWsdlDocument("http://localhost:8080/services/SpitterService?wsdl");
	proxy.setServiceName("spitterService");
	proxy.setPortName("spitterServiceHttpPort");
	proxy.setServiceInterface(SpitterService.class);
	proxy.setNamespaceUri("http://spitter.com");
	return proxy;
}
- The wsdlDocumentUrl property identifies the location of the remote web service’s definition file. 
- JaxWsPortProxyFactoryBean will use the WSDL available at that URL to construct a proxy to the service.
- The proxy that’s produced by JaxWsPortProxyFactoryBean will implement the SpitterService interface, as specified by the serviceInterface property.
- You can usually determine the values for the remaining three properties by looking at the service’s WSDL
<wsdl:definitions targetNamespace="http://spitter.com">
	...
	<wsdl:service name="spitterService">
		<wsdl:port name="spitterServiceHttpPort" binding="tns:spitterServiceHttpBinding">
			...
		</wsdl:port>
	</wsdl:service>
</wsdl:definitions>
- the namespaceUri property specifies the namespace of the service. the namespace helps JaxWsPortProxyFactoryBean locate the service definition in the WSDL.
- port and service names is in the <wsdl:port> and <wsdl:service> elements, usually available in the targetNamespace attribute of the <wsdl:definitions> element.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- SOA means many things to different people. But at the center of SOA is the idea that applications can and should be designed to lean on a common set
of core services instead of reimplementing the same functionality for each application.
- Spring comes with some capable support for publishing and consuming SOAP web services using the "Java API for XML Web Services" (JAX-WS)

#Creating Spring-enabled JAX-WS endpoints
- you probably expect me to show you how to create web services using a JAX-WS service exporter in this section.
- Spring does provide a JAX-WS service exporter, SimpleJaxWsServiceExporter, and you’ll see it soon enough. But before you get there, you should know that it may not be the best choice in all situations.
- SimpleJaxWsServiceExporter requires that the JAX-WS runtime support publishing of endpoints to a specified address. The JAX-WS runtime that ships with Sun’s JDK 1.6 fits the bill, but other JAX-WS implementations, including the reference implementation of JAX-WS, may not.
- If you’ll be deploying to a JAX-WS runtime that doesn’t support publishing to a specified address, you’ll have write your JAX-WS endpoints in a more conventional way. That means the lifecycle of the endpoints will be managed by the JAX-WS runtime and not by Spring.

#AUTOWIRING JAX-WS ENDPOINTS IN SPRING
- The JAX-WS programming model involves using annotations to declare a class and its methods as web service operations.
- A class that’s annotated with @WebService is considered a web service endpoint, and its methods—annotated with @WebMethod—are the operations.
- The secret to wiring JAX-WS endpoints is to extend SpringBeanAutowiringSupport.
@WebService(serviceName="SpitterService")
public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {		//Enable autowiring
	@Autowired
	SpitterService spitterService;						//Autowire SpitterService
	
	@WebMethod
	public void addSpittle(Spittle spittle) {			//Delegate to SpitterService
		spitterService.saveSpittle(spittle);
	}
	
	@WebMethod
	public void deleteSpittle(long spittleId) {			//Delegate to SpitterService
		spitterService.deleteSpittle(spittleId);
	}
	
	@WebMethod
	public List<Spittle> getRecentSpittles(int spittleCount) {			//Delegate to SpitterService
		return spitterService.getRecentSpittles(spittleCount);
	}
	
	@WebMethod
	public List<Spittle> getSpittlesForSpitter(Spitter spitter) {			//Delegate to SpitterService
		return spitterService.getSpittlesForSpitter(spitter);
	}
}

- Spring’s SimpleJaxWsServiceExporter works much like the other service exporters that you saw earlier in this chapter, in that it publishes Spring-managed beans as service endpoints in a JAX-WS runtime.
@Bean
public SimpleJaxWsServiceExporter jaxWsExporter() {
	return new SimpleJaxWsServiceExporter();
}

- When it gets started, it digs through the Spring application context looking for beans that are annotated with @WebService. When it finds one, it publishes the bean as a JAX-WS endpoint with a base address of http://localhost:8080/.
- SimpleJaxWsServiceExporter turns beans into JAX-WS endpoints:
@Component
@WebService(serviceName="SpitterService")
public class SpitterServiceEndpoint {
	@Autowired
	SpitterService spitterService;
	
	@WebMethod
	public void addSpittle(Spittle spittle) {
		spitterService.saveSpittle(spittle);
	}
	
	@WebMethod
	public void deleteSpittle(long spittleId) {
		spitterService.deleteSpittle(spittleId);
	}
	
	@WebMethod
	public List<Spittle> getRecentSpittles(int spittleCount) {
		return spitterService.getRecentSpittles(spittleCount);
	}
	
	@WebMethod
	public List<Spittle> getSpittlesForSpitter(Spitter spitter) {
		return spitterService.getSpittlesForSpitter(spitter);
	}
}

- this new implementation of SpitterServiceEndpoint no longer extends SpringBeanAutowiringSupport. As a full-fledged Spring bean, it qualifies for autowiring
without extending a special support class.
- SimpleJaxWsServiceEndpoint’s base address defaults to http://localhost:8080/, and because SpitterServiceEndpoint is annotated with @WebService (serviceName="SpitterService"), the matchup of these two beans results in a web service at http://localhost:8080/SpitterService.

- you can set the base address to something else.
@Bean
public SimpleJaxWsServiceExporter jaxWsExporter() {
	SimpleJaxWsServiceExporter exporter = new SimpleJaxWsServiceExporter();
	exporter.setBaseAddress("http://localhost:8888/services/");
}

- As simple as SimpleJaxWsServiceEndpoint seems, you should be aware that it only works with a JAX-WS runtime that supports publication of endpoints with an address. That includes the JAX-WS runtime that comes with Sun’s 1.6 JDK.
- Other JAX-WS runtimes, such as the JAX-WS 2.1 reference implementation, don’t support this type of endpoint publication and thus can’t be used with SimpleJaxWsServiceEndpoint.

#Proxying JAX-WS services on the client side
- Using JaxWsPortProxyFactoryBean, you can wire the Spitter web service in Spring as if it were any other bean.
- JaxWsPortProxyFactoryBean is a Spring FactoryBean that produces a proxy that knows how to talk to a SOAP web service.
- The proxy is created to implement the service’s interface. Consequently, JaxWsPortProxyFactoryBean makes it possible to wire and use a remote web service as if it were any other local POJO.
- JaxWsPortProxyFactoryBean produces proxies that talk to remote web services. These proxies can then be wired into other beans as if they were local POJOs.

@Bean
public JaxWsPortProxyFactoryBean spitterService() {
	JaxWsPortProxyFactoryBean proxy = new JaxWsPortProxyFactoryBean();
	proxy.setWsdlDocument("http://localhost:8080/services/SpitterService?wsdl");
	proxy.setServiceName("spitterService");
	proxy.setPortName("spitterServiceHttpPort");
	proxy.setServiceInterface(SpitterService.class);
	proxy.setNamespaceUri("http://spitter.com");
	return proxy;
}

- The wsdlDocumentUrl property identifies the location of the remote web service’s definition file. 
- JaxWsPortProxyFactoryBean will use the WSDL available at that URL to construct a proxy to the service.
- The proxy that’s produced by JaxWsPortProxyFactoryBean will implement the SpitterService interface, as specified by the serviceInterface property.
- You can usually determine the values for the remaining three properties by looking at the service’s WSDL.
<wsdl:definitions targetNamespace="http://spitter.com">
	...
	<wsdl:service name="spitterService">
		<wsdl:port name="spitterServiceHttpPort" binding="tns:spitterServiceHttpBinding">
		...
		</wsdl:port>
	</wsdl:service>
</wsdl:definitions>


- On the client side, Spring provides proxy factory beans that enable you to configure remote services in your Spring application. Regardless of whether you’re using RMI, Hessian, Burlap, Spring’s own HTTP invoker, or web services for remoting, you can wire remote services into your application as if they were POJOs.
- Spring even catches any RemoteExceptions that are thrown and rethrows runtime RemoteAccessExceptions in their place, freeing your code from having to deal with an exception that it probably can’t recover from.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 17 Messaging in Spring
总而言之 (messaging model)
1）Asynchronous messaging is a way of "indirectly" sending messages from one application to another "without waiting" for a response.
2）Spring supports message-driven POJOs(MDP): a way to receive messages that resembles EJB’s message-driven beans (MDBs).
3) message brokers and destinations: 
3.1) When an application sends a message, it hands it off to a message broker. A message broker is analogous to the post office. The message broker ensures that the message is delivered to the specified destination, leaving the sender free to go about other business. 
3.2) asynchronous message are addressed with a destination. Destinations are like mailboxes where the messages are placed until someone comes to pick them up.
6) two types of destination: queues and topics. 
7) Each of these is associated with a specific messaging model: either point-to-point (for queues) or publish/subscribe (for topics).
8) POINT-TO-POINT MESSAGING: 
8.1) each message has exactly one sender and one receiver
8.2) A message queue decouples a message sender from the message receiver. Although a queue may have several receivers, each message is picked up by exactly one receiver.
8.3) Because the message is removed from the queue as it’s delivered, it’s guaranteed that the message will be delivered to only one receiver.
9) PUBLISH-SUBSCRIBE MESSAGING:
9.1) Unlike queues, a topic message may be delivered to many topic subscribers.
9.2) In the publish/subscribe messaging model, messages are sent to a topic. As with queues, many receivers may be listening to a topic.
9.3) But unlike with queues, where a message is delivered to exactly one receiver, all subscribers to a topic receive a copy of the message
10) benefits of asynchronous messaging: no waiting/decouple from the interface of the service/decouple from the location of the service/decouple from availability of the service/guranteed delivery, service implementation flexibility/service clustering
11) disavantage: additional components(message brokers) to develop and maintiain, time sequence of messages

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- RMI, Hessian, Burlap, the HTTP invoker, and web services to enable communication between applications. All of these communication mechanisms employ synchronous communication in which a client application directly contacts a remote service and waits for the remote procedure to complete before continuing.
- Asynchronous messaging is a way of indirectly sending messages from one application to another without waiting for a response.
- send and receive messages in Spring using both the Java Message Service (JMS) and the Advanced Message Queuing Protocol (AMQP).
- Spring’s support for messagedriven POJOs: a way to receive messages that resembles EJB’s message-driven beans (MDBs).

#A brief introduction to asynchronous messaging
Synchronious - When communicating synchronously, the client must wait for the operation to complete.
Asynchronious - Asynchronous communication is a no-wait form of communication.

#Sending messages
- indirection is the key to asynchronous messaging. When one application sends a message to another, there’s no direct link between the two applications.
- the sending application places the message in the hands of a service that will ensure delivery to the receiving application.
- There are two main actors in asynchronous messaging: message brokers and destinations. 
- When an application sends a message, it hands it off to a message broker. A message broker is analogous to the post office. The message broker ensures that the message is delivered to the specified destination, leaving the sender free to go about other business.
- asynchronous message are addressed with a destination. Destinations are like mailboxes where the messages are placed until someone comes to pick them up.
- Destinations are only concerned about where messages will be picked up—not who will pick them up. In this way, a destination is like sending a letter addressed “To current resident.”

- two common types of destinations: 
- Each of these is associated with a specific messaging model: either point-to-point (for queues) or publish/subscribe (for topics).

#POINT-TO-POINT MESSAGING
- In the point-to-point model, each message has exactly one sender and one receiver
- When the message broker is given a message, it places the message in a queue. 
- When a receiver comes along and asks for the next message in the queue, the message is pulled from the queue and delivered to the receiver.
- Because the message is removed from the queue as it’s delivered, it’s guaranteed that the message will be delivered to only one receiver.
- Although each message in a message queue is delivered to only one receiver, this doesn’t imply that only one receiver is pulling messages from the queue. 
- It’s likely that several receivers are processing messages from the queue. But they’ll each be given their own messages to process.
- Likewise, with point-to-point messaging, if multiple receivers are listening to a queue, there’s no way of knowing which one will process a specific message. This uncertainty is a good thing, because it enables an application to scale up message processing by adding another listener to the queue.
- A message queue decouples a message sender from the message receiver. Although a queue may have several receivers, each message is picked up by exactly one receiver.

#PUBLISH-SUBSCRIBE MESSAGING
- Like queues, topics decouple message senders from message receivers. Unlike queues, a topic message may be delivered to many topic subscribers.
- In the publish/subscribe messaging model, messages are sent to a topic. As with queues, many receivers may be listening to a topic.
- But unlike with queues, where a message is delivered to exactly one receiver, all subscribers to a topic receive a copy of the message,
- the publish/subscribe message model is much like the model of a magazine publisher and its subscribers. The magazine (a message) is published and sent to the postal service, and all subscribers receive their own copy.
- The publisher only knows that its message will be published to a particular topic—not who’s listening to that topic. This also implies that the publisher has no idea how the message will be processed.

#Assessing the benefits of asynchronous messaging
- Synchronous communication implies waiting: When a client invokes a method on a remote service, the client must wait for the remote method to complete before
continuing. If the client communicates frequently with the remote service or the remote service is slow to respond, this could negatively impact performance
of the client application.
- The client is coupled to the service through the service’s interface: If the interface of the service changes, all of the service’s clients will need to change accordingly.
- The client is coupled to the service’s location: A client must be configured with the service’s network location so that it knows how to contact the service. If the network topology changes, the client will need to be reconfigured with the new location.
- The client is coupled to the service’s availability. If the service becomes unavailable, the client is effectively crippled.

NO WAITING: When a message is sent asynchronously, the client doesn’t need to wait for it to be processed or delivered. The client drops off the message with the message broker and moves along, confident that the message will make it to the appropriate destination. Because it doesn’t have to wait, the client is freed up to perform other activities. With all this free time, the client’s performance can be dramatically improved. 

MESSAGE ORIENTATION AND DECOUPLING: Unlike RPC communication, which is typically oriented around a method call, messages sent asynchronously are data-centric. This means the client isn’t fixed to a specific method signature. Any queue or topic subscriber that can process the data sent by the client can process the message. The client doesn’t need to be aware of any service specifics.

LOCATION INDEPENDENCE: messaging clients have no idea what service will process their messages or where the service is located. The client only knows the queue or topic through which the messages will be sent. As a result, it doesn’t matter where the service is located, as long as it can retrieve messages from the queue or topic.
- In the point-to-point model, it’s possible to take advantage of location independence to create a cluster of services.
- multiple services can be configured to pull messages from the same queue. If the service is overburdened and falling behind in its processing, all you
need to do is start a few more instances of the service to listen to the same queue.
- Location independence takes on another interesting side effect in the publish/subscribe model. Multiple services could all subscribe to a single topic, receiving duplicate copies of the same message. But each service could process that message differently.

GUARANTEED DELIVERY: 
- In order for a client to communicate with a synchronous service, the service must be listening at the IP address and port specified. If the service were to go down or otherwise become unavailable, the client wouldn’t be able to proceed.
- But when sending messages asynchronously, the client can rest assured that its messages will be delivered. Even if the service is unavailable when a message is sent, the message will be stored until the service is available again.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

总而言之 (configure JMS broker and destination)
1）The Java Message Service (JMS) is a Java standard that defines a common API for working with message brokers.
2）JMS standardize proprietary API of different message broker via a common interface in much the same way that JDBC does to database
3) Spring supports JMS through a template-based abstraction known as JmsTemplate and message-driven POJOs
3.1) JmsTemplate makes it easy to send messages across queues and topics from the producer side and to receive those messages on the consumer side.
3.2) message-driven POJOs is simple Java objects that react to messages arriving on a queue or topic in an asynchronous fashion
4) Setting up a message broker in Spring: 
4.1) ActiveMQ is a great open source message broker, downloaded ActiveMQ, unzip it to your local hard drive. 
4.2) In the lib directory of the unzipped distribution, you’ll find activemq-core-5.9.1.jar. This is the JAR file you’ll need to add to the application’s classpath to be able to use ActiveMQ’s API.
4.3) Under the bin directory, you’ll find subdirectories for various operating systems. In those, you’ll find scripts that you can use to start ActiveMQ.
5) CREATING A CONNECTION FACTORY, By default, ActiveMQ broker is listening at port 61616 on localhost.
<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory" />
<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory" p:brokerURL="tcp://localhost:61616"/>
6) DECLARING AN ACTIVEMQ MESSAGE DESTINATION
- In addition to a connection factory, you need a destination for the messages to be passed to. The destination can be either a queue or a topic, depending on the needs of the application. 
- In either case, the constructor is given the name of the queue, as it’s known to the message broker—spitter.topic in this case.
<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue" c:_="spitter.queue" />
<bean id="topic" class="org.apache.activemq.command.ActiveMQTopic" c:_="spitter.queue" />
7) Using amq namesapce:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jms="http://www.springframework.org/schema/jms"
	xmlns:amq="http://activemq.apache.org/schema/core"
	xsi:schemaLocation="http://activemq.apache.org/schema/core
	http://activemq.apache.org/schema/core/activemq-core.xsd
	http://www.springframework.org/schema/jms
	http://www.springframework.org/schema/jms/spring-jms.xsd
	http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd">
		
	<amq:connectionFactory id="connectionFactory" brokerURL="tcp://localhost:61616"/>
	<amq:queue id="spittleQueue" physicalName="spittle.alert.queue" />				//the physicalName attribute sets the name of the message channel.
	<amq:topic id="spittleTopic" physicalName="spittle.alert.topic" />
</beans>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Sending messages with JMS
- The Java Message Service (JMS) is a Java standard that defines a common API for working with message brokers.
- Before JMS, each message broker had a proprietary API, making an application’s messaging code less portable between brokers. 
- But with JMS, all compliant implementations can be worked with via a common interface in much the same way that JDBC has given database operations a common interface.
- Spring supports JMS through a template-based abstraction known as JmsTemplate. Using JmsTemplate, it’s easy to send messages across queues and topics from the producer side and also to receive those messages on the consumer side.
- Spring also supports the notion of message-driven POJOs: simple Java objects that react to messages arriving on a queue or topic in an asynchronous fashion.
- before you can send and receive messages, you need a message broker ready to relay those messages between producers and consumers.

#Setting up a message broker in Spring
- ActiveMQ is a great open source message broker and a wonderful option for asynchronous messaging with JMS.
- downloaded ActiveMQ, unzip it to your local hard drive. In the lib directory of the unzipped distribution, you’ll find activemq-core-5.9.1.jar. This is the JAR file you’ll need to add to the application’s classpath to be able to use ActiveMQ’s API.
- Under the bin directory, you’ll find subdirectories for various operating systems. In those, you’ll find scripts that you can use to start ActiveMQ.

#CREATING A CONNECTION FACTORY
- you’ll need a JMS connection factory to be able to send messages through the message broker. 
<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory" />
- By default, ActiveMQConnectionFactory assumes that the ActiveMQ broker is listening at port 61616 on localhost. you can specify the broker URL with the brokerURL property:
-<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory" p:brokerURL="tcp://localhost:61616"/>
- Optionally, because you know you’re dealing with ActiveMQ, you can use ActiveMQ’s own Spring configuration namespace:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jms="http://www.springframework.org/schema/jms"
	xmlns:amq="http://activemq.apache.org/schema/core"
	xsi:schemaLocation="http://activemq.apache.org/schema/core
	http://activemq.apache.org/schema/core/activemq-core.xsd
	http://www.springframework.org/schema/jms
	http://www.springframework.org/schema/jms/spring-jms.xsd
	http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd">
	...
</beans>

- Then you can use the <amq:connectionFactory> element to declare the connection factory:
<amq:connectionFactory id="connectionFactory" brokerURL="tcp://localhost:61616"/>

#DECLARING AN ACTIVEMQ MESSAGE DESTINATION
- In addition to a connection factory, you need a destination for the messages to be passed to. The destination can be either a queue or a topic, depending on the needs of the application.
- Regardless of whether you’re using a queue or a topic, you must configure the destination bean in Spring using a message broker–specific implementation class.
<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue" c:_="spitter.queue" />
<bean id="topic" class="org.apache.activemq.command.ActiveMQTopic" c:_="spitter.queue" />
- In either case, the constructor is given the name of the queue, as it’s known to the message broker—spitter.topic in this case.

- As with the connection factory, the ActiveMQ namespace offers an alternative way to declare queues and topics.
<amq:queue id="spittleQueue" physicalName="spittle.alert.queue" />
<amq:topic id="spittleTopic" physicalName="spittle.alert.topic" />
- the physicalName attribute sets the name of the message channel.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

总而言之
1）unlike conventional (non-Spring) JMS, JmsTemplate takes care of creating a connection, obtaining a session, and ultimately sending or receiving messages. This leaves you to focus your development efforts on constructing the message to send or processing messages that are received.
2) JmsTemplate can handle any clumsy JMSException that may be thrown along the way. If a JMSException is thrown in the course of working with JmsTemplate, JmsTemplate will catch it and rethrow it as one of the unchecked subclasses of Spring’s own JmsException.
3) declare it as a bean in the Spring configuration file.
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" />
Because JmsTemplate needs to know how to get connections to the message broker, you must set the connectionFactory property with a reference to the bean that implements JMS’s ConnectionFactory interface.
4) use jmsTemplate to send message: <Test> <Test Done>
4.1) To support sending spittle alerts asynchronously with the creation of spittles, let’s introduce AlertService to the Spittr application:
public interface AlertService {
	void sendSpittleAlert(Spittle spittle);
}
4.2) AlertServiceImpl is an implementation of the AlertService interface that uses an injected JmsOperations (the interface that JmsTemplate implements) to send Spittle objects to a message queue to be processed at some later time.
public class AlertServiceImpl implements AlertService {
	
	private JmsOperations jmsOperations;
	
	@Autowired
	public AlertServiceImpl(JmsOperations jmsOperatons) {			//Inject JMS template
		this.jmsOperations = jmsOperations;
	}
	
	public void sendSpittleAlert(final Spittle spittle) {
		jmsOperations.send("spittle.alert.queue", new MessageCreator() {			//Send message //Specify destination
			public Message createMessage(Session session) throws JMSException {
					return session.createObjectMessage(spittle);					//Create message
			}
		}
		);
	}
}
- The first parameter to JmsOperations’ send() method is the name of the JMS destination to which the message will be sent.
- When the send() method is called, JmsTemplate deals with obtaining a JMS connection and session and sends the message on behalf of the sender
- The message is constructed using a MessageCreator, implemented here as an anonymous inner class. In MessageCreator’s createMessage() method, you ask for an
object message from the session, giving it the Spittle object from which to build the object message.

5) set default destination <Test> <Test Done>
5.1) in the case of AlertServiceImpl, you’ll always be sending the spittle message to the same destination, you can wire a default destination into JmsTemplate:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestinationName="spittle.alert.queue" />
5.2) or you can instead wire in a reference to a queue or destination bean that you declared earlier:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestination-ref="spittleTopic" />
5.3) Now the call to JmsOperations’ send() method can be simplified slightly by removing the first parameter:
jmsOperations.send(new MessageCreator() {
	...
	}
);

6)CONVERTING MESSAGES WHEN SENDING <Test> <Test Failed>
6.1) In addition to the send() method, JmsTemplate offers convertAndSend().
public void sendSpittleAlert(Spittle spittle) {
	jmsOperations.convertAndSend(spittle);
}
6.2) spring uses an implementation of MessageConverter to converting objects to Messages.
public interface MessageConverter {
	Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;
	Object fromMessage(Message message) throws JMSException, MessageConversionException;
}
MappingJacksonMessageConverter/MappingJackson2MessageConverter/MarshallingMessageConverter/SimpleMessageConverter
6.3) if you want to work with JSON messages, you can declare a MappingJacksonMessageConverter bean: <Test> <Test Failed>
<bean id="messageConverter" class="org.springframework.jms.support.converter.MappingJacksonMessageConverter" />
- Then you can wire it into JmsTemplate like this:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestinationName="spittle.alert.queue"
	p:messageConverter-ref="messageConverter" />
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Using Spring’s JMS template
- JMS gives Java developers a standard API for interacting with message brokers and for sending and receiving messages. virtually every message broker implementation supports JMS. So there’s no reason to learn a proprietary messaging API for every message broker you deal with.

#TACKLING RUNAWAY JMS CODE
- Sending a message using conventional (non-Spring) JMS
ConnectionFactory cf = new ActiveMQConnectionFactory("tcp://localhost:61616");
Connection conn = null;
Session session = null;
try {
	conn = cf.createConnection();
	session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
	Destination destination = new ActiveMQQueue("spitter.queue");
	MessageProducer producer = session.createProducer(destination);
	TextMessage message = session.createTextMessage();
	message.setText("Hello world!");
	producer.send(message);			//send message
	
	} catch (JMSException e) {
		// handle exception?
	} finally {
		try {
			if (session != null) {
				session.close();
			}
			if (conn != null) {
				conn.close();
			}
		} catch (JMSException ex) {
	}
}

- Receiving a message using conventional (non-Spring) JMS
ConnectionFactory cf = new ActiveMQConnectionFactory("tcp://localhost:61616");
Connection conn = null;
Session session = null;
try {
	conn = cf.createConnection();
	conn.start();
	session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
	Destination destination = new ActiveMQQueue("spitter.queue");
	MessageConsumer consumer = session.createConsumer(destination);
	Message message = consumer.receive();
	TextMessage textMessage = (TextMessage) message;
	System.out.println("GOT A MESSAGE: " + textMessage.getText());
	conn.start();
	
	} catch (JMSException e) {
		// handle exception?
	} finally {
		try {
		if (session != null) {
			session.close();
		}
		if (conn != null) {
			conn.close();
		}
		} catch (JMSException ex) {
		}
}

#WORKING WITH JMS TEMPLATES
- JmsTemplate takes care of creating a connection, obtaining a session, and ultimately sending or receiving messages. This leaves you to focus your development efforts on constructing the message to send or processing messages that are received.
- JmsTemplate can handle any clumsy JMSException that may be thrown along the way. If a JMSException is thrown in the course of working with JmsTemplate, JmsTemplate will catch it and rethrow it as one of the unchecked subclasses of Spring’s own JmsException.
DestinationResolutionException: Spring-specific—thrown when Spring can’t resolve a destination name
IllegalStateException: IllegalStateException
InvalidClientIDException: InvalidClientIDException
InvalidDestinationException: InvalidDestinationException
InvalidSelectorException: InvalidSelectorException
JmsSecurityException: JmsSecurityException
ListenerExecutionFailedException: Spring-specific—thrown when execution of a listener method fails
MessageConversionException: Spring-specific—thrown when message conversion fails
MessageEOFException: MessageEOFException
MessageFormatException: MessageFormatException
MessageNotReadableException: MessageNotReadableException
MessageNotWriteableException: MessageNotWriteableException
ResourceAllocationException: ResourceAllocationException
SynchedLocalTransactionFailedException: Spring-specific—thrown when a synchronized local transaction fails to complete
TransactionInProgressException: TransactionInProgressException
TransactionRolledBackException: TransactionRolledBackException
UncategorizedJmsException: Spring-specific—thrown when no other exception applies

- JMSException does come with a rich and descriptive set of subclasses that give you a better sense of what went wrong. Nevertheless, all these subclasses
of JMSException are checked exceptions and thus must be caught. JmsTemplate attends to that for you by catching each exception and rethrowing an appropriate
unchecked subclass of JmsException. 
- To use JmsTemplate, you’ll need to declare it as a bean in the Spring configuration file.
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" />

- Because JmsTemplate needs to know how to get connections to the message broker, you must set the connectionFactory property with a reference to the bean that implements JMS’s ConnectionFactory interface.

#SENDING MESSAGES
- To support sending spittle alerts asynchronously with the creation of spittles, let’s introduce AlertService to the Spittr application:
public interface AlertService {
	void sendSpittleAlert(Spittle spittle);
}

- AlertServiceImpl is an implementation of the AlertService interface that uses an injected JmsOperations (the interface that JmsTemplate implements) to send Spittle objects to a message queue to be processed at some later time.
public class AlertServiceImpl implements AlertService {
	private JmsOperations jmsOperations;
	@Autowired
	public AlertServiceImpl(JmsOperations jmsOperatons) {			//Inject JMS template
		this.jmsOperations = jmsOperations;
	}
	public void sendSpittleAlert(final Spittle spittle) {
		jmsOperations.send("spittle.alert.queue", new MessageCreator() {			//Send message //Specify destination
			public Message createMessage(Session session) throws JMSException {
					return session.createObjectMessage(spittle);					//Create message
			}
		}
		);
	}
}

- The first parameter to JmsOperations’ send() method is the name of the JMS destination to which the message will be sent.
- When the send() method is called, JmsTemplate deals with obtaining a JMS connection and session and sends the message on behalf of the sender
- The message is constructed using a MessageCreator, implemented here as an anonymous inner class. In MessageCreator’s createMessage() method, you ask for an
object message from the session, giving it the Spittle object from which to build the object message.

#SETTING A DEFAULT DESTINATION
- In above listing, you explicitly specify a destination where the spittle message should be sent in the send() method. That form of send() comes in handy when you want to programmatically choose a destination.
- But in the case of AlertServiceImpl, you’ll always be sending the spittle message to the same destination, Instead of explicitly specifying a destination each time you send a message, you can opt for wiring a default destination into JmsTemplate:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestinationName="spittle.alert.queue" />
- Here you set the destination name to spittle.alert.queue. But that’s only a name: it doesn’t say what kind of destination you’re dealing with. If an existing queue or topic exists with that name, it will be used. If not, then a new destination (usually a queue) will be created.
- But if you want to be specific about what type of destination to create, you can instead wire in a reference to a queue or destination bean that you declared earlier:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestination-ref="spittleTopic" />

- Now the call to JmsOperations’ send() method can be simplified slightly by removing the first parameter:
jmsOperations.send(new MessageCreator() {
	...
	}
);

#CONVERTING MESSAGES WHEN SENDING
- In addition to the send() method, JmsTemplate offers convertAndSend(). Unlike send(), the convertAndSend() method doesn’t take a MessageCreator as an argument. That’s because convertAndSend() uses a built-in message converter to create the message for you.
public void sendSpittleAlert(Spittle spittle) {
	jmsOperations.convertAndSend(spittle);
}
- spring uses an implementation of MessageConverter to converting objects to Messages.

public interface MessageConverter {
	Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;
	Object fromMessage(Message message) throws JMSException, MessageConversionException;
}

- Spring offers several message converters for common conversion tasks. (All of these message converters are in the org.springframework.jms.support.converter package.)
MappingJacksonMessageConverter - Uses the Jackson JSON library to convert messages to and from JSON
MappingJackson2MessageConverter - Uses the Jackson 2 JSON library to convert messages to and from JSON
MarshallingMessageConverter - Uses JAXB to convert messages to and from XML
SimpleMessageConverter - Converts Strings to/from TextMessage, byte arrays to/from BytesMessage, Maps to/from MapMessage, and Serializable objects to/from ObjectMessage

- By default, JmsTemplate uses a SimpleMessageConverter when sending messages in convertAndSend(). But you can override that by declaring the message converter as a bean and injecting it into JmsTemplate’s messageConverter property.
- if you want to work with JSON messages, you can declare a MappingJacksonMessageConverter bean:
<bean id="messageConverter" class="org.springframework.jms.support.converter.MappingJacksonMessageConverter" />

Then you can wire it into JmsTemplate like this:
<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestinationName="spittle.alert.queue"
	p:messageConverter-ref="messageConverter" />

- The various message converters may have additional configuration for finer-grained control of the conversion process. MappingJacksonMessageConverter, for instance, allows you to configure things such as encoding and a custom Jackson ObjectMapper.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
总而言之 jms consumer
1) call JmsOperations’ receive() method to consume a message: <Test> <Test Done>
public Spittle receiveSpittleAlert() {
	try {
		ObjectMessage receivedMessage = (ObjectMessage) jmsOperations.receive("spittle.alert.queue");	//Receive message
		return (Spittle) receivedMessage.getObject();													//Get object
		} catch (JMSException jmsException) {
			throw JmsUtils.convertJmsAccessException(jmsException);										//Throw converted exception
		}
}
2) receive and convert: <Test> <Test Done>
public Spittle retrieveSpittleAlert() {
	return (Spittle) jmsOperations.receiveAndConvert();
}
3) The big downside of consuming messages with JmsTemplate is that both the receive() and receiveAndConvert() methods are synchronous.  This means the receiver must wait patiently for the message to arrive, because those methods will block until a message is available (or until a timeout condition occurs).
4) Message-driven POJOs(MDP), CREATING A MESSAGE LISTENER
public class SpittleAlertHandler {
	public void handleSpittleAlert(Spittle spittle) {
		// ... implementation goes here...
	}
}

5) CONFIGURING MESSAGE LISTENERS, empowering a POJO with message-receiving abilities by configuring it as a message listener in Spring. 
- Spring’s jms namespace provides everything you need to do that. 
5.1) First, declare the handler as a <bean>:
<bean id="spittleHandler" class="com.habuma.spittr.alerts.SpittleAlertHandler" />
5.2) Then, to turn SpittleAlertHandler into a message-driven POJO, you can declare the bean to be a message listener:
<jms:listener-container connection-factory="connectionFactory">
	<jms:listener destination="spitter.alert.queue" ref="spittleHandler" method="handleSpittleAlert" />
</jms:listener-container>
5.3) A message-listener container is a special bean that watches a JMS destination, waiting for a message to arrive. Once a message arrives, the bean retrieves the message and passes it on to any message listeners that are interested.
- The <jms:listener> element is used to identify a bean and a method that should handle incoming messages.

5.4) above config doesn't work. please see following working config: <Test> <Test Done>
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="spittr.messaging.jms.alerts.SpittleAlertHandler"/>
    </constructor-arg>
    <property name="defaultListenerMethod" value="handleSpittleAlert"/>
</bean>

<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="spittleTopic"/>
    <property name="messageListener" ref="messageListener" />
</bean>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#CONSUMING MESSAGES
- In SpittleAlertServiceImpl call JmsOperations’ receive() method to consume a message:
public Spittle receiveSpittleAlert() {
	try {
		ObjectMessage receivedMessage = (ObjectMessage) jmsOperations.receive();	//Receive message
		return (Spittle) receivedMessage.getObject();								//Get object
		} catch (JMSException jmsException) {
			throw JmsUtils.convertJmsAccessException(jmsException);					//Throw converted exception
		}
}

- When the JmsOperations’ receive() method is called, it attempts to retrieve a message from the message broker. If no message is available, receive() waits until a message becomes available.
- take advantage of a message converter:
public Spittle retrieveSpittleAlert() {
	return (Spittle) jmsOperations.receiveAndConvert();
}

- The big downside of consuming messages with JmsTemplate is that both the receive() and receiveAndConvert() methods are synchronous. 
- This means the receiver must wait patiently for the message to arrive, because those methods will block until a message is available (or until a timeout condition occurs).

#Creating message-driven POJOs
- receive messages asynchronously using components that react to messages rather than wait on them.
#CREATING A MESSAGE LISTENER
public class SpittleAlertHandler {
	public void handleSpittleAlert(Spittle spittle) {
		// ... implementation goes here...
	}
}

#CONFIGURING MESSAGE LISTENERS
- The trick to empowering a POJO with message-receiving abilities is to configure it as a message listener in Spring.
- Spring’s jms namespace provides everything you need to do that. First, you must declare the handler as a <bean>:
<bean id="spittleHandler" class="com.habuma.spittr.alerts.SpittleAlertHandler" />
- Then, to turn SpittleAlertHandler into a message-driven POJO, you can declare the bean to be a message listener:
<jms:listener-container connection-factory="connectionFactory">
	<jms:listener destination="spitter.alert.queue" ref="spittleHandler" method="handleSpittleAlert" />
</jms:listener-container>

- Here you have a message listener that’s contained in a message-listener container. A message-listener container is a special bean that watches a JMS destination, waiting for a message to arrive. Once a message arrives, the bean retrieves the message and passes it on to any message listeners that are interested.
- The <jms:listener> element is used to identify a bean and a method that should handle incoming messages.
- if the bean identified by the ref attribute implements MessageListener, then there’s no need to specify the method attribute. The onMessage() will be called by default.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
总而言之 (JMS over RPC) <Test> <Test Done>
1）message-based RPC can be used to make remote calls that use JMS as a transport.
2) To support message-based RPC, Spring offers JmsInvokerServiceExporter for exporting beans as message-based services and JmsInvokerProxyFactoryBean for clients to consume those services.
3) EXPORTING JMS-BASED SERVICES
3.1) To demonstrate how JmsInvokerServiceExporter works, consider AlertServiceImpl.
public class AlertServiceImpl implements AlertService {
    public Spittle sendSpittleAlert(final Spittle spittle) {
        System.out.println("email send for " + spittle);
        return spittle;
    }
}

3.2) implement the AlertService interface,
public interface AlertService {
    Spittle sendSpittleAlert(Spittle spittle);
}

3.3) Server side: in jms-rpc-service.xml, configure a JmsInvokerServiceExporter, refer AlertService :
<bean id="alertServiceExporter" class="org.springframework.jms.remoting.JmsInvokerServiceExporter"
          p:service-ref="alertService"
          p:serviceInterface="spittr.messaging.rpc.alerts.AlertService" />

<bean id="alertService" class="spittr.messaging.rpc.alerts.AlertServiceImpl"/>

3.4) declare a messageListener bean ref to alertServiceExporter. i.e. a JmsInvokerServiceExporter:
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg ref="alertServiceExporter"/>
</bean>

<!-- and this is the message listener container -->
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="spittleQueue"/>
    <property name="messageListener" ref="messageListener" />
</bean>

3.5) define a ServiceRunner, System.in.read() is just a way to keep ServiceRunner thread alive:
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:jms-rpc-service.xml")
public class AlertServiceRunner {
    @Test
    public void runService() {
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

4) Client side: 
4.1) define a JmsInvokerProxyFactoryBean to access the service.
<bean id="alertService" class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"
          p:connectionFactory-ref="connectionFactory"
          p:queue-ref="spittleQueue"
          p:serviceInterface="spittr.messaging.rpc.alerts.AlertService" />
4.2) define client test runner:
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:jms-rpc-client.xml")
public class AlertServiceClient {

    @Autowired
    AlertService alertService;

    @Test
    public void testRPCoverJMS() {
        Spittle spittle = new Spittle(1L, null, "Hello", new Date());
        Spittle returnSpittle = alertService.sendSpittleAlert(spittle);
        System.out.println(returnSpittle);
    }

    public static void main(String[] args) throws IOException {
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:jms-rpc-client.xml");
        AlertService alertService = context.getBean(AlertService.class);
        for (;;) {
            System.out.print("Please input spittle message: ");
            Scanner scanner = new Scanner(System.in);
            String message = scanner.nextLine();
            Spittle spittle = new Spittle(1L, null, message, new Date());
            Spittle returnSpittle = alertService.sendSpittleAlert(spittle);
            System.out.println(returnSpittle);
        }
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Using message-based RPC
- make remote calls that use JMS as a transport.
- To support message-based RPC, Spring offers JmsInvokerServiceExporter for exporting beans as message-based services and JmsInvokerProxyFactoryBean for clients to consume those services.

#EXPORTING JMS-BASED SERVICES
- If HttpInvokerServiceExporter exports services that communicate over HTTP, then JmsInvokerServiceExporter must export services that converse over JMS.
- To demonstrate how JmsInvokerServiceExporter works, consider AlertServiceImpl.
@Component("alertService")
public class AlertServiceImpl implements AlertService {
	private JavaMailSender mailSender;
	
	private String alertEmailAddress;
	
	public AlertServiceImpl(JavaMailSender mailSender, String alertEmailAddress) {
		this.mailSender = mailSender;
		this.alertEmailAddress = alertEmailAddress;
	}
	
	public void sendSpittleAlert(final Spittle spittle) {				//Send Spittle alert
		SimpleMailMessage message = new SimpleMailMessage();
		String spitterName = spittle.getSpitter().getFullName();
		message.setFrom("noreply@spitter.com");
		message.setTo(alertEmailAddress);
		message.setSubject("New spittle from " + spitterName);
		message.setText(spitterName + " says: " + spittle.getText());
		mailSender.send(message);
	}
}

- It does implement the AlertService interface, as shown here:
public interface AlertService {
	void sendSpittleAlert(Spittle spittle);
}

You’ll refer to this bean as you configure a JmsInvokerServiceExporter:
<bean id="alertServiceExporter" class="org.springframework.jms.remoting.JmsInvokerServiceExporter" p:service-ref="alertService"
p:serviceInterface="com.habuma.spittr.alerts.AlertService" />

- This bean’s properties describe what the exported service should look like. The service property is wired to refer to the alertService bean, which is the implementation of the remote service. Meanwhile, the serviceInterface property is set to the fully qualified class name of the interface that the service provides.

- The exporter’s properties don’t describe the specifics of how the service will be carried over JMS. But the good news is that JmsInvokerServiceExporter qualifies as a JMS listener. Therefore, you can configure it as such in a <jms:listener-container> element:
<jms:listener-container connection-factory="connectionFactory">
	<jms:listener destination="spitter.alert.queue" ref="alertServiceExporter" />
</jms:listener-container>

- At this point, the JMS-based alert service should be ready and waiting for RPC messages to arrive on the spitter.alert.queue queue. 

#CONSUMING JMS-BASED SERVICES
- On the client side, JmsInvokerProxyFactoryBean will be used to access the service.
- JmsInvokerProxyFactoryBean is a lot like the other remoting proxy factory beans that we looked at in chapter 15. It hides the details of accessing a remote service behind a convenient interface, through which the client interacts with the service. 
- The big difference is that instead of proxying RMI- or HTTP-based services, JmsInvokerProxyFactoryBean proxies a JMS-based service that was exported by
JmsInvokerServiceExporter.
- To consume the alert service, you can wire the JmsInvokerProxyFactoryBean like this:
<bean id="alertService" class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"
	p:connectionFactory-ref="connectionFactory"
	p:queueName="spittle.alert.queue"
	propp:serviceInterface="com.habuma.spittr.alerts.AlertService" />

- The connectionFactory and queueName properties specify how RPC messages should be delivered—here, on the spitter.alert.queue queue at the message broker configured in the given connection factory. 
- The serviceInterface specifies that the proxy should be exposed through the AlertService interface.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
总而言之，JMS over RPC java config
1) Server Side: 
@Configuration
@ComponentScan(basePackages = "spittr.service")
public class JMSServiceConfig {
    @Autowired
    SpittleService spittleService;

    @Bean
    public JmsInvokerServiceExporter exporter() {
        JmsInvokerServiceExporter exporter = new JmsInvokerServiceExporter();
        exporter.setService(spittleService);
        exporter.setServiceInterface(SpittleService.class);
        return exporter;
    }

    @Bean
    public MessageListenerAdapter messageListener() {
        return new MessageListenerAdapter(exporter());
    }

    @Bean
    public DefaultMessageListenerContainer jmsContainer() {
        DefaultMessageListenerContainer jmsContainer = new DefaultMessageListenerContainer();
        jmsContainer.setConnectionFactory(connectionFactory());
        jmsContainer.setDestination(spittleQueue());
        jmsContainer.setMessageListener(messageListener());
        return jmsContainer;
    }

    @Bean
    public ConnectionFactory connectionFactory() {
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        connectionFactory.setBrokerURL("tcp://localhost:61616");
        return connectionFactory;
    }


    @Bean
    public Queue spittleQueue() {
        return new org.apache.activemq.command.ActiveMQQueue("spittle.alert.queue");
    }

    @Bean
    public Topic spittleTopic() {
        return new org.apache.activemq.command.ActiveMQTopic("spittle.alert.topic");
    }
}
2) Client side: 
@Configuration
public class JMSClientConfig {
    @Bean
    public JmsInvokerProxyFactoryBean spittleService() {
        JmsInvokerProxyFactoryBean proxy = new JmsInvokerProxyFactoryBean();
        proxy.setConnectionFactory(connectionFactory());
        proxy.setQueue(spittleQueue());
        proxy.setServiceInterface(SpittleService.class);
        return proxy;
    }
    @Bean
    public ConnectionFactory connectionFactory() {
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        connectionFactory.setBrokerURL("tcp://localhost:61616");
        return connectionFactory;
    }
    @Bean
    public Queue spittleQueue() {
        return new ActiveMQQueue("spittle.alert.queue");
    }
    @Bean
    public Topic spittleTopic() {
        return new ActiveMQTopic("spittle.alert.topic");
    }
}
3) ServiceRunner and ClientTest are the same as RMI, except for configuration classes references.
4) Service and ServiceImpl are the same as RMI.



#Messaging with AMQP

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- AMQP offers several advantages over JMS. AMQP goes beyond the Java language and platform
- First, AMQP defines a wire-level protocol for messaging, whereas JMS defines an API specification. 
- JMS’s API specification ensures that all JMS implementations can be used through a common API but doesn’t mandate that messages sent by one JMS implementation can be consumed by a different JMS implementation. 
- AMQP’s wire-level protocol, on the other hand, specifies the format that messages will take when en route between the producer and consumer. Consequently, AMQP is more interoperable than JMS—not only across different AMQP implementations, but also across languages and platforms.
- Another significant advantage of AMQP over JMS is that AMQP has a much more flexible and transparent messaging model.
- With JMS, there are only two messaging models to choose from: point-to-point and publish/subscribe.
- but AMQP enables you to route messages in a number of ways, and it does this by decoupling the message producer from the queue(s) in which the messages will be placed.
- Spring AMQP is an extension to the Spring Framework that enables AMQP-style messaging in Spring applications. As you’ll see, Spring AMQP provides an API that makes working with AMQP remarkably similar to Spring’s JMS abstraction.

# introduction
- In JMS, there are just three primary participants: the message producer, the message consumer(s), and a channel (either a queue or a topic) to carry the message between producers and consumers.
- In JMS, the channel helps to decouple the producer from the consumer, but both are still coupled to the channel.
- The channel has the double duty of relaying messages and determining how those messages will be routed; queues route using a point-to-point algorithm, and topics route in publish/subscribe fashion.
- *In contrast, AMQP producers don’t publish directly to a queue. Instead, AMQP introduces a new level of indirection between the producer and any queues that will carry the message: the exchange.
- a message producer publishes a message to an exchange. The exchange, which is bound to one or more queues, routes the message to the queue(s). Consumers pull messages from the queue and process them.
- the exchange isn’t a pass-through mechanism to a queue. AMQP defines four different types of exchanges, each with a different routing algorithm that decides whether to place a message in a queue.
- Depending on an exchange’s algorithm, it may consider the message’s routing key and/or arguments and compare those with the routing key and arguments of the binding between the exchange and a queue. (A routing key can be loosely thought of as the To address in an email, specifying the intended recipient.)

- The four standard types of AMQP exchanges are as follows:
1) Direct—A message will be routed to a queue if its routing key is a direct match for the routing key of the binding.
2) Topic—A message will be routed to a queue if its routing key is a wildcard match for the routing key of the binding.
3) Headers—A message will be routed to a queue if the headers and values in its table of arguments match those in the binding’s table of arguments. A special
header named x-match can specify whether all values must match or if any can match.
4) Fanout—A message will be routed to all queues that are bound to the exchange, regardless of the routing key or headers/values in the table of arguments.

- producers publish to an exchange with a routing key; consumers retrieve from a queue.

#Configuring Spring for AMQP messaging
- RabbitMQ is a popular open source message broker that implements AMQP. Spring AMQP comes ready with RabbitMQ support, including a RabbitMQ connection factory, template, and Spring configuration namespace. www.rabbitmq.com/download.html
- The easiest way to configure a RabbitMQ connection factory is to use the rabbit configuration namespace provided by Spring AMQP
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/rabbit"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/rabbit
		http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<connection-factory id="connectionFactory" /> 			//RabbitMQ connection factory		

</beans:beans>
- Although it’s optional, in this case I’ve decided to declare the rabbit namespace as the primary namespace in the configuration and demote the beans namespace to being a secondary namespace.
- That’s because I anticipate declaring more rabbits than beans in this configuration and would rather prefix the few bean elements with beans: and leave the rabbit elements prefix-less.
- By default, the connection factory will assume that the RabbitMQ server is listening on localhost at post 5672 and that the username and password are both guest. in production:

<connection-factory id="connectionFactory"
	host="${rabbitmq.host}"
	port="${rabbitmq.port}"
	username="${rabbitmq.username}"
	password="${rabbitmq.password}" />

#DECLARING QUEUES, EXCHANGES, AND BINDINGS
- with JMS, the routing behavior of queues and topics is established by the specification, 
- AMQP routing is richer and more flexible and thus depends on you to define the queues and exchanges and how they’re bound to each other.
- Spring AMQP’s rabbit namespace includes several elements for lazily creating queues, exchanges, and the bindings between them.
<queue>: Creates a queue.
<fanout-exchange>: Creates a fanout exchange.
<header-exchange>: Creates a headers exchange.
<topic-exchange>: Creates a topic exchange.
<direct-exchange>: Creates a direct exchange.
<bindings> <binding/> </bindings>: The <bindings> element defines a set of one or more <binding> elements. The <binding> element creates a binding between an exchange and a queue.
- <admin> element creates a RabbitMQ administrative component that automatically creates (in the RabbitMQ broker, if they don’t already exist) any queues, exchanges, and bindings declared
- declare a queue named spittle.alert.queue:
<admin connection-factory="connectionFactory"/> 
<queue id="spittleAlertQueue" name="spittle.alerts" />
- there’s a default direct exchange with no name, and all queues are bound to that exchange with a routing key that’s the same as the queue’s name.
- With this simple configuration, you could send messages to the no-name exchange and specify a routing key of spittle.alert.queue to have messages routed to the queue.
- Essentially, this re-creates a JMSstyle point-to-point model.
- to have a message routed to multiple queues with no regard for the routing key, you can configure a fanout exchange and several queues
<admin connection-factory="connectionFactory" /> 
<queue name="spittle.alert.queue.1" > 
<queue name="spittle.alert.queue.2" > 
<queue name="spittle.alert.queue.3" > 
<fanoutexchange name="spittle.fanout"> 
	<bindings> 
		<binding queue="spittle.alert.queue.1" /> 
		<binding queue="spittle.alert.queue.2" /> 
		<binding queue="spittle.alert.queue.3" /> 
	</bindings> 
</fanoutexchange>

#Sending messages with RabbitTemplate
- Spring AMQP provides RabbitTemplate to eliminate boilerplate associated with sending and receiving messages with RabbitMQ.
<template id="rabbitTemplate" connection-factory="connectionFactory" />
- inject the template bean into AlertServiceImpl and use it to send a Spittle.
public class AlertServiceImpl implements AlertService {
	private RabbitTemplate rabbit;
	@Autowired
	public AlertServiceImpl(RabbitTemplate rabbit) {
		this.rabbit = rabbit;
	}
	public void sendSpittleAlert(Spittle spittle) {
		rabbit.convertAndSend("spittle.alert.exchange", "spittle.alerts", spittle);
	}
}
- passes in three parameters: the name of the exchange, the routing key, and the object to be sent.
- leave out the exchange name when calling convertAndSend():
rabbit.convertAndSend("spittle.alerts", spittle);
- leave out both the exchange name and routing key:
rabbit.convertAndSend(spittle);
- When the exchange name or the exchange name and routing key are left out of the parameter list, RabbitTemplate uses its default exchange name and routing key.
- you can configure different defaults using the exchange and routing-key attributes on the <template>
<template id="rabbitTemplate" connection-factory="connectionFactory" exchange="spittle.alert.exchange" routing-key="spittle.alerts" />
- you can use the lower-level send() method to send an org.springframework.amqp.core.Message object
Message helloMessage = new Message("Hello World!".getBytes(), new MessageProperties());
rabbit.send("hello.exchange", "hello.routing", helloMessage);
- convertAndSend() convert an object to a Message with the assistance of a message converter. The default message converter is SimpleMessageConverter, which is suitable for working with Strings, Serializable instances, and byte arrays. 
- Spring AMQP provides a few other message converters that you might find useful, including some for working with JSON and XML data.

#Receiving AMQP messages
#RECEIVING MESSAGES WITH RABBITTEMPLATE
- fetch a Message object from the queue:
Message message = rabbit.receive("spittle.alert.queue");
- you can configure a default queue for receiving messages:
<template id="rabbitTemplate" connection-factory="connectionFactory" exchange="spittle.alert.exchange" routing-key="spittle.alerts" queue="spittle.alert.queue" />
Message message = rabbit.receive();

Spittle spittle = (Spittle) rabbit.receiveAndConvert("spittle.alert.queue");
Spittle spittle = (Spittle) rabbit.receiveAndConvert();			//fall back on the template’s default queue name:
- Calls to both receive() and receiveAndConvert() return immediately, possibly with a null if no messages are waiting in the queue. That leaves it up to you to manage any polling and threading necessary to monitor the queue.
- Instead of synchronously polling and waiting for messages to arrive, Spring AMQP offers message-driven POJO support

#DEFINING MESSAGE-DRIVEN AMQP POJOS
- define the POJO
public class SpittleAlertHandler {
	public void handleSpittleAlert(Spittle spittle) {
		// ... implementation goes here ...
	}
}
- declare SpittleAlertHandler as a bean
<bean id="spittleListener" class="com.habuma.spittr.alert.SpittleAlertHandler" />
- declare a listener container and a listener to call on SpittleAlertHandler when a message arrives.
<listener-container connection-factory="connectionFactory">
	<listener ref="spittleListener" method="handleSpittleAlert" queue-names="spittle.alert.queue" />
</listener-container>
- using the queue-names attribute, you can list as many queue names as you want, separated with commas.
- Another way of specifying the queues to listen on is to reference the queue beans you declared with the <queue> element.
<listener-container connection-factory="connectionFactory">
	<listener ref="spittleListener" method="handleSpittleAlert" queues="spittleAlertQueue" />
</listener-container>
- alert queue redeclared with an ID:
<queue id="spittleAlertQueue" name="spittle.alert.queue" />

- messaging is about asynchronous communication between applications. using WebSocket enables asynchronous communication between a browser-based client and a server

Chapter 18 Messaging with WebSocket and STOMP
- Asynchronous messaging is a common form of communication between applications. But when one of those applications is running in a web
browser, something a little different is needed.
- WebSocket is a protocol providing full-duplex communication across a single socket. It enables, among other things, asynchronous messaging between a web
browser and a server. Being full-duplex means that the server can send messages to the browser as well as the browser sending messages to the server.
- Spring 4.0 introduced support for WebSocket communication, including:
	A low-level API for sending and receiving messages
	A higher-level API for handling messages in Spring MVC controllers
	A messaging template for sending messages
	SockJS support to cope with the lack of WebSocket support in browsers, servers, and proxies

#Working with Spring’s low-level WebSocket API
- a WebSocket is just a communication channel between two applications. An application on one end of the WebSocket sends a message, and the other end handles that message.
- Because it’s full-duplex, either end can send messages and either end can handle messages.
- A JavaScript client in the browser opens a connection to the server, and the server sends updates to the browser on that connection. This is
generally more efficient and more natural than the historically common alternative of polling the server for updates.
- To handle messages in Spring with low-level WebSocket support, you must write a class that implements WebSocketHandler:
public interface WebSocketHandler {
	void afterConnectionEstablished(WebSocketSession session) 	throws Exception;
	void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception;
	void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;
	void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;
	boolean supportsPartialMessages();
}

- Rather than implement WebSocketHandler directly, it’s easier to extend AbstractWebSocketHandler, an abstract implementation of WebSocketHandler
public class MarcoHandler extends AbstractWebSocketHandler {
	private static final Logger logger = LoggerFactory.getLogger(MarcoHandler.class);
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		logger.info("Received message: " + message.getPayload());
		Thread.sleep(2000);
		session.sendMessage(new TextMessage("Polo!"));
	}
}
- three additional methods defined by AbstractWebSocketHandler:
	handleBinaryMessage()
	handlePongMessage()
	handleTextMessage()
- handling the establishment and closing of connections：
public void afterConnectionEstablished(WebSocketSession session) throws Exception {
	logger.info("Connection established");
}
@Override
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
	logger.info("Connection closed. Status: " + status);
}
- configure it so that Spring will dispatch messages to it. In Spring’s Java configuration, this involves annotating a configuration class with @EnableWebSocket and implementing the WebSocketConfigurer interface,
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(marcoHandler(), "/marco");								//Map MarcoHandler to “/marco”
	}
	@Bean
	public MarcoHandler marcoHandler() {				//Declare MarcoHandler bean
		return new MarcoHandler();
	}
}
- In xml config: take advantage of the websocket namespace
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="
		http://www.springframework.org/schema/websocket
		http://www.springframework.org/schema/websocket/spring-websocket.xsd
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd">
		
		<websocket:handlers>
			<websocket:mapping handler="marcoHandler" path="/marco" />
		</websocket:handlers>
		<bean id="marcoHandler" class="marcopolo.MarcoHandler" />
</beans>

- client side: JavaScript that opens a native WebSocket and uses it to volley messages to the server.
var url = 'ws://' + window.location.host + '/websocket/marco';
var sock = new WebSocket(url);						//Open WebSocket
sock.onopen = function() {
	console.log('Opening');							//Handle open event
	sayMarco();
};
sock.onmessage = function(e) {						//Handle message
	console.log('Received message: ', e.data);
	setTimeout(function(){sayMarco()}, 2000);
};
sock.onclose = function() {							//Handle close event
	console.log('Closing');
};
function sayMarco() {
	console.log('Sending Marco!');
	sock.send("Marco!");							//Send message
}

- the URL is prefixed with “ws://”, indicating a basic WebSocket connection. If it were a secure WebSocket connection, the protocol prefix would have been “wss://”.
- the WebSocket’s onopen, onmessage, and onclose events mirror MarcoHandler’s afterConnectionEstablished(), handleTextMessage(), and afterConnectionClosed() methods.
- onopen event is given a function that calls sayMarco() to send the “Marco!” message on the WebSocket.
- a call to sock.close() will put an end to the madness. The server could also close the connection, or the browser could navigate away from the page, and the
connection will be closed. once the connection goes down, the onclose event will be fired.
- If you were to build the code and deploy it to a servlet container, it "might" even work.

#Coping with a lack of WebSocket support
- WebSocket is a relatively new specification. Even though it was standardized by the end of 2011, it still doesn’t have consistent support in web browsers and application servers.
- Firefox and Chrome have had full support for WebSocket for quite a while, but other browsers have only recently started to support WebSocket.
- minimum versions of several popular browsers that support WebSocket:
	Internet Explorer: 10.0
	Firefox: 4.0 (partial), 6.0 (full)
	Chrome: 4.0 (partial), 13.0 (full)
	Safari: 5.0 (partial), 6.0 (full)
	Opera: 11.0 (partial), 12.10 (full)
	iOS Safari: 4.2 (partial), 6.0 (full)
	Android Browser: 4.4
- server support also limited:
	GlassFish
	Tomcat 8
- trouble in the middle. Firewall proxies generally block anything but HTTP traffic. They’re not configured (yet) to allow WebSocket communication.
- WebSocket fallback is the specialty of SockJS. SockJS is a WebSocket emulator that mirrors the WebSocket API on the surface, but under the covers is clever enough to choose another form of communication when WebSocket isn’t available.
- SockJS will always favor WebSocket first, but if WebSocket isn’t an option, it will determine the best available option
XHR streaming
XDR streaming
iFrame event source
iFrame HTML file
XHR polling
XDR polling
iFrame XHR polling
JSONP polling
- SockJS lets you develop to a consistent programming model as if WebSocket support were ubiquitous, and it handles the fallback plans under the covers.
- enable SockJS communication on the server side, you can simply ask for it in the Spring configuration:
@Override
public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
	registry.addHandler(marcoHandler(), "/marco").withSockJS();
}
- calling withSockJS() on the WebSocketHandlerRegistration returned from the call to addHandler(), you’re saying that you want SockJS to be enabled, and
for its fallbacks to go into effect if WebSocket can’t be used.
- in xml config:
<websocket:handlers>
	<websocket:mapping handler="marcoHandler" path="/marco" />
	<websocket:sockjs />
</websocket:handlers>

- To use SockJS on the client, you’ll need to be sure to load the SockJS client library.
- load it from the SockJS CDN with a <script> tag like this:
<script src="http://cdn.sockjs.org/sockjs-0.3.min.js"></script>

#Resolving web resources with WebJars
- using WebJars to resolve JavaScript libraries as part of the project’s Maven or Gradle build, just like any other dependency.
- To support that, set up a resource handler in the Spring MVC configuration to resolve requests where the path starts with /webjars/** from the WebJars standard path:
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
	registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
}
- With that resource handler in effect, I can load the SockJS library in a web page with the following <script> tag:
<script th:src="@{/webjars/sockjs-client/0.3.4/sockjs.min.js}"></script>
- Notice that this particular <script> tag comes from a Thymeleaf template and takes advantage of the @{...} expression to calculate the full context-relative URL path for the JavaScript file.
- only two lines from must be changed to use SockJS:
var url = 'marco';
var sock = new SockJS(url);
- The first change you can make is to the URL. SockJS deals in URLs with the http:// or https:// scheme instead of ws:// and wss://.
- you can use relative URLs, keeping you from having to derive the fully qualified URL.
- In this case, if the page containing the JavaScript was at http://localhost:8080/websocket, the simple marco path given will result in a connection to http://localhost:8080/websocket/marco.
- The key change you must make, however, is to create an instance of SockJS instead of WebSocket. Because SockJS mimics WebSocket as closely as possible, the rest of the code can remain the same.
- WebSocket enables browser-server communication, and SockJS offers fallback communication when WebSocket isn’t supported
- But in either case, this form of communication is too low-level for practical use. Let’s see how you can layer STOMP (Simple Text Oriented Messaging Protocol) on top of WebSocket to add proper messaging semantics to browser-server communication.

#Working with STOMP messaging
- HTTP protocol addresses the minute details of how a web browser makes a request and how a web server responds to that request. As a result, most
developers never write code that deals with low-level TCP socket communication.
- Working directly with WebSocket (or SockJS) is a lot like developing a web application using only TCP sockets. Without a higher-level wire protocol, it’s up to you to define the semantics of the messages being sent between applications. And you’d need to be sure that both ends of the connection agreed on those semantics.
- Just as HTTP layers a request-response model on top of TCP sockets, STOMP layers a frame-based wire format to define messaging semantics on top of WebSocket.
- Much like HTTP requests and responses, STOMP frames are comprised of a command, one or more headers, and a payload.
SEND
destination:/app/marco
content-length:20

{\"message\":\"Marco!\"}

- the STOMP command is SEND, indicating that something is being sent. 
- It’s followed by two headers: one indicates the destination where the message should be sent, and the other communicates the size of the payload. 
- Following a blank line, the frame concludes with the payload; in this case, a JSON message.
- destination header indicates STOMP is a messaging protocol, very much like JMS or AMQP
- Messages are published to destinations that may, in fact, be backed by real message brokers.
- On the other end, message handlers can listen to those destinations to receive the messages sent.
- In the context of WebSocket communication, a browser-based JavaScript application may publish a message to a destination that’s handled by a server-side component. 
- A server-side component may publish a message to a destination to be received by the JavaScript client.
- Spring provides for STOMP-based messaging with a programming model based on Spring MVC. 
- handling STOMP messages in a Spring MVC controller isn’t much different from handling HTTP requests.

#Enabling STOMP messaging
- annotate controller methods with @MessageMapping to handle STOMP messages within Spring MVC in a way very similar to how @RequestMapping-annotated methods handle HTTP requests.
- Unlike @RequestMapping, @MessageMapping isn’t enabled by the @EnableWebMvc annotation
- Spring’s web messaging is built around a message broker, you must configure a message broker and some basic destination details.

@Configuration
@EnableWebSocketMessageBroker
	public class WebSocketStompConfig extends AbstractWebSocketMessageBrokerConfigurer {
	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/marcopolo").withSockJS();
	}
	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableSimpleBroker("/queue", "/topic");
		registry.setApplicationDestinationPrefixes("/app");
	}
}

- @EnableWebSocketMessageBroker indicates that this configuration class is not only configuring WebSocket, but it’s configuring broker-based STOMP messaging.
- overrides the registerStompEndpoints() method to register /marcopolo as a STOMP endpoint.
- This path is distinct from any destination path that you might send or receive messages from. It’s the endpoint that a client would connect to before
subscribing to or publishing to a destination path.
- WebSocketStompConfig also configures a simple message broker by overriding the configureMessageBroker() method. This method is optional. If you don’t override it, you’ll get a simple in-memory message broker configured to handle messages prefixed with /topic.
- When a message arrives, the destination prefix will determine how the message is handled.
- the application destinations are prefixed with /app and the broker destinations are prefixed with either /topic or /queue.
- A message headed for an application destination is routed directly to an @MessageMapping-annotated controller method.
- Messages destined for the broker, including any messages resulting from values returned by @MessageMapping-annotated methods, are routed to the broker
and are ultimately sent out to clients subscribed to those destinations.

#ENABLING A STOMP BROKER RELAY
- For a production application, you’ll probably want to back your WebSocket messaging with a real STOMP-enabled broker, such as RabbitMQ or ActiveMQ.
- Once the broker is ready, you can replace the default inmemory broker with a STOMP broker relay by overriding the configureMessageBroker() method like this:
@Override
public void configureMessageBroker(MessageBrokerRegistry registry) {
	registry.enableStompBrokerRelay("/topic", "/queue");
	registry.setApplicationDestinationPrefixes("/app");
}
- By default, the STOMP broker relay assumes that the broker is listening on port 61613 of localhost and that the client username and password are both “guest”. If your STOMP broker is on another server or is configured with different client credentials
@Override
public void configureMessageBroker(MessageBrokerRegistry registry) {
	registry.enableStompBrokerRelay("/topic", "/queue")
		.setRelayHost("rabbit.someotherserver")
		.setRelayPort(62623)
		.setClientLogin("marcopolo")
		.setClientPasscode("letmein01");
	registry.setApplicationDestinationPrefixes("/app", "/foo");
}

#Handling STOMP messages from the client
- A method annotated with @MessageMapping can handle messages as they arrive at a specified destination
@Controller
public class MarcoController {
	private static final Logger logger = LoggerFactory.getLogger(MarcoController.class);
	
	@MessageMapping("/marco")							//Handle messages for /app/marco destination
	public void handleShout(Shout incoming) {
		logger.info("Received message: " + incoming.getMessage());
	}
}

- Because handleShout() accepts a Shout parameter, the payload of the STOMP message will be converted into a Shout using one of Spring’s message converters.

public class Shout {
	private String message;
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
}

- Spring can convert message payloads to Java types using one of a few message converters.
ByteArrayMessageConverter： Converts a message with a MIME type of application/octet-stream to and from byte[]
MappingJackson2MessageConverter： Converts a message with a MIME type of application/json to and from a Java object
StringMessageConverter Converts a message with a MIME type of text/plain to and from String
- Assuming that the message handled by handleShout() has a content type of application/json (which is probably a safe guess given that Shout is neither a byte[] nor a String), the MappingJackson2MessageConverter will be tasked with converting the JSON message into a Shout object.
- Just like its HTTP-oriented counterpart, MappingJackson2HttpMessageConverter, MappingJackson2MessageConverter delegates much of its work to the underlying Jackson 2 JSON processor.
- By default, Jackson will use reflection to map JSON properties to Java object properties. you can influence how the conversion takes place by annotating the Java type with Jackson annotations.

#PROCESSING SUBSCRIPTIONS
- Any method that’s annotated with @SubscribeMapping will be invoked, much like @MessagingMapping methods, when a STOMP subscription message arrives.
- It’s important to understand that just like @MessageMapping methods, @SubscribeMapping methods receive their messages via AnnotationMethodMessageHandler
- the configuration in listing 18.5, that means that @SubscribeMapping methods can only handle messages for destinations that are prefixed with /app.
- The primary use case for @SubscribeMapping is to implement a request-reply pattern. In the request-reply pattern, the client subscribes to a destination expecting a one-time response at that destination.
@SubscribeMapping({"/marco"})
public Shout handleSubscription() {
	Shout outgoing = new Shout();
	outgoing.setMessage("Polo!");
	return outgoing;
}

#WRITING THE JAVASCRIPT CLIENT
- some JavaScript client code that might connect to the /marcopolo endpoint and send a “Marco!” message.
var url = 'http://' + window.location.host + '/stomp/marcopolo';
var sock = new SockJS(url);											//Create SockJS connection
var stomp = Stomp.over(sock);										//Create STOMP client
var payload = JSON.stringify({ 'message': 'Marco!' });
stomp.connect('guest', 'guest', function(frame) {					//Connect to STOMP endpoint
	stomp.send("/marco", {}, payload);								//Send message
});

- you never use SockJS directly. Instead you construct an instance of the STOMP client by calling Stomp.over(sock). This effectively wraps SockJS to send STOMP messages over the WebSocket connection.
- The second parameter passed to send() is a map of headers to be included in the STOMP frame;

#Sending messages to the client
- WebSocket is often viewed as a way that a server can send data to the browser without being in response to an HTTP request.
- How can you communicate with the browser-based client using Spring and WebSocket/STOMP? Spring offers two ways to send data to a client:
1） As a side-effect of handling a message or subscription
2） Using a messaging template

#SENDING A MESSAGE AFTER HANDLING A MESSAGE
@MessageMapping("/marco")
public Shout handleShout(Shout incoming) {
	logger.info("Received message: " + incoming.getMessage());
	Shout outgoing = new Shout();
	outgoing.setMessage("Polo!");
	return outgoing;
}

- By simply returning an object, a handler method can also be a sender method. When an @MessageMapping-annotated method has a return value, the returned object will be converted (via a message converter) and placed into the payload of a STOMP frame and published to the broker.

- By default, the frame will be published to the same destination that triggered the handler method, but with /topic as the prefix. In the case of handleShout(), that means that the returned Shout object will be written to the payload of a STOMP frame and published to the /topic/marco destination.
- But you can override the destination by annotating the method with @SendTo:
@MessageMapping("/marco")
@SendTo("/topic/shout")
public Shout handleShout(Shout incoming) {
	logger.info("Received message: " + incoming.getMessage());
	Shout outgoing = new Shout();
	outgoing.setMessage("Polo!");
	return outgoing;
}
- The handleShout() method now sends a message in response to having received a message. In a similar way, an @SubscribeMapping-annotated method can send a message in reply to a subscription.
@SubscribeMapping("/marco")
public Shout handleSubscription() {
	Shout outgoing = new Shout();
	outgoing.setMessage("Polo!");
	return outgoing;
}

#SENDING A MESSAGE FROM ANYWHERE
- @MessageMapping and @SubscribeMapping offer a simple way to send messages as a consequence of receiving a message or handling a subscription. 
- But Spring’s SimpMessagingTemplate makes it possible to send messages from anywhere in an application, even without having received a message first.
- Rather than force the user to refresh the page, you can have the home page subscribe to a STOMP topic to receive a live feed of Spittle updates as they’re created.
- Within the home page, you need to add the following JavaScript chunk:
<script>
	var sock = new SockJS('spittr');
	var stomp = Stomp.over(sock);
	stomp.connect('guest', 'guest', function(frame) {
		console.log('Connected');
		stomp.subscribe("/topic/spittlefeed", handleSpittle);
	});
	function handleSpittle(incoming) {
		var spittle = JSON.parse(incoming.body);
		console.log('Received: ', spittle);
		var source = $("#spittle-template").html();
		var template = Handlebars.compile(source);
		var spittleHtml = template(spittle);
		$('.spittleList').prepend(spittleHtml);
	}
</script>

Handlebars template is defined in a separate <script> tag as follows:
<script id="spittle-template" type="text/x-handlebars-template">
	<li id="preexist">
		<div class="spittleMessage">{{message}}</div>
		<div>
			<span class="spittleTime">{{time}}</span>
			<span class="spittleLocation">({{latitude}}, {{longitude}})</span>
		</div>
	</li>
</script>

- On the server, you can use SimpMessagingTemplate to publish any newly created Spittle as a message to the /topic/spittlefeed topic.
@Service
public class SpittleFeedServiceImpl implements SpittleFeedService {
	private SimpMessageSendingOperations messaging;
	@Autowired
	public SpittleFeedServiceImpl(SimpMessageSendingOperations messaging) {			//Inject messaging template
		this.messaging = messaging;
	}
	public void broadcastSpittle(Spittle spittle) {
		messaging.convertAndSend("/topic/spittlefeed", spittle);					//Send message
	}
}

- As a side-effect of configuring Spring’s STOMP support, there’s already a SimpMessageTemplate bean in the Spring application context
- When you publish a message to a STOMP topic with convertAndSend() or as a result of a handler method, any client subscribed to that topic will receive the message.

#Working with user-targeted messages
- Up to this point, the messages you’ve sent and received were between a client (in a web browser) and the server. The user of that client hasn’t been taken into account. 
- When an @MessageMapping-annotated method is invoked, you know that a message has been received, but not who it’s from.
- Similarly, if you don’t know who the user is, then any messages sent will go to all clients that have subscribed to the topic that the message is carried on; there’s no way to send that message to a specific user.
- If you know who the user is, however, it becomes possible to deal with messages associated with a user, not just those associated with a client.
- three ways to take advantage of an authenticated user when messaging with Spring and STOMP:
1） The @MessageMapping and @SubscribeMapping methods can receive a Principal for the authenticated user.
2） Values returned from the @MessageMapping, @SubscribeMapping, and @MessageException methods can be sent as messages to the authenticated user.
3） The SimpMessagingTemplate can send messages to a specific user.

#Working with user messages in a controller
- two ways that a controller’s @MessageMapping or @SubscribeMapping method can be user-aware in processing messages. 
- By simply asking for a Principal as a parameter to a handler method, the handler method can know who the user is
- a handler method can be annotated with @SendToUser to indicate that its return value should be sent in a message to the authenticated user’s client (and to
that client only).
- By posting the Spittle as a STOMP message, you can take full advantage of the asynchronous nature of STOMP messaging.
@MessageMapping("/spittle")
@SendToUser("/queue/notifications")
public Notification handleSpittle(Principal principal, SpittleForm form) {
	Spittle spittle = new Spittle(principal.getName(), form.getText(), new Date());
	spittleRepo.save(spittle);
	return new Notification("Saved Spittle");
}
- Because this method is annotated with @MessageMapping, it will be invoked whenever a message arrives on the /app/spittle destination. 
- The SpittleForm will be created from that message and, assuming that the user is authenticated, the Principal will also be derived from headers in the STOMP frame.
- The @SendToUser annotation specifies that the returned Notification should be sent as a message to the /queue/notifications destination.
- Consider this line of JavaScript that subscribes to a user-specific destination:
stomp.subscribe("/user/queue/notifications", handleNotifications);
- destinations that are prefixed with /user are handled in a special way. Rather than flowing through AnnotationMethodMessageHandler (like an application message), or through SimpleBrokerMessageHandler or StompBrokerRelayMessageHandler (like a broker message), /user messages flow through UserDestinationMessageHandler
- UserDestinationMessageHandler’s primary job is to reroute user messages to a destination that’s unique to the user.
- In the case of a subscription, it derives the target destination by removing the /user prefix and adding a suffix that’s based on the user’s session.
- For instance, a subscription to /user/queue/notifications may end up being rerouted to a destination named /queue/notifications-user6hr83v6t.
- handleSpittle() is annotated with @SendToUser("/queue/ notifications"). This new destination is prefixed with /queue, which is one of the prefixes
that your StompBrokerRelayMessageHandler (or SimpleBrokerMessageHandler) is configured to handle, so the message will go there next. As it turns out, the client subscribed to that destination, so the client will receive the Notification message.
- The @SendToUser annotation and a Principal parameter are very useful when working within a controller method.

#Sending messages to a specific user
- In addition to convertAndSend(), SimpMessagingTemplate also offers convertAndSendToUser(). As its name suggests, the convertAndSendToUser() method enables
you to send messages that target a specific user.
- if the Spittle text includes “@jbauer”, then you should send a message to the client where a user with the username “jbauer” is logged in.
@Service
public class SpittleFeedServiceImpl implements SpittleFeedService {
	private SimpMessagingTemplate messaging;
	private Pattern pattern = Pattern.compile("\\@(\\S+)");
	@Autowired
	public SpittleFeedServiceImpl(SimpMessagingTemplate messaging) {
		this.messaging = messaging;
	}
	public void broadcastSpittle(Spittle spittle) {
		messaging.convertAndSend("/topic/spittlefeed", spittle);
		Matcher matcher = pattern.matcher(spittle.getMessage());
		if (matcher.find()) {
			String username = matcher.group(1);
			messaging.convertAndSendToUser(username, "/queue/notifications", new Notification("You just got mentioned!"));
		}
	}

}
- if the given Spittle object’s message contains what appears to be a username (that is, any text that begins with “@”), a new Notification
will be sent to a destination named /queue/notifications. Therefore, if the Spittle has a message that contains “@jbauer”, the Notification will be published to the /user/jbauer/queue/notifications destination.

#Handling message exceptions
- In Spring MVC, if an exception occurs during request handling, an @ExceptionHandler method will be given an opportunity to deal with the exception
- you can annotate a controller method with @MessageExceptionHandler to handle exceptions thrown in an @MessageMapping method.
@MessageExceptionHandler
public void handleExceptions(Throwable t) {
	logger.error("Error handling message: " + t.getMessage());
}
- can declare a specific exception type that it should handle as a parameter:
@MessageExceptionHandler(SpittleException.class)
public void handleExceptions(Throwable t) {
	logger.error("Error handling message: " + t.getMessage());
}
- Or you can specify several exception types to be handled as an array parameter:
@MessageExceptionHandler({SpittleException.class, DatabaseException.class})
public void handleExceptions(Throwable t) {
	logger.error("Error handling message: " + t.getMessage());
}

-reply with an error:
@MessageExceptionHandler(SpittleException.class)
@SendToUser("/queue/errors")
public SpittleException handleExceptions(SpittleException e) {
	logger.error("Error handling message: " + e.getMessage());
	return e;
}

- UserDestinationMessageHandler will reroute the message to a destination unique to the user.
- Spring’s WebSocket support includes a low-level API that lets you work with raw WebSocket connections.
- Unfortunately, WebSocket support is not ubiquitous among web browsers, servers, and proxies. Therefore, Spring also supports SockJS, a protocol that falls back to alternative communication schemes when WebSocket doesn’t work.
- Spring also offers a higher-level programming model for handling WebSocket messages using the STOMP wire-level protocol.
- In this higher-level model, STOMP messages are handled in Spring MVC controllers, similarly to how HTTP messages are handled.

Chapter 19 Sending email with Spring
总而言之 (Spring email configuration and simple/rich email/velocity template)
1）Configuring a mail sender bean. a MailSender implementation sends email by connecting with an email server. Spring comes with one implementation of the MailSender interface, JavaMailSenderImpl, which uses the JavaMail API to send email.
@Configuration
@ComponentScan(basePackages = "spittr.mail")
@PropertySource("classpath:mailserver.properties")
public class MailConfig {

    @Bean
    public JavaMailSender mailSender(Environment env) {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(env.getProperty("mailserver.host"));
        mailSender.setPort(Integer.parseInt(env.getProperty("mailserver.port")));
        mailSender.setUsername(env.getProperty("mailserver.username"));
        mailSender.setPassword(env.getProperty("mailserver.password"));
        return mailSender;
    }
}
2) mailserver.properties
mailserver.host=smtp.163.com
mailserver.port=25
mailserver.username=13928882387@163.com
mailserver.password=Wen0304dw

2) wire MailSender and send a simple email <Test> <Test Done>
public interface SpittleMailService {
    void sendSimpleSpittleEmail(String to, Spittle spittle);
}

@Service
public class SpittleMailServiceImpl implements SpittleMailService{
    @Autowired
    JavaMailSender mailSender;

    public void sendSimpleSpittleEmail(String to, Spittle spittle) {
        SimpleMailMessage message = new SimpleMailMessage();		    //Construct message
        String spitterName = spittle.getSpitter().getFullName();
//        message.setFrom("noreply@spitter.com");
        message.setFrom("13928882387@163.com");	//Address email
        message.setTo(to);
        message.setSubject("New spittle from " + spitterName);
        message.setText(spitterName + " says: " + spittle.getText());   //Set message text
        mailSender.send(message);			                             //Send email
    }
}
3) send email with attachment <Test> <Test Done>
3.1) - Sending email messages with attachments using MimeMessageHelper, which wraps cumbersome javax.mail.internet.MimeMessage api 
public void sendSpittleEmailWithAttachment(String to, Spittle spittle) throws MessagingException {
	MimeMessage message = mailSender.createMimeMessage();
	MimeMessageHelper helper = new MimeMessageHelper(message, true);		//true indicates that this is to be a multipart message.
	String spitterName = spittle.getSpitter().getFullName();
	helper.setFrom("noreply@spitter.com");
	helper.setTo(to);
	helper.setSubject("New spittle from " + spitterName);
	helper.setText(spitterName + " says: " + spittle.getText());
	ClassPathResource couponImage = new ClassPathResource("/collateral/coupon.jpg");	
	helper.addAttachment("Coupon.png", couponImage);
	mailSender.send(message);
}
- using Spring’s ClassPathResource to load coupon.jpg from within the application’s classpath, pass that resource in as a parameter
4) Sending email with rich content, key is to set the message’s text as HTML. <Test> <Test Done>
public void sendRichSpitterEmail(String to, Spittle spittle) throws MessagingException {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);
        helper.setFrom("13928882387@163.com");
        helper.setTo(to);
        helper.setSubject("New spittle from " + spittle.getSpitter().getFullName());
        helper.setText("<html><body><img src='cid:spitterLogo'>" +
                "<h1>" + spittle.getSpitter().getFullName() + " says...</h1>" +
                "<i>" + spittle.getText() + "</i>" +
                "</body></html>", true);
        ClassPathResource image = new ClassPathResource("/collateral/spittr_logo_50.png");
        helper.addInline("spitterLogo", image);			//embed the logo image in the email message, <img src='cid:spitterLogo'>
        mailSender.send(message);
}
5) The problem with constructing an email message using string concatenation is that it’s not clear what the resulting message will look like. What you need is a way to express the email layout in a template close to what the resulting HTML, and then transform that template into a String to be passed into the setText() method on the message helper.
6) Constructing email messages with Velocity <Test> <Test Done>
- Apache Velocity is a general-purpose templating engine from Apache. 
- Velocity has been used for all kinds of things, including code generation and as an alternative to JSP. It can also be used to format rich email messages
6.1) declare a VelocityEngine bean and wire into SpitterEmailServiceImpl.
@Bean
public VelocityEngineFactoryBean velocityEngine() {			//VelocityEngineFactoryBean produces a VelocityEngine in the Spring application context.
	VelocityEngineFactoryBean velocityEngine = new VelocityEngineFactoryBean();
	Properties props = new Properties();
	props.setProperty("resource.loader", "class");
	props.setProperty("class.resource.loader.class", ClasspathResourceLoader.class.getName());		//load Velocity templates from the classpath
	velocityEngine.setVelocityProperties(props);	
	return velocityEngine;
}

7) Wire the Velocity engine and use VelocityEngineUtils from Spring to merge a Velocity template and model data into a String.
public void sendRichSpittleEmailGeneratedByVelocity(String to, Spittle spittle) throws MessagingException, VelocityException {
    MimeMessage message = mailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(message, true);
    helper.setFrom("13928882387@163.com");
    helper.setTo(to);
    helper.setSubject("New spittle from " + spittle.getSpitter().getFullName());
    Map<String, Object> model = new HashMap<>();
    model.put("spitterName", spittle.getSpitter().getFullName());
    model.put("spittleText", spittle.getText());
    String emailText = VelocityEngineUtils.mergeTemplateIntoString(velocityEngine, "mail/emailTemplate.vm", model);
    helper.setText(emailText, true);
    ClassPathResource image = new ClassPathResource("/collateral/spittr_logo_50.png");
    helper.addInline("spitterLogo", image);
    mailSender.send(message);
}

8) The template is sitting at the email folder of the classpath in a file called emailTemplate.vm:
<html>
	<body>
		<img src='cid:spitterLogo'>
		<h1>${spitterName} says...</h1>
		<i>${spittleText}</i>
	</body>
</html>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Email offers many of the same asynchronous benefits as the messaging options, only with humans as the senders and receivers.
#Configuring Spring to send email
- a MailSender implementation sends email by connecting with an email server.
- Spring comes with one implementation of the MailSender interface, JavaMailSenderImpl, which uses the JavaMail API to send email.
#Configuring a mail sender
@Bean
public MailSender mailSender(Environment env) {
	JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
	mailSender.setHost(env.getProperty("mailserver.host"));
	mailSender.setPort(env.getProperty("mailserver.port"));
	mailSender.setUsername(env.getProperty("mailserver.username"));
	mailSender.setPassword(env.getProperty("mailserver.password"));
	return mailSender;
}
- By default, JavaMailSenderImpl assumes that the mail server is listening on port 25(the standard SMTP port)

- you may already have a javax.mail.MailSession configured in JNDI (or perhaps one was placed there by your application server). you can configure MailSender
to use the MailSession you have ready to use from JNDI.

@Bean
public JndiObjectFactoryBean mailSession() {
	JndiObjectFactoryBean jndi = new JndiObjectFactoryBean();
	jndi.setJndiName("mail/Session");
	jndi.setProxyInterface(MailSession.class);
	jndi.setResourceRef(true);
	return jndi;
}

in xml:
<jee:jndi-lookup id="mailSession" jndi-name="mail/Session" resource-ref="true" />

- wire mail session bean into the mailSender bean
like this:
@Bean
public MailSender mailSender(MailSession mailSession) {
	JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
	mailSender.setSession(mailSession);
	return mailSender;
}

#Wiring and using the mail sender
@Autowired
JavaMailSender mailSender;
- Sending email with Spring using a MailSender
public void sendSimpleSpittleEmail(String to, Spittle spittle) {
	SimpleMailMessage message = new SimpleMailMessage();		//Construct message
	String spitterName = spittle.getSpitter().getFullName();
	message.setFrom("noreply@spitter.com");						//Address email
	message.setTo(to);
	message.setSubject("New spittle from " + spitterName);
	message.setText(spitterName + " says: " + spittle.getText()); //Set message text
	mailSender.send(message);			//Send email
}

#Constructing rich email messages
#Adding attachments
- The trick to sending email with attachments is to create multipart messages—email messages composed of multiple parts, one of which is the body and the other parts being the attachments.
- To send multipart email messages, you need to create a Multipurpose Internet Mail Extensions (MIME) message.
MimeMessage message = mailSender.createMimeMessage();
- The javax.mail.internet.MimeMessage class has an API that’s too cumbersome to use on its own. Fortunately, Spring provides MimeMessageHelper to lend a hand.
MimeMessageHelper helper = new MimeMessageHelper(message, true); 		//true indicates that this is to be a multipart message.
String spitterName = spittle.getSpitter().getFullName();
helper.setFrom("noreply@spitter.com");
helper.setTo(to);
helper.setSubject("New spittle from " + spitterName);
helper.setText(spitterName + " says: " + spittle.getText());
- using Spring’s FileSystemResource to load coupon.png from within the application’s classpath, pass that resource in as you call the helper’s addAttachment()
FileSystemResource couponImage = new FileSystemResource("/collateral/coupon.png");
helper.addAttachment("Coupon.png", couponImage);

- Sending email messages with attachments using MimeMessageHelper
public void sendSpittleEmailWithAttachment(String to, Spittle spittle) throws MessagingException {
	MimeMessage message = mailSender.createMimeMessage();
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	String spitterName = spittle.getSpitter().getFullName();
	helper.setFrom("noreply@spitter.com");
	helper.setTo(to);
	helper.setSubject("New spittle from " + spitterName);
	helper.setText(spitterName + " says: " + spittle.getText());
	FileSystemResource couponImage = new FileSystemResource("/collateral/coupon.png");
	helper.addAttachment("Coupon.png", couponImage);
	mailSender.send(message);
}

#Sending email with rich content
- Sending rich email's key is to set the message’s text as HTML.
helper.setText("<html><body><img src='cid:spitterLogo'>" +
	"<h4>" + spittle.getSpitter().getFullName() + " says...</h4>" +
	"<i>" + spittle.getText() + "</i>" +
	"</body></html>", true);			//indicates that the text passed in to the first parameter is HTML
- you embed the logo image in the email message. The value cid:spitterLogo indicates that there will be an image in one of the message’s parts identified as spitterLogo. Adding the embedded image to the message is much like adding an attachment.
ClassPathResource image = new ClassPathResource("spitter_logo_50.png");
helper.addInline("spitterLogo", image);
- The first parameter to addInline specifies the identity of the inline image
- The second parameter is the resource reference for the image, created here using Spring’s ClassPathResource to retrieve the image from the application’s classpath.

public void sendRichSpitterEmail(String to, Spittle spittle) throws MessagingException {
	MimeMessage message = mailSender.createMimeMessage();
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	helper.setFrom("noreply@spitter.com");
	helper.setTo("craig@habuma.com");
	helper.setSubject("New spittle from " + spittle.getSpitter().getFullName());
	helper.setText("<html><body><img src='cid:spitterLogo'>" +
		"<h4>" + spittle.getSpitter().getFullName() + " says...</h4>" +
		"<i>" + spittle.getText() + "</i>" +
		"</body></html>", true);
	ClassPathResource image = new ClassPathResource("spitter_logo_50.png");
	helper.addInline("spitterLogo", image);
	mailSender.send(message);
}

#Generating email with templates
- The problem with constructing an email message using string concatenation is that it’s not clear what the resulting message will look like. It’s hard enough to mentally parse HTML markup to imagine how it might appear when rendered.
- it might be nice to extract the email layout into a template that a graphic designer (who probably has an aversion to Java code) can produce.
- What you need is a way to express the email layout in something close to what the resulting HTML will look like, and then transform that template into a String to be passed into the setText() method on the message helper.

#Constructing email messages with Velocity
- Apache Velocity is a general-purpose templating engine from Apache. 
- Velocity has been around for quite a while and has been used for all kinds of things, including code generation and as an alternative to JSP. It can also be used to format rich email messages
- first need to wire a VelocityEngine into SpitterEmailServiceImpl.
- Spring provides a handy factory bean called VelocityEngineFactoryBean that produces a VelocityEngine in the Spring application context.
@Bean
public VelocityEngineFactoryBean velocityEngine() {
	VelocityEngineFactoryBean velocityEngine = new VelocityEngineFactoryBean();
	Properties props = new Properties();
	props.setProperty("resource.loader", "class");
	props.setProperty("class.resource.loader.class", ClasspathResourceLoader.class.getName());
	velocityEngine.setVelocityProperties(props);
	return velocityEngine;
}

- In this case, you’re configuring it to load Velocity templates from the classpath (see the Velocity documentation for more details on how to configure Velocity).
- wire the Velocity engine into SpitterEmailServiceImpl
@Autowired
VelocityEngine velocityEngine;
- use the velocityEngine property to transform a Velocity template into a String to send as your email text. Spring comes with VelocityEngineUtils to make simple work of merging a Velocity template and some model data into a String.
Map<String, String> model = new HashMap<String, String>();
	model.put("spitterName", spitterName);
	model.put("spittleText", spittle.getText());
	String emailText = VelocityEngineUtils.mergeTemplateIntoString(velocityEngine, "emailTemplate.vm", model);
helper.setText(emailText, true);

- The template is sitting at the root of the classpath in a file called emailTemplate.vm:
<html>
	<body>
		<img src='cid:spitterLogo'>
		<h4>${spitterName} says...</h4>
		<i>${spittleText}</i>
	</body>
</html>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
总而言之 (Using Thymeleaf to create email messages)
1）Thymeleaf is an attractive templating engine for HTML because it enables you to create WYSIWYG templates.
2）Unlike JSP and Velocity, Thymeleaf templates don’t contain any special tag libraries or unusual markup. This makes it easy for template designers to use any HTML tools to display:
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
	<body>
		<img src="spitterLogo.png" th:src='cid:spitterLogo'>
		<h4><span th:text="${spitterName}">Craig Walls</span> says...</h4>
		<i><span th:text="${spittleText}">Hello there!</span></i>
	</body>
</html>
- model attributes are referenced with ${} notation and confined to values of attribute
3) Update SpringTemplateEngine bean’s configuration: the Thymeleaf engine is the same SpringTemplateEngine bean that you configured for constructing web views in Spring MVC.
3.1) declare a ClassLoaderTemplateResolver: SpringTemplateEngine bean used in Spring MVC is only configured to resolve templates from the servlet context. Your email templates will need to be resolved from the classpath.
@Bean
public ClassLoaderTemplateResolver emailTemplateResolver() {
    ClassLoaderTemplateResolver resolver = new ClassLoaderTemplateResolver();
    resolver.setPrefix("mail/"); //indicating that Thymeleaf templates is in the mail directory rooted at the classpath root
    resolver.setTemplateMode("HTML5");
    resolver.setCharacterEncoding("UTF-8");
    resolver.setOrder(1);
    return resolver;
}
3.2) because now you have two template resolvers, you need to indicate the order, the ClassLoaderTemplateResolver bean has its order as 1. Tweak the ServletContextTemplateResolver configuration, setting its order to 2:
@Bean
public ServletContextTemplateResolver webTemplateResolver() {
    ServletContextTemplateResolver resolver = new ServletContextTemplateResolver();
    resolver.setPrefix("/WEB-INF/templates/");
    resolver.setTemplateMode("HTML5");
    resolver.setCharacterEncoding("UTF-8");
    resolver.setOrder(2);
    return resolver;
}
3.3) change the SpringTemplateEngine bean’s configuration to use both of your template resolvers:
@Bean
public SpringTemplateEngine templateEngine(Set<ITemplateResolver> resolvers) {
	SpringTemplateEngine engine = new SpringTemplateEngine();
	engine.setTemplateResolvers(resolvers);
	return engine;
}
4) Using Thymeleaf to generate and send HTML email messages is similar to what you did with Velocity:
@Override
public void sendRichSpittleEmailGeneratedByThymleaf(String to, Spittle spittle) throws MessagingException {
    MimeMessage message = mailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(message, true);
    helper.setFrom("13928882387@163.com");
    helper.setTo(to);
    helper.setSubject("New spittle from " + spittle.getSpitter().getFullName());
    Context ctx = new Context();
    ctx.setVariable("spitterName", spittle.getSpitter().getFullName());
    ctx.setVariable("spittleText", spittle.getText());
    String emailText = thymeleaf.process("emailTemplate.html", ctx);		//use Thymeleaf engine process the tempalte
    System.out.println(emailText);
    helper.setText(emailText, true);
    ClassPathResource image = new ClassPathResource("/collateral/spittr_logo_50.png");
    helper.addInline("spitterLogo", image);
    mailSender.send(message);
}

4.2) email template file must be named emailTemplate.html and reside in the mail directory relative to the root of the classpath.
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
	<body>
		<img src='cid:spitterLogo'/>
		<h4><span th:text="${spitterName}">Craig Walls</span> says...</h4>
		<i><span th:text="${spittleText}">Hello there!</span></i>
	</body>
</html>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#Using Thymeleaf to create email messages
- Thymeleaf is an attractive templating engine for HTML because it enables you to create WYSIWYG templates.
- Unlike JSP and Velocity, Thymeleaf templates don’t contain any special tag libraries or unusual markup. This makes it easy for template designers to use any HTML tools they like in their work without worrying about a tool’s inability to deal with special markup
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
	<body>
		<img src="spitterLogo.png" th:src='cid:spitterLogo'>
		<h4><span th:text="${spitterName}">Craig Walls</span> says...</h4>
		<i><span th:text="${spittleText}">Hello there!</span></i>
	</body>
</html>

- no custom tags (as you might see in JSP).
- although model attributes are referenced with ${} notation, it’s confined to values of attributes instead of being out in the open as with Velocity.
- This template could easily be opened in a web browser and viewed in its complete form without relying on the Thymeleaf engine to process it.
- Using Thymeleaf to generate and send HTML email messages is similar to what you did with Velocity:
Context ctx = new Context();
ctx.setVariable("spitterName", spitterName);
ctx.setVariable("spittleText", spittle.getText());
String emailText = thymeleaf.process("emailTemplate.html", ctx);		//use Thymeleaf engine process the tempalte
...
helper.setText(emailText, true);
mailSender.send(message);

- The Thymeleaf engine here is the same SpringTemplateEngine bean that you configured for constructing web views in chapter 6.

@Autowired
private SpringTemplateEngine thymeleaf;

@Autowired
public SpitterEmailServiceImpl(SpringTemplateEngine thymeleaf) {
	this.thymeleaf = thymeleaf;
}

- SpringTemplateEngine bean, as you left it in chapter 6, it’s only configured to resolve templates from the servlet context. Your email templates will need to be resolved from the classpath.
@Bean
public ClassLoaderTemplateResolver emailTemplateResolver() {
	ClassLoaderTemplateResolver resolver = new ClassLoaderTemplateResolver();
	resolver.setPrefix("mail/");
	resolver.setTemplateMode("HTML5");
	resolver.setCharacterEncoding("UTF-8");
	setOrder(1);
	return resolver;
}

- For the most part, you’ll configure the ClassLoaderTemplateResolver bean just as you did ServletContextTemplateResolver
- the prefix property is set to mail/, indicating that it expects to find Thymeleaf templates in the mail directory rooted at the classpath root.
- Therefore, your email template file must be named emailTemplate.html and reside in the mail directory relative to the root of the classpath.
- because you’ll now have two template resolvers, you need to indicate which one takes precedence, using the order property.
- The ClassLoaderTemplateResolver bean has its order as 1. Tweak the ServletContextTemplateResolver configuration, setting its order to 2:

@Bean
public ServletContextTemplateResolver webTemplateResolver() {
	ServletContextTemplateResolver resolver = new ServletContextTemplateResolver();
	resolver.setPrefix("/WEB-INF/templates/");
	resolver.setTemplateMode("HTML5");
	resolver.setCharacterEncoding("UTF-8");
	setOrder(2);
	return resolver;
}

- change the SpringTemplateEngine bean’s configuration to use both of your template resolvers:
@Bean
public SpringTemplateEngine templateEngine(Set<ITemplateResolver> resolvers) {
	SpringTemplateEngine engine = new SpringTemplateEngine();
	engine.setTemplateResolvers(resolvers);
	return engine;
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>











