Chapter1 Introduction
#Maven是构建工具
总而言之

- Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理
1）项目构建：
1.1) Maven是一个标准化，跨平台，开放式（plugin），构建自动化工具
1.2）build: Compiling、unit testing、documentation、packaging and deployment (besides coding)
1.3) build automation: use software to automate the process, just one command to execute
1.4) automated：automate build process，从clean, compile, test, generate report, package and deploy. No need to enter command again and again, just use Maven配置好项目，then use mvn clean  install.., Maven会帮我们处理那些烦琐的任务。
1.5) portable： 这意味着无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。
1.6) Standardized： Maven抽象了一个完整的构建生命周期模型，这个模型吸取了大量其他的构建脚本和构建工具的优点，总结了大量项目的实际需求。如果遵循这个模型，可以避免很多不必要的错误，可以直接使用大量成熟的Maven插件来完成我们的任务（很多时候我们可能都不知道自己在使用Maven插件）。
1.7) Open：如果有非常特殊的需求，我们也可以轻松实现自己的插件。

2) Dependency Management
2.1) Maven通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。
3.2) Maven还为全世界的Java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源类库。通过一些Maven的衍生工具（如Nexus），我们还能对其进行快速地搜索。只要定位了坐标，Maven就能够帮我们自动下载，省去了手工劳动。

3) 项目信息管理
3.1) (in POM.xml)Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等
3.2) 除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。

4) Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置（Convention Over Configuration）。

5) Maven vs. IDE, Make, Ant
5.1) - shell script (require shell skills, error-prone) -> Make (target/prerequisite/shell command) -> Ant (java version of make)  -> reuse Ant script -> standardized ant script -> Maven (standardize build process/plugins/convention) -> Gradle (integrated dependency management/groovy)


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1) Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理
2) Build: 除了编写源代码，我们每天有相当一部分时间花在了Compiling、unit testing、documentation、packaging and deployment等烦琐且不起眼的工作上，这就是构建
3) Build autotation: 如果我们现在还手工这样做，那成本也太高了，于是有人用软件的方法让这一系列工作完全自动化，使得软件的构建可以像全自动流水线一样，只需要一条简单的命令，所有烦琐的步骤都能够自动完成，很快就能得到最终结果。
4) Why Maven?: automate build process，从clean, compile, test, generate report, package and deploy. No need to enter command again and again, just use Maven配置好项目，then use mvn clean  install.., Maven会帮我们处理那些烦琐的任务。
5) Maven是跨平台的，这意味着无论是在Windows上，还是在Linux或者Mac上，都可以使用同样的命令。
6) Maven最大化地消 除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要
再去实现这些过程中的一些任务。
7) 最简单的例子是测试，我们没必要告诉Maven去测试，更不需要告诉Maven如何运行测试，只需要遵循Maven的约定编写好测试用例，当我们运行构建的时候，这些测试便会自动运行。
8) Maven抽象了一个完整的构建生命周期模型，这个模型吸取了大量其他的构建脚本和构建工具的优点，总结了大量项目的实际需求。如果遵循这个模型，可以避免很多不必要的错误，可以直接使用大量成熟的Maven插件来完成我们的任务（很多时候我们可能都不知道自己在使用Maven插件）。
9) 此外，如果有非常特殊的需求，我们也可以轻松实现自己的插件。
10) Maven还有一个优点，它能帮助我们标准化构建过程, 构建步骤和构建命令都是简单一致

#Maven不仅仅是构建工具
- Maven提 供了一个优秀的解决方案，它通过一个坐标系统准确地定位每一个构件（artifact），也就是通过一组坐标Maven能够找到任何一个Java类库（如jar文件）。
- Maven给这个类库世界引入了经纬，让它们变得有秩序，于是我们可以借助它来有序地管理依赖，轻松地解决那些繁杂的依赖问题。
- Maven还能帮助我们管理原本分散在项目中各个角落的项目信息，包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等
- 除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，我们还能够轻松获得项目文档、测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。
- Maven还为全世界的Java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源类库。通过一些Maven的衍生工具（如Nexus），我们还能对其进行快速地搜索。只要定位了坐标，Maven就能够帮我们自动下载，省去了手工劳动。
- Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置（Convention Over Configuration）。

#Maven vs. IDE, Make, Ant
- Maven vs. custom script:用脚本建立高度自定义的构建系统就像买组装PC，耗时费力，结果也不一定很好。使用Maven就像购买品牌PC，省时省力，并能得到成熟的构建系统，还能得到来自于Maven社区的大量支持。
- Maven vs. IDE: IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的，很难一键完成所有工作;很难在项目中统一所有的IDE配置; 而且主流IDE都集成了Maven，我们可以在IDE中方便地运行Maven执行构建。
- Maven vs Make: Make通过一系列目标和依赖将整个构建过程串联起来，同时利用本地命令完成每个目标的实际行为;Make的强大之处在于
它可以利用所有系统的本地命令，尤其是UNIX/Linux系统，丰富的功能、强大的命令能够帮助Make快速高效地完成任务;但是，Make将自己和操作系统绑定在一起了。也就是说，使用Make，就不能实现（至少很难）跨平台的构建
- Ant: Ant不是指蚂蚁，而是意指“另一个整洁的工具”（Another Neat Tool)创作它的动机就是因为受不了Makefile的语法格式。 我们可以将Ant看成是一个Java版本的Make，也正因为使用了Java，Ant是跨平台的。此外，Ant使用XML定义构建脚本，相对于Makefile来说，这也更加友好。 
- 与Make类似，Ant有一个构建脚本build.xml, build.xml的基本结构也是目标（target）、依赖（depends），以及实现目标的任务。
- Ant有大量内置的用Java实现的任务，这保证了其跨平台的特质，同时，Ant也有特殊的任务exec来执行本地命令。
- 和Make一样，Ant也都是过程式的，开发者显式地指定每一个目标，以及完成该目标所需要执行的任务。针对每一个项目，开发者都需要重新编写这一过程，这里其实隐含着很大的重复
- Ant打包，无非就是创建目录，复制文件，编译源代码，使用一堆任务，如copydir、fileset、classpath、ref、target，然后再jar、zip、war，打包就成功了。
- Maven是声明式的，项目构建过程和过程各个阶段所需的工作都由插件实现，并且大部分插件都是现成的，开发者只需要声明项目的基本元素，Maven就执行内置的、完整的构建过程。这在很大程度上消除了重复。
- shell script (require shell skills) -> Make (target/prerequisite/shell command) -> Ant (java version of make)  -> reuse Ant script -> standardized ant script -> Maven (standardize build process/plugins/convention) -> Gradle (integrated dependency management/groovy)

#Gradle
1.一种可切换的，像maven一样的基于约定的构建框架，却又从不锁住你（约定优于配置）
2. 强大的支持多工程的构建
3. 强大的依赖管理（基于Apache Ivy），提供最大的便利去构建你的工程
4. 全力支持已有的Maven或者Ivy仓库基础建设, 支持多方式依赖管理：包括从maven远程仓库、nexus私服、ivy仓库以及本地文件系统的jars或者dirs
5. 支持传递性依赖管理，在不需要远程仓库和pom.xml和ivy配置文件的前提下
6 基于groovy脚本构建，其build脚本使用groovy语言编写
7 具有广泛的领域模型支持你的构建


#Maven与XP(SCRUM as well)
- 测试驱动开发 （TDD）
- 十分钟构建
- 持续集成
- 富有信息的工作区

#Maven's problem
- “Maven对于IDE（如Eclipse和IDEA）的支持较差，bug多，而且不稳定。”
- “Maven采用了一个糟糕的插件系统来执行构建，新的、破损的插件会让你的构建莫名其妙地失败。”
- “Maven过于复杂，它就是构建系统的EJB 2。”
- “Maven的仓库十分混乱，当无法从仓库中得到需要的类库时，我需要手工下载复制到本地仓库中。”
- “缺乏文档是理解和使用Maven的一个主要障碍！”
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 2 Maven的安装和配置
总而言之
1）install JDK/JDK_HOME/path
2）install Maven/MAVEN_HOME/path
3) super POM: $MAVEN_HOME/lib/maven-model-builder-3.5.0.jar的\org\apache\maven\model\pom-4.0.0.xml.
4) ~/.m2: 默认情况下，该文件夹下放置了Maven本地仓库.m2/repository
5) 所有的Maven构件(plugins and dependency)都被存储到该仓库中，以方便重用。
6) 大多数Maven用户需要复制MAVEN_HOME/conf/settings.xml文件到~/.m2/settings.xml。
7) http proxy: 有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网, edit <proxies><proxy>...</proxy></proxies> in settings.xml
8) best practices: 
8.1) 设置MAVEN_OPTS环境变量: 通常需要设置MAVEN_OPTS的值为-Xms128m-Xmx512m，因为Java默认的最大可用内存往往不能够满足Maven运行的需要，比如在项目较大时，使用Maven生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到java.lang.OutOfMemeoryError。参考前面设置MAVEN_HOME环境变量的做法.
8.2) 配置用户范围settings.xml: 主要是为了避免无意识地影响到系统中的其他用户；配置用户范围settings.xml文件还便于Maven升级。
8.3）不要使用IDE内嵌的Maven
- 应该在IDE中配置Maven插件时使用与命令行一致的Maven。
9) maven最重要的配置文件： settings.xml, pom.xml, super pom
9.1) super pom: global level config, such as central repository, default plugin??, default plugin config??
9.2）settings.xml: global level or user level custom settings, such as local repository, http proxy, server authentication(for remote dependency repository and distribution repository), mirrors of repository, remote repositories(dependency and plugin) other than central...
9.3) pom.xml: project level config: artifact coordinate, dependency, plugins, remote repositories(dependency and plugin) other than central， distributionManagement/repository

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#在Windows上安装Maven
1) 安装JDK， JAVA_HOME， path
echo %JAVA_HOME%
echo %path%
java -version
2) download Maven apache-maven-3.X-bin.zip
3) install Maven: 
echo %MAVEN_HOME%
add %MAVEN_HOME%\bin to path variable
mvn -v
4) upgrade Maven:
**down and install new version. change MAVEN_HOME to point to the new version.

#Unix installation
1) 安装JDK， JAVA_HOME， path
echo $JAVA_HOME
echo $path
java -version
2) download apache-maven-3.x-bin.tar.gz
- tar -xvzf apache-maven-3.x-bin.tar.gz
3) install Maven: 
- 虽然直接使用该目录配置环境变量之后就能使用Maven了，但这里的推荐做法是，在安装目录旁平行地创建一个符号链接，以方便日后的升级：
ln -s apache-maven-3.0 apache-maven
export MAVEN_HOME=/home/atwjsw/bin/apache-maven （MAVEN_HOME指向符号链接）
export PATH=$PATH:$MAVEN_HOME/bin
echo $MAVEN_HOME
mvn -v
- 一般来说，需要将这两行命令加入到系统的登录shell脚本中去，以Ubuntu 8.10为例，编辑~/.bashrc文件，添加这两行命令。这
样，每次启动一个终端，这些配置就能自动执行。
4) upgrade Maven:
**download and install new version. change MAVEN_HOME to point to the new version.
- 在基于UNIX的系统上，可以利用符号链接这一工具来简化Maven的升级，不必像在Windows上那样，每次升级都必须更新环境变量。
- 假设需要升级到新的Maven 3.1版本，将安装包解压到与前一版本平行的目录下，然后更新符号链接指向3.1版的目录便可：
rm apache-maven
ln -s apache-maven-3.1 apache-maven

#安装目录分析
- bin：该目录包含了mvn运行的脚本，这些脚本用来配置Java命令，准备好classpath和相关的Java系统属性，然后执行Java命
令。 其中mvn是基于UNIX平台的shell脚本，mvn.bat是基于Windows平台的bat脚本。该目录还包含了mvnDebug和mvnDebug.bat两个文件，mvnDebug多了一条MAVEN_DEBUG_OPTS配置，其作用就是在运行Maven时开启debug，以便调试Maven本身。此外，该目录还包含m2.conf文件，这是classworlds的配置文件，后面会介绍classworlds。
- boot：该目录只包含一个文件plexus-classworlds-2.2.3.jar。 plexus-classworlds是一个类加载器框
架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。对于一般的Maven用户来说，不必关心该文件- conf：该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为。一般情况
下，我们更偏向于复制该文件至~/.m2/目录下（~表示用户目录），然后修改该文件，在用户范围定制Maven的行为。后面将会多
次提到settings.xml，并逐步分析其中的各个元素。
- lib：该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、
maven-model-3.0.jar之类的文件。此外，这里还包含一些Maven用到的第三方依赖，如common-cli-1.2.jar、google-collection-1.0.jar
等。 可以说，lib目录就是真正的Maven。关于该文件，还有一点值得一提的是，用户可以在这个目录中找到Maven内置的超级POM，

#~/.m2
- 在用户目录下可以发现.m2文件夹。默认情况下，该文件夹下放置了Maven本地仓库.m2/repository。
- 所有的Maven构件都被存储到该仓库中，以方便重用。可以到~/.m2/repository/org/apache/maven/plugins/maven-help-plugins/目录下找到刚才下载的maven-helpplugin的pom文件和jar文件。Maven根据一套规则来确定任何一个构件在仓库中的位置，
- 默认情况下，~/.m2目录下除了repository仓库之外就没有其他目录和文件了，不过大多数Maven用户需要复制M2_HOME/conf/settings.xml文件到~/.m2/settings.xml。

#设置HTTP代理
- 有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网。这种情况下，就需要为Maven配置
HTTP代理，才能让它正常访问外部仓库，以下载所需要的资源。
- 如果真的需要代理，先检查一下代理服务器是否畅通。比如现在有一个IP地址为218.14.227.197，端口为3128的代理服务，我们可以运行telnet
218.14.227.1973128来检测该地址的该端口是否畅通。
- 检查完毕之后，编辑~/.m2/settings.xml文件（如果没有该文件，则复制＄MAVEN_HOME/conf/settings.xml）。添加代理配置如下：
<proxies>
	<proxy>
		<id>my-proxy</id>
		...
	</proxy>		
</proxies>

#安装m2eclipse
- 由Maven之父Jason sVan Zyl创立的Sonatype公司建立了m2eclipse项目。这是Eclipse下的一款十分强大的Maven插件

#Maven安装最佳实践
#设置MAVEN_OPTS环境变量
- 前面介绍Maven安装目录时我们了解到，运行mvn命令实际上是执行了Java命令，既然是运行Java，那么运行Java命令可用的参数当然也应该在运行mvn命令时可用。这个时候，MAVEN_OPTS环境变量就能派上用场。
- 通常需要设置MAVEN_OPTS的值为-Xms128m-Xmx512m，因为Java默认的最大可用内存往往不能够满足Maven运行的需要，比如在项目较大时，使用Maven生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到java.lang.OutOfMemeoryError。因此，一开始就配置该变量是推荐的做法。
- 关于如何设置环境变量，请参考前面设置MAVEN_HOME环境变量的做法，尽量不要直接修改mvn.bat或者mvn这两个Maven执行脚本文件。因为如果修改了脚本文件，升级Maven时就不得不再次修改，一来麻烦，二来容易忘记。同理，应该尽可能地不去修改任何Maven安装目录下的文件。

#配置用户范围settings.xml
- Maven用户可以选择配置＄MAVEN_HOME/conf/settings.xml或者~/.m2/settings.xml。前者是全局范围的，整台机器上的所有用户都会
直接受到该配置的影响，而后者是用户范围的，只有当前用户才会受到该配置的影响。
- 推荐使用用户范围的settings.xml，主要是为了避免无意识地影响到系统中的其他用户。如果有切实的需求，需要统一系统中所有用户的settings.xml配置，当然应该使用全局范围的settings.xml。
- 除了影响范围这一因素，配置用户范围settings.xml文件还便于Maven升级。直接修改conf目录下的settings.xml会导致Maven升级不便，每次升级到新版本的Maven，都需要复制settings.xml文件。如果使用~/.m2目录下的settings.xml，就不会影响到Maven安装文件，升级时就不需要触动settings.xml文件。

#不要使用IDE内嵌的Maven
- 应该在IDE中配置Maven插件时使用与命令行一致的Maven。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter3 Maven使用入门
总而言之
1）就像Make的Makefile、Ant的build.xml一样，Maven项目的核心是pom.xml
2）POM（Project Object Model，项目对象模型）定义了项目的基本信息（coordinate...），用于描述项目如何构建(build/plugin)，声明项目依赖(depndency)
3) 代码的第一行是XML头，指定了该xml文档的版本和编码方式
4) project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具（如IDE中的XML编辑器）帮助我们快速编辑POM。
5) project info:
5.1) modelVersion指定了当前POM模型的版本，对于Maven 2及Maven 3来说，它只能是4.0.0
5.2) groupId、artifactId和version的三行。这三个元素定义了一个项目基本的坐标
5.2.1) groupId: Maven项目属于哪个组, org.springframework, org.junit, com.googlecode.myapp, org.atwjsw.mia...
5.2.2) artifactId: 定义了当前Maven项目在组中唯一的ID，spring-webmvc, spring-core, spring-context...
5.2.3) version: 指定了项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等
5.2.4) name: 声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name，以方便信息交流。
6) source structure: 
6.1) 项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（如jar），而测试代码只在运行测试时用到，不会被打包。
6.2) 在绝大多数情况下，应该把项目主代码放到src/main/java/目录下（遵循Maven的约定），而无须额外的配置，Maven会自动搜寻该目录找到项目主代码。
6.3) Java类的包名使用groupId+artifactId, e.g. org.springframework.spring-core, 一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者Java类。
6.4) 测试代码: 为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中, Maven项目中默认的测试代码目录是src/test/java。
7) dependency:
7.1) In pom.xml: add<dependencies><dependency>....</dependency></dependencies>
7.2) scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效。 
7.3) 换句话说，测试代码中的import JUnit代码是没有问题的，但是如果在主代码中用import JUnit代码，就会造成编译错误。
7.4) 如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。
7.5) Maven就能够自动下载junit-4.12.jar。在Maven之前，可以去JUnit的官方网站下载分发包，有了Maven，它会自动访问中央仓库（http://repo1.maven.org/maven2/ ），下载需要的文件。
7.6) 可以自己访问该仓库，打开路径junit/junit/4.7/，就能看到junit-4.12.pom和junit-4.12.jar
8) compile: 执行mvn clean compile
8.1) clean告诉Maven删除输出目录target/，默认情况下， Maven构建的所有输出都在target/目录中
8.2）接着执行resources：resources任务（未定义项目资源，暂且略过）； 
8.3）compile告诉Maven编译项目主代码。 执行compiler：compile任务， 将项目主代码编译至target/classes目录（编译好的类为org/atwjsw/mia/helloworld/HelloWorld.Class）。
8.4）上文提到的clean：clean、resources：resources和compiler：compile对应了一些Maven插件及插件目标，比如clean：clean是clean插
件的clean目标，compiler：compile是compiler插件的compile目标
8.5）clean插件： maven-clean-plugin:2.5:clean (default-clean) @ hello-world 
8.6）resources插件： maven-resources-plugin:2.6:resources (default-resources) @ hello-world 
8.7）compiler插件： maven-compiler-plugin:3.1:compile (default-compile) @ hello-world
9）test: 执行mvn clean test
9.1) steps
clean:clean 
resoueces:resources 
compiler:compile
*resource:testResouces maven-resources-plugin:2.6:testResources (default-testResources) @ hello-world ---
*compile:testCompile   maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello-world ---
*surefire:test       maven-surefire-plugin:2.12.4:test (default-test) @ hello-world ---
9.2) 在Maven执行测试（test）之前，它会先自动执行项目主资源处理、主代码编译、测试资源处理、测试代码编译等工作，这是Maven生命周期的一个特性
9.3 配置maven-compiler-plugin支持Java 5 (由于Maven3.0默认支持JDK1.3，而junit4需要@Test annotation)
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
10) package: mvn clean package
10.1) POM中没有指定打包类型，使用默认打包类型jar。\
10.2) steps： 比test多一步jar:jar 
clean:clean       
resoueces:resources   
compiler:compile    
resource:testResouces 
compile:testCompile   
surefire:test
jar:jar         maven-jar-plugin:2.4:jar (default-jar) @ hello-world
10.3） jar：jar任务负责打包，实际上就是jar插件的jar目标，将项目主代码打包成一个名为hello-world-1.0-SNAPSHOT.jar的文件。
10.4）该文件也位于target/输出目录中，它是根据artifact-version.jar规则进行命名的，如有需要，还可以使用finalName来自定义该文件的名称.
11）install: mvn clean install
11.1) 为了让其他的Maven项目直接引用这个jar，还需要一个安装的步骤：
11.2) steps: 比package多一步install:install
clean:clean       
resoueces:resources   
compiler:compile    
resource:testResouces 
compile:testCompile   
surefire:test
jar:jar
install:install maven-install-plugin:2.4:install (default-install) @ hello-world
11.3) 该任务将项目输出的jar安装到了Maven本地仓库中，可以打开相应的文件夹看到HelloWorld项目的pom和jar。
11.4) 只有构件被下载到本地仓库后，才能由所有Maven项目使用, 也只有将HelloWorld的构件安装到本地仓库之后，其他Maven项目才能使用它。
12) run: 
12.1) 默认打包生成的jar是不能够直接运行的，因为带有main方法的类信息不会添加到manifest中（打开jar文件中的META-INF/MANIFEST.MF文件， 将无法看到Main-Class一行）
12.2)为了生成可执行的jar文件，需要借助maven-shade-plugin，replacing original artifact with shaded artifact：
<plugin>
   <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-shade-plugin</artifactId>
   <version>1.2.1</version>
   <executions>
     <execution>
       <phase>package</phase>
       <goals>
         <goal>shade</goal>
       </goals>
       <configuration>
         <transformers>
           <transformplementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
             <mainClass>org.atwjsw.mia.helloworld.HelloWorld</mainClass>
           </transformer>
         </transformers>
       </configuration>
     </execution>
   </executions>
</plugin>
12.3) mvn clean install
clean:clean             
resoueces:resources     
compiler:compile        
resource:testResouces   
compile:testCompile     
surefire:test
jar:jar
shade:shade maven-shade-plugin:1.2.1:shade (default) @ hello-world
install:install 
12.4) plugin元素在POM中的相对位置应该在<project><build><plugins>下面。 我们配置了mainClass为 org.atwjsw.mia.helloworld.HelloWorld， 项目在打包时会将该信息放到MANIFEST中。
12.5) java -jar target/hello-world-1.0-SNAPSHOT.jar => Hello Maven, 
12.6) 否则需要按如下方式运行: java -classpath target/hello-world-1.0-SNAPSHOT.jar org.atwjsw.mia.helloworld.HelloWorld

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 如果你是初次接触Maven，建议按照本章的内容一步步地编写代码并执行，其中可能你会碰到一些概念暂时难以理解，不用着急，记下这些疑难点，相信本书的后续章节会帮你逐一解答。
- 就像Make的Makefile、Ant的build.xml一样，Maven项目的核心是pom.xml
- POM（Project Object Model，项目对象模型）定义了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.atwjsw.mia</groupId>
    <artifactId>hello-world</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>Maven Hello World Project</name>  
</project>
- 代码的第一行是XML头，指定了该xml文档的版本和编码方式。
- 紧接着是project元素，project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具（如IDE中的XML编辑器）帮助我们快速编辑POM。
- 根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven 2及Maven 3来说，它只能是4.0.0。
- 最重要的是包含groupId、artifactId和version的三行。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者war都是以基于这些基本的坐标进行区分的。
- groupId定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联。譬如在googlecode上建立了一个名为myapp的项目，那么groupId就应该是com.googlecode.myapp，如果你的公司是mycom，有一个项目为myapp，那么groupId就应该是com.mycom.myapp。本书中所有的代码都基于groupId com.juvenxu.mvnbook。
- artifactId定义了当前Maven项目在组中唯一的ID，而在前面的groupId为com.googlecode.myapp的例子中，你可能会为不同的子项目（模块）分配artifactId，如myapp-util、myapp-domain、myapp-web等。
- version指定了Hello World项目当前的版本——1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version会不断更新，如升级为1.0、1.1-SNAPSHOT、1.1、2.0等。
- 最后一个name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name，以方便信息交流。
- 没有任何实际的Java代码，我们就能够定义一个Maven项目的POM，这体现了Maven的一大优点，它能让项目对象模型最大程度地与实际代码相独立，我们可以称之为解耦，或者正交性。这在很大程度上避免了Java代码和POM代码的相互影响。比如当项目需要升级版本时，只需要修改POM，而不需要更改Java代码；而在POM稳定之后，日常的Java代码开发工作基本不涉及POM的修改。

#编写主代码
- 项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中（如jar），而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven假设项目主代码位于src/main/java目录，我们遵循Maven的约定，创建该目录，然后在该目录下创建文件com/juvenxu/mvnbook/helloworld/HelloWorld.java，
package com.juvenxu.mvnbook.helloworld;

public class HelloWorld {

	public String sayHello()
	{
		return "Hello Maven";
	}
	
	public static void main(String[] args)
	{
		System.out.print( new HelloWorld().sayHello() );
	}
}
- 在绝大多数情况下，应该把项目主代码放到src/main/java/目录下（遵循Maven的约定），而无须额外的配置，Maven会自动搜寻该目录找到项目主代码。
- 其次，该Java类的包名是org.atwjsw.mia.helloworld，这与之前在POM中定义的groupId和artifactId相吻合。一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者Java类。

- 执行mvn clean compile
- clean告诉Maven清理输出目录target/，从输出中看到Maven首先执行了clean：clean任务，删除target/目录, 默认情况下， Maven构建的所有输出都在target/目录中
- 接着执行resources：resources任务（未定义项目资源，暂且略过）； 
- compile告诉Maven编译项目主代码。 最后执行compiler：compile任务， 将项目主代码编译至target/classes目录（编译好的类为org/atwjsw/mia/helloworld/HelloWorld.Class）。
- 上文提到的clean：clean、resources：resources和compiler：compile对应了一些Maven插件及插件目标，比如clean：clean是clean插
件的clean目标，compiler：compile是compiler插件的compile目标
- maven-clean-plugin:2.5:clean (default-clean) @ hello-world 
- maven-resources-plugin:2.6:resources (default-resources) @ hello-world 
- maven-compiler-plugin:3.1:compile (default-compile) @ hello-world

#编写测试代码
- 为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录中。
- Maven项目中默认的主代码目录是src/main/java，对应地，Maven项目中默认的测试代码目录是src/test/java。
- 添加junit
<dependencies>
  <dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
  </dependency>
</dependencies> 
- 有了这段声明，Maven就能够自动下载junit-4.7.jar。在Maven之前，可以去JUnit的官方网站下载分发包，有了Maven，它会自动访问中央仓库（http://repo1.maven.org/maven2/ ），下载需要的文件。
- 可以自己访问该仓库，打开路径junit/junit/4.7/，就能看到junit-4.7.pom和junit-4.7.jar
- 上述POM代码中还有一个值为test的元素scope，scope为依赖范围，若依赖范围为test则表示该依赖只对测试有效。 
- 换句话说，测试代码中的import JUnit代码是没有问题的，但是如果在主代码中用import JUnit代码，就会造成编译错误。
- 如果不声明依赖范围，那么默认值就是compile，表示该依赖对主代码和测试代码都有效。
- create test class:
package org.atwjsw.mia.helloworld;

import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class HelloWorldTest
{
    @Test
    public void testSayHello()
    {
        HelloWorld helloWorld = new HelloWorld();

        String result = helloWorld.sayHello();

        assertEquals( "Hello Maven", result );
    }
}
- 一个典型的单元测试包含三个步骤：①准备测试类及数据；②执行要测试的行为；③检查结果。
- mvn clean test
clean:clean 			maven-clean-plugin:2.5:clean (default-clean) @ hello-world ---
resoueces:resources 	maven-resources-plugin:2.6:resources (default-resources) @ hello-world ---
compiler:compile 		maven-compiler-plugin:3.1:compile (default-compile) @ hello-world ---
resource:testResouces	maven-resources-plugin:2.6:testResources (default-testResources) @ hello-world ---
compile:testCompile 	maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello-world ---
surefire:test 			maven-surefire-plugin:2.12.4:test (default-test) @ hello-world ---
- 在Maven执行测试（test）之前，它会先自动执行项目主资源处理、主代码编译、测试资源处理、测试代码编译等工作，这是Maven生命周期的一个特性
- 由于历史原因，Maven的核心插件之一——compiler插件默认只支持编译Java 1.3，因此需要配置该插件使其支持Java 5
2015-11-14	3.3.9	Java 7
2014-12-20	3.2.5	Java 6
2013-10-04	3.1.1	Java 5
- 配置maven-compiler-plugin支持Java 5
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>

#打包和运行
- 将项目进行编译、测试之后，下一个重要步骤就是打包（package）。
- Hello World的POM中没有指定打包类型，使用默认打包类型jar。
- mvn clean package
clean:clean 			
resoueces:resources 	
compiler:compile 		
resource:testResouces	
compile:testCompile 	
surefire:test
jar:jar  				maven-jar-plugin:2.4:jar (default-jar) @ hello-world
- Maven会在打包之前执行编译、测试等操作。这里看到jar：jar任务负责打包，实际上就是jar插件的jar目标将项目主代码打包成一个名为hello-world-1.0-SNAPSHOT.jar的文件。
- 该文件也位于target/输出目录中，它是根据artifact-version.jar规则进行命名的，如有需要，还可以使用finalName来自定义该文件的名称.

#install
- 我们得到了项目的输出，如果有需要的话，就可以复制这个jar文件到其他项目的Classpath中从而使用HelloWorld类。
- 如何才能让其他的Maven项目直接引用这个jar呢？还需要一个安装的步骤，执行mvn clean install：
mvn clean install
clean:clean 			
resoueces:resources 	
compiler:compile 		
resource:testResouces	
compile:testCompile 	
surefire:test
jar:jar
install:install maven-install-plugin:2.4:install (default-install) @ hello-world
- compile->test->package->install
- 该任务将项目输出的jar安装到了Maven本地仓库中，可以打开相应的文件夹看到HelloWorld项目的pom和jar。
- 只有构件被下载到本地仓库后，才能由所有Maven项目使用，只有将HelloWorld的构件安装到本地仓库之后，其他Maven项目才能使用它。

#run
- 默认打包生成的jar是不能够直接运行的，因为带有main方法的类信息不会添加到manifest中（打开jar文件中的META-INF/MANIFEST.MF文件，将无法看到Main-Class一行）
- 为了生成可执行的jar文件，需要借助maven-shade-plugin，Replacing original artifact with shaded artifact：
<plugin>
   <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-shade-plugin</artifactId>
   <version>1.2.1</version>
   <executions>
     <execution>
       <phase>package</phase>
       <goals>
         <goal>shade</goal>
       </goals>
       <configuration>
         <transformers>
           <transformplementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
             <mainClass>org.atwjsw.mia.helloworld.HelloWorld</mainClass>
           </transformer>
         </transformers>
       </configuration>
     </execution>
   </executions>
</plugin>
- mvn install again
clean:clean             
resoueces:resources     
compiler:compile        
resource:testResouces   
compile:testCompile     
surefire:test
jar:jar
shade:shade maven-shade-plugin:1.2.1:shade (default) @ hello-world
install:install 
- plugin元素在POM中的相对位置应该在<project><build><plugins>下面。我们配置了mainClass为 org.atwjsw.mia.helloworld.HelloWorld，项目在打包时会将该信息放到MANIFEST中。
- java -jar target/hello-world-1.0-SNAPSHOT.jar => Hello Maven, 否则需要按如下方式运行
- java -classpath target/hello-world-1.0-SNAPSHOT.jar org.atwjsw.mia.helloworld.HelloWorld
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#使用Archetype生成项目骨架
总而言之 (Archetype)
1) Maven的约定在项目的根目录中放置pom.xml，在src/main/java目录中放置项目的主代码，在src/test/java中放置项目的测试代码。
2) 这些基本的目录结构和pom.xml文件内容称为项目的骨架，为了避免重复创建基本结构，Maven提供了Archetype可以帮助我们迅速地构建起项目的骨架
3) 使用maven archetype来创建该项目的骨架, 实际上是在运行插件maven-archetype-plugin： mvn archetype:generate
archetype:generate          maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom
4) Archetype插件将根据我们提供的信息创建项目骨架。在当前目录下，Archetype插件会创建一个名为hello-world（我们定义的artifactId）的子目录，
5) 从中可以看到项目的基本结构：基本的pom.xml已经被创建，里面包含了必要的信息以及一个junit依赖；主代码目录src/main/java已经被创建，在该目录下还有一个Java类org.atwjsw.mia.helloworld.App，注意这里使用到了刚才定义的包名，而这个类也仅仅只有一个简单的输出Hello World！的main方法； 测试代码目录src/test/java也被创建好了，并且包含了一个测试用例org.atwjsw.mia.helloworld.AppTest。
6) 如果有很多项目拥有类似的自定义项目结构以及配置文件，则完全可以一劳永逸地开发自己的Archetype，然后在这些项目中使用自定义的Archetype来快速生成项目骨架。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Hello World项目中有一些Maven的约定：在项目的根目录中放置pom.xml，在src/main/java目录中放置项目的主代码，在src/test/java中放置项目的测试代码。
- 我们称这些基本的目录结构和pom.xml文件内容称为项目的骨架，为了避免重复创建基本结构，Maven提供了Archetype可以帮助我们迅速地构建起项目的骨架
- 使用maven archetype来创建该项目的骨架, 实际上是在运行插件maven-archetype-plugin：
mvn archetype:generate
archetype:generate          maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom
- Archetype插件将根据我们提供的信息创建项目骨架。在当前目录下，Archetype插件会创建一个名为hello-world（我们定义的artifactId）的子目录，从中可以看到项目的基本结构：基本的pom.xml已经被创建，里面包含了必要的信息以及一个junit依赖；主代码目录src/main/java已经被创建，在该目录下还有一个Java类org.atwjsw.mia.helloworld.App，注意这里使用到了刚才定义的包名，而这个类也仅仅只有一个简单的输出Hello World！的main方法；测试代码目录src/test/java也被创建好了，并且包含了一个测试用例org.atwjsw.mia.helloworld.AppTest。
- 如果有很多项目拥有类似的自定义项目结构以及配置文件，则完全可以一劳永逸地开发自己的Archetype，然后在这些项目中使用自定义的Archetype来快速生成项目骨架。

#m2eclipse简单使用
#导入Maven项目
#创建Maven项目
#运行mvn命令
in idea, open maven project window
- lifecycle 可以执行default goal
- plugin 可以执行individual goal
- Dependency可以看到transitive dependency
- 可以下载documentation和source code， 这样ctrl B就可以看到source code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter4　背景案例
- 简单的账户注册服务
- 不过本书的目的不在这个功能本身，我们需要一个像模像样的、有很多模块的系统来演示Maven很多非常酷的特性，同时，又不想引入一个拥有成千上万行代码的过于庞大的系统

Chapter5 坐标和依赖
总而言之 （coordinate)
1) Maven的一大功能是管理项目依赖。
2) 坐标: 为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。
3) 世界上任何一个构件都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupId、artifactId、version、packaging、classifier。
4) 例如，当需要使用Java5平台上TestNG的5.8版时，就告诉Maven：“groupId=org.testng；artifactId=testng；version=5.8；classifier=jdk15”，Maven就会从仓库中寻找相应的构件供我们使用。
5）in super POM, Maven内置了一个中央仓库的地址（http://repo1.maven.org/maven2), 包含了世界上大部分流行的开源项目构件， Maven会在需要的时候去那里下载
6) 在我们开发自己项目的时候，也需要为其定义适当的坐标，这是Maven强制要求的。在这个基础上，其他Maven项目才能引用该项目生成的构件
7) 坐标详解
7.1) Maven坐标是通过一些元素定义的，groupId、artifactId、version、packaging、classifier。
7.2) e.g. nexus-indexer的坐标定义，它是Nexus项目的一个子模块:
<groupId>org.sonatype.nexus</groupId>
<artifactId>nexus-indexer</artifactId>
<version>2.0.0</version>
<packaging>jar</packaging>
没有classifier
7.3) groupId: 定义当前Maven项目隶属的实际项目: e.g. org.springframework, org.sonatype.nexus
7.4) artifactId： 该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀。 e.g. 上例中的artifactId是nexus-indexer, 考虑有5个项目，每个项目都有一个core模块，如果没有前缀，我们会看到很多core-1.2.jar这样的文件，加上实际项目名前缀之后，便能很容易区分foo-core-1.2.jar、bar-core-1.2.jar……
7.4.1) 在默认情况下，Maven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar，使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件. 
7.5)version：该元素定义Maven项目当前所处的版本，如上例中nexus-indexer的版本是2.0.0。Maven定义了一套完整的版本规范，以及SNAPSHOT的概念
7.6) packaging： 该元素定义Maven项目的打包方式。 
7.6.1) 打包方式通常与所生成构件的文件扩展名对应，如上例中packaging为jar，最终的文件名为nexus-indexer-2.0.0.jar， 而使用war打包方式的Maven 项目，最终生成的构件会有一个.war文件，不过这不是绝对的。
7.6.2) 打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令（plugin/goal）。 
7.6.3) 当不定义packaging的时候， Maven会使用默认值jar。
7.7) classifier： 该元素用来帮助定义构建输出的一些附属构件。
7.7.1) 附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar，该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。
7.7.2) javadoc和sources就是这两个附属构件的classifier。
7.7.3) 这样，附属构件也就拥有了自己唯一的坐标。
7.7.4)不能直接定义项目的classifier，因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成。
7.7.5) 一个关于classifier的典型例子是TestNG，TestNG的主构件是基于Java 1.4平台的，而它又提供了一个classifier为jdk5的附属构件。
8) groupId、artifactId、version是必须定义的，packaging是可选的（默认为jar），而classifier是不能直接定义的。
9) artifact的文件名是与坐标相对应的，一般的规则为artifactId-version［-classifier］.packaging，［-classifier］表示可选。
10) packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。
11) Maven仓库的布局也是基于Maven坐标

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Maven的一大功能是管理项目依赖。为了能自动化地解析任何一个Java构件，Maven就必须将它们唯一标识，这就依赖管理的底层基础——坐标。
#何为Maven坐标
- 对应于平面中的点和城市中的地址，Maven的世界中拥有数量非常巨大的构件，也就是平时用的一些jar、war等文件。在Maven为这些构件引入坐标概念之前，我们无法使用任何一种方式来唯一标识所有这些构件。
- Maven定义了这样一组规则：世界上任何一个构件都可以使用Maven坐标唯一标识，Maven坐标的元素包括groupId、artifactId、version、packaging、
classifier。现在，只要我们提供正确的坐标元素，Maven就能找到对应的构件。
- 比如说，当需要使用Java5平台上TestNG的5.8版时，就告诉Maven：“groupId=org.testng；artifactId=testng；version=5.8；classifier=jdk15”，Maven就会从仓库中寻找相应的构件供我们使用。
- Maven内置了一个中央仓库的地址（http://repo1.maven.org/maven2)，该中央仓库包含了世界上大部分流行的开源项目构件，Maven会在需要的时候去那里下载。
- 在我们开发自己项目的时候，也需要为其定义适当的坐标，这是Maven强制要求的。在这个基础上，其他Maven项目才能引用该项目生成的构件

#坐标详解
- Maven坐标为各种构件引入了秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，groupId、artifactId、version、packaging、classifier。
- 这是nexus-indexer的坐标定义，nexus-indexer是一个对Maven仓库编纂索引并提供搜索功能的类库，它是Nexus项目的一个子模块。后面会详细介绍Nexus:
<groupId>org.sonatype.nexus</groupId>
<artifactId>nexus-indexer</artifactId>
<version>2.0.0</version>
<packaging>jar</packaging>
没有classifier

groupId： 
- 定义当前Maven项目隶属的实际项目。 
- Maven项目和实际项目不一定是一对一的关系。比如SpringFramework这一实际项目，其对应的Maven项目会有很多，如spring-core、spring-context等。
- 其次，groupId不应该对应项目隶属的组织或公司. groupId的表示方式与Java包名的表示方式类似，通常与域名反向一一对应
- 上例中，groupId为org.sonatype.nexus，org.sonatype表示Sonatype公司建立的一个非盈利性组织，nexus表示Nexus这一实际项目，该groupId与域名nexus.sonatype.org对应。

artifactId： 
- 该元素定义实际项目中的一个Maven项目（模块），推荐的做法是使用实际项目名称作为artifactId的前缀。 比如上例中的artifactId是nexus-indexer， 
- 在默认情况下，Maven生成的构件，其文件名会以artifactId作为开头，如nexus-indexer-2.0.0.jar，使用实际项目名称作为前缀之后，就能方便从一个lib文件夹中找到某个项目的一组构件. 
- 考虑有5个项目，每个项目都有一个core模块，如果没有前缀，我们会看到很多core-1.2.jar这样的文件，加上实际项目名前缀之后，便能很容易区分foo-core-1.2.jar、bar-core-1.2.jar……

version： 该元素定义Maven项目当前所处的版本，如上例中nexus-indexer的版本是2.0.0。需要注意的是，Maven定义了一套完整的版本规范，以及快照（SNAPSHOT）的概念

packaging： 该元素定义Maven项目的打包方式。
- 首先，打包方式通常与所生成构件的文件扩展名对应，如上例中packaging为jar，最终的文件名为nexus-indexer-2.0.0.jar， 而使用war打包方式的Maven项目，最终生成的构件会有一个.war文件，不过这不是绝对的。
- 其次，打包方式会影响到构建的生命周期，比如jar打包和war打包会使用不同的命令（plugin/goal）。 
- 最后，当不定义packaging的时候， Maven会使用默认值jar。

classifier： 该元素用来帮助定义构建输出的一些附属构件。
- 附属构件与主构件对应，如上例中的主构件是nexus-indexer-2.0.0.jar，该项目可能还会通过使用一些插件生成如nexus-indexer-2.0.0-javadoc.jar、nexus-indexer-2.0.0-sources.jar这样一些附属构件，其包含了Java文档和源代码。
- javadoc和sources就是这两个附属构件的classifier。
- 这样，附属构件也就拥有了自己唯一的坐标。
- 还有一个关于classifier的典型例子是TestNG，TestNG的主构件是基于Java 1.4平台的，而它又提供了一个classifier为jdk5的附属构件。
- 注意，不能直接定义项目的classifier，因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成。

- groupId、artifactId、version是必须定义的，packaging是可选的（默认为jar），而classifier是不能直接定义的。
- artifact的文件名是与坐标相对应的，一般的规则为artifactId-version［-classifier］.packaging，［-classifier］表示可选。
- 这里还要强调的一点是，packaging并非一定与构件扩展名对应，比如packaging为maven-plugin的构件扩展名为jar。
- 此外，Maven仓库的布局也是基于Maven坐标

#构建account-email
- 使用mvn clean install构建account-email，Maven会根据POM配置自动下载所需要的依赖构件，执行编译、测试、打包等工作，最后将项目生成的构件account-email-1.0.0-SNAPSHOT.jar安装到本地仓库中。这时，该模块就能供其他Maven项目使用了。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#依赖的配置
总而言之 （dependency)
1) 一个依赖声明可以包含如下的一些元素： <groupId>, <artifactId>, <version>, <scope>, <type>, <optional>, <exclusions>
2) scope： 代码的引用范围 compile/test/provided/runtime/system
2.1）since not all the dependency jars are required to be used in all scenarios, three types of classpath: 编译/测试/运行 are defined in Maven:
2.1.1) 编译classpath:Maven在编译项目主代码的时候需要使用一套classpath。编译项目主代码的时候需要用到spring-core,该文件以依赖的方式被引入到classpath中。
2.1.2) 测试classpath: 在编译测试代码和执行测试代码的时候会使用另外一套classpath。上例中的JUnit就是一个很好的例子， 该文件也以依赖的方式引入到测试使用的classpath中。
2.1.3）运行classpath: 实际运行Maven项目的时候，又会使用一套classpath，上例中的spring-core需要在该classpath中，而JUnit则不需要。
3）scope is used to control the relationship and the dependency and the three types of classpath（编译classpath、测试classpath、运行classpath）的关系, define whether the dependency will be added to the classpth:
3.1）compile： 默认的依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。 
3.2）test： 使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要。
3.3) provided： 使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。
3.4) runtime： 使用此依赖范围的Maven依赖，对于测试(需要运行测试代码）和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。
3.5)system： 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用
<dependency>
    <groupId>javax.sql</groupId>
    <artifactId>jdbc-stdext</artifactId>
    <version>2.0</version>
    <scope>system</scope>
    <systemPath>${java.home}/lib/rt.jar</systemPath>
</dependency>
3.6) 
4）relationship between dependency and classpath 
            complie classpath           test classpath              run classpath           Example
compile     Y                           Y                           Y                       spring-core
test        N                           Y                           N                       junit
provided    Y                           Y                           N                       servlet API    
runtime     N                           Y                           Y                       JDBC driver
system      Y                           Y                           N                       local jars
3.6) import（Maven 2.0.9及以上）： 导入依赖范围。该依赖范围不会对三种classpath产生实际的影响.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 一个依赖声明可以包含如下的一些元素：
<dependency>
  <groupId>...</groupId>
  <artifactId>...</artifactId>
  <version>...</version>
  <scope>test/runtime/compile</scope> <!--代码的引用范围--
  <type></type> <!依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar-->
  <optional>true/false</optional> <!--依赖是否可选--> 
  <exclusions>
        <exclude></exclude><!--排除依赖引用传递-->
  </exclusions>
</dependency>

#依赖范围
- 编译classpath:Maven在编译项目主代码的时候需要使用一套classpath。在上例中，编译项目主代码的时候需要用到springcore,该文件以依赖的方式被引入到classpath中。
- 测试classpath: 其次，Maven在编译测试代码和执行测试的时候会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖范围是test。
- 运行classpath: 最后，实际运行Maven项目的时候，又会使用一套classpath，上例中的spring-core需要在该classpath中，而JUnit则不需要。

- 依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven有以下几种依赖范围：
1）compile： 编译依赖范围。默认的依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。 

2）test： 测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要。

3) provided： 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。

4) runtime： 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。

5)system： 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用
<dependency>
    <groupId>javax.sql</groupId>
    <artifactId>jdbc-stdext</artifactId>
    <version>2.0</version>
    <scope>system</scope>
    <systemPath>${java.home}/lib/rt.jar</systemPath>
</dependency>
import（Maven 2.0.9及以上）： 导入依赖范围。该依赖范围不会对三种classpath产生实际的影响.
            complie classpath           test classpath              run classpath           Example
compile     Y                           Y                           Y                       spring-core
test        N                           Y                           N                       junit
provided    Y                           Y                           N                       servlet API    
runtime     N                           Y                           Y                       JDBC driver
system      Y                           Y                           N                       local jars
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#传递性依赖
总而言之 （scope affecting dependency transistion)
1) 通过传递性依赖机制，在使用Dependency(e.g. Spring Framework),的时候就Maven会解析各个直接依赖的POM，将那些必要的间接依赖， 以传递性依赖的形式引入到当前的项目中。
2) 不用去考虑它依赖了什么，也不用担心引入多余的依赖。 
3） dependency scope affects dependency transistion:
3.1) 假设A依赖于B，B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖, A对于C是传递性依赖
3.2) 第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围, 最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围， 中间的交叉单元格则表示传递性依赖范围。
                compile         test        provided        runtime
compile         compile         _           _               runtime
test            test            _           _               test
provided        provided        _           provided        provided
runtime         runtime         _           _               runtime
3.3) rules, 从第二依赖开始观察：
3.3.1）当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；
3.3.2）当第二直接依赖的范围是test的时候，依赖不会得以传递；
3.3.3）当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；
3.3.4）当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。
4) 依赖调解 (dependency mediation)
4.1) 当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。
4.2) 路径最近者优先： A->B->C->X（1.0）、A->D->X（2.0) ,X（2.0）会被解析使用。
4.3) 第一声明者优先： A->B->Y（1.0）、A->C->Y（2.0）, 在依赖路径长度相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用
5) 可选依赖 (Optional)
5.1) 假设有这样一个依赖关系，项目A依赖于项目B，项目B依赖于项目X和Y，B对于X和Y的依赖都是可选依赖：A->B、B->X（可选）、 B->Y（可选）。 
5.2) 由于这里X、Y是可选依赖， 依赖将不会得以传递。 换句话说，X、Y将不会对A有任何影响
5.3) 为什么要使用可选依赖这一特性呢？可能项目B实现了两个特性，其中的特性一依赖于X，特性二依赖于Y，而且这两个特性是互斥的，用户不可能同时使用两个特性。比如B是一个持久层隔离工具包，它支持多种数据库，包括MySQL、PostgreSQL等，在构建这个工具包的时候，需要这两种数据库的驱动程序，但在使用这个工具包的时候，只会依赖一种数据库。
5.4) 使用<optional>元素表示mysql-connector-java和postgresql这两个依赖为可选依赖，它们只会对当前项目B产生影响， 当其他项目依赖于B的时候， 这两个依赖不会被传递。
5.5) 当项目A依赖于项目B的时候，如果其实际使用基于MySQL数据库，那么在项目A中就需要显式地声明mysql-connector-java这一依赖
5.6) 在理想的情况下，是不应该使用可选依赖的

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 考虑一个基于Spring Framework的项目，如果不使用Maven，那么在项目中就需要手动下载相关依赖。
- 这么做往往就引入了很多不必要的依赖。另一种做法是只下载springframework-2.5.6.zip这样一个包，这里不包含其他相关依赖，到实际使用的时候，再根据出错信息，或者查询相关文档，加入需要的其他依赖。
- Maven的传递性依赖机制可以很好地解决这一问题。account-mail有一个compile范围的spring-core依赖，spring-core有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile范围依赖，commons-logging是account-email的一个传递性依赖
- 有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。

#传递性依赖和依赖范围
- 依赖范围不仅可以控制依赖与三种classpath的关系，还对传递性依赖产生影响。
- 假设A依赖于B，B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖, A对于C是传递性依赖
- 第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围, 最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围， 中间的交叉单元格则表示传递性依赖范围。
                compile         test        provided        runtime
compile         compile         _           _               runtime
test            test            _           _               test
provided        provided        _           provided        provided
runtime         runtime         _           _               runtime

- 这里再举个例子。account-email项目有一个com.icegreen：greenmail：1.3.1b的直接依赖，我们说这是第一直接依赖，其依赖范围是test；而greenmail又有一个javax.mail：mail：1.4的直接依赖，我们说这是第二直接依赖，其依赖范围是compile。显然javax.mail：mail：1.4是account-email的传递性依赖，对照上表可以知道，当第一直接依赖范围为test，第二直接依赖范围是compile的时候，传递性依赖的范围是test，因此javax.mail：mail：1.4是 account-email的一个范围是test的传递依赖。
规律：
- 当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；
- 当第二直接依赖的范围是test的时候，依赖不会得以传递；
- 当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；
- 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。

#依赖调解
- Maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用考虑这些直接依赖会引入什么传递性依赖。
- 但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。
- 路径最近者优先： 例如，项目A有这样的依赖关系：A->B->C->X（1.0）、A->D->X（2.0），X是A的传递性依赖，但是两条依赖路径上有两个版本的X， 必须选择一个。 Maven依赖调解（Dependency Mediation）的第一原则是：路径最近者优先。该例中X（1.0）的路径长度为3， 而X（2.0）的路径长度为2， 因此X（2.0）会被解析使用。
- 第一声明者优先： 依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A->B->Y（1.0）、A->C->Y（2.0），Y（1.0）和Y（2.0）的 依赖路径长度是一样的，都为2。 那么到底谁会被解析使用呢？ Maven定义了依赖调解的第二原则：第一声明者优先。在依赖路径长度相等的前提
下，在POM中依赖声明的顺序决定了谁会被解析使用，顺序最靠前的那个依赖优胜。该例中，如果B的依赖声明在C之前，那么Y（1.0）就会被解析使用。

#可选依赖
- 假设有这样一个依赖关系，项目A依赖于项目B，项目B依赖于项目X和Y，B对于X和Y的依赖都是可选依赖：A->B、B->X（可选）、 B->Y（可选）。 根据传递性依赖的定义，如果所有这三个依赖的范围都是compile，那么X、Y就是A的compile范围传递性依赖。然而，由于这里X、Y是可选依赖，依赖将不会得以传递。换句话说，X、Y将不会对A有任何影响
- 为什么要使用可选依赖这一特性呢？可能项目B实现了两个特性，其中的特性一依赖于X，特性二依赖于Y，而且这两个特性是互斥的，用户不可能同时使用两个特性。比如B是一个持久层隔离工具包，它支持多种数据库，包括MySQL、PostgreSQL等，在构建这个工具包的时候，需要这两种数据库的驱动程序，但在使用这个工具包的时候，只会依赖一种数据库。
- 上述XML代码片段中，使用<optional>元素表示mysql-connector-java和postgresql这两个依赖为可选依赖，它们只会对当前项目B
产生影响，当其他项目依赖于B的时候，这两个依赖不会被传递。
- 因此，当项目A依赖于项目B的时候，如果其实际使用基于MySQL数据库，那么在项目A中就需要显式地声明mysql-connector-java这一依赖
- 在理想的情况下，是不应该使用可选依赖的
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#最佳实践
总而言之 （dependency best practice)
1) 排除依赖 (dependency exclusion)
1.1) 传递性依赖会给项目隐式地引入很多依赖，这极大地简化了项目依赖的管理，但是有些时候这种特性也会带来问题。
1.2) 例如，当前项目有一个第三方依赖，而这个第三方依赖由于某些原因依赖了另外一个类库的SNAPSHOT版本，那么这个SNAPSHOT就会成为当前项目的传递性依赖，而SNAPSHOT的不稳定性会直接影响到当前的项目。这时就需要排除掉该SNAPSHOT，并且在当前项目中声明该类库的某个正式发布的版本。
1.3) 还有一些情况，你可能也想要替换某个传递性依赖，比如Sun JTA API，Hibernate依赖于这个JAR，但是由于版权的因素， 该类库不在中央仓库中， 而Apache Geronimo项目有一个对应的实现。这时你就可以排除Sun JAT API，再声明Geronimo的JTA API实现：
1.4) 代码中使用exclusions元素声明排除依赖，exclusions可以包含一个或者多个exclusion子元素, 排除一个或者多个传递性依赖
1.5) 声明exclusion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖
2) 归类依赖：
2.1）有很多关于Spring Framework的依赖，它们分别是org.springframework：spring-core：2.5.6、org.springframework：
spring-beans：2.5.6、org.springframework：spring-context：2.5.6和org.springframework：spring-context-support：2.5.6，它们是来自同一
项目的不同模块。所有这些依赖的版本都是相同的，如果将来需要升级Spring Framework，这些依赖的版本会一起升级。 
2.2）使用properties元素定义Maven属性，该例中定义了一个springframework.version子元素，其值为2.5.6。
2.3）使用${...}的方式引用Maven属性,所有Spring Framework依赖的版本值用这一属性引用表示
3) 优化依赖
3.1) understand Maven项目的dependency，并对其进行优化，如去除多余的依赖，显式地声明某些必要的依赖。
3.2) Maven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确判断每个依赖的范围，对于一些依赖冲突，也能进行调节，"以确保任何一个构件只有唯一的版本在依赖中存在"。在这些工作之后，最后得到的那些依赖被称为已解析依赖（Resolved Dependency）。
3.3) 查看当前项目的已解析依赖：mvn dependency:list 
3.4) 当前项目POM声明的依赖定义为顶层依赖，而这些顶层依赖的依赖则定义为第二层依赖，以此类推，有第三、第四层依赖。当这些依赖经Maven解析后，就会构成一个依赖树，通过这棵依赖树就能很清楚地看到某个依赖是通过哪条传递路径引入的。
3.5) 查看当前项目的依赖树：mvn dependency: tree
3.6） 分析当前项目的依赖： mvn dependency: analyze
[WARNING] Used undeclared dependencies found:
[WARNING]    org.springframework:spring-context:jar:2.5.6:compile
[WARNING] Unused declared dependencies found:
[WARNING]    org.springframework:spring-core:jar:2.5.6:compile
[WARNING]    org.springframework:spring-beans:jar:2.5.6:compile
3.6.1）首先是Used undeclared dependencies，意指项目中使用到的，但是没有显式声明的依赖，例如这里是spring-context，应显式声明任何项目中 直接用到的依赖。
3.6.2）Used undeclared dependencies意味着潜在的风险，当前项目直接在使用它们，例如有很多相关的Java import声明，而这种依赖是通过直
接依赖传递进来的
3.6.3）当升级直接依赖的时候，相关传递性依赖的版本也可能发生变化，这种变化不易察觉，但是有可能导致当前项目出错。例如由于接口的改变，当前项目中的相关代码无法编译。
3.6.4）Unused declared dependencies，意指项目中未使用的，但显式声明的依赖，这里有spring-core和spring-beans。 对于这样一类依赖，我们不应该简单地直接删除其声明，而是应该仔细分析。
3.6.5）由于dependency：analyze只会分析"编译"主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它就发现不了（例如jdbc-driver或者是不直接import的类库）。
3.6.6）该例中的spring-core和spring-beans是运行SpringFramework项目必要的类库，因此不应该删除依赖声明。当然，有时候确实能通过该信息找到一些没用的依赖，但一定要小心测试。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Maven依赖涉及的知识点比较多，在理解了主要的功能和原理之后，最需要的当然就是前人的经验总结了，我们称之为最佳实践。

1）排除依赖
- 传递性依赖会给项目隐式地引入很多依赖，这极大地简化了项目依赖的管理，但是有些时候这种特性也会带来问题。
- 例如，当前项目有一个第三方依赖，而这个第三方依赖由于某些原因依赖了另外一个类库的SNAPSHOT版本，那么这个SNAPSHOT就会成为当前项目的传递性依赖，而SNAPSHOT的不稳定性会直接影响到当前的项目。这时就需要排除掉该SNAPSHOT，并且在当前项目中声明该类库的某个正式发布的版本。
- 还有一些情况，你可能也想要替换某个传递性依赖，比如Sun JTA API，Hibernate依赖于这个JAR，但是由于版权的因素， 该类库不在中央仓库中， 而Apache Geronimo项目有一个对应的实现。这时你就可以排除Sun JAT API，再声明Geronimo的JTA API实现： 
- 代码中使用exclusions元素声明排除依赖，exclusions可以包含一个或者多个exclusion子元素，因此可以排除一个或者多个传
递性依赖。需要注意的是，声明exclusion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId
就能唯一定位依赖图中的某个依赖

2）归类依赖
- 有很多关于Spring Framework的依赖，它们分别是org.springframework：spring-core：2.5.6、org.springframework：
spring-beans：2.5.6、org.springframework：spring-context：2.5.6和org.springframework：spring-context-support：2.5.6，它们是来自同一
项目的不同模块。因此，所有这些依赖的版本都是相同的，而且可以预见，如果将来需要升级Spring Framework，这些依赖的版本会一起升级。 
- 对于account-email中这些Spring Framework来说，也应该在一个唯一的地方定义版本，并且在dependency声明中引用这一版本。 这样， 在升级Spring Framework的时候就只需要修改一处，
- 这里简单用到了Maven属性，首先使用properties元素定义Maven属性，该例中定义了一个springframework.version子元素，其值为2.5.6。
- 有了这个属性定义之后，Maven运行的时候会将POM中的所有的＄{springframework.version}替换成实际值2.5.6。也就是说，可以使用美元符号和大括弧环绕的方式引用Maven属性。然后，将所有Spring Framework依赖的版本值用 这一属性引用表示:

<properties>
    <springframework.version>2.5.6</springframework.version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${springframework.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${springframework.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${springframework.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-support</artifactId>
        <version>${springframework.version}</version>
    </dependency>
    ...
</dependencies>

#优化依赖
- 程序员也应该能够对Maven项目的依赖了然于胸，并对其进行优化，如去除多余的依赖，显式地声明某些必要的依赖。
- Maven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确判断每个依赖的范围，对于一些依赖冲突，也能进行调节，以确保任何一个构件只有唯一的版本在依赖中存在。在这些工作之后，最后得到的那些依赖被称为已解析依赖（Resolved Dependency）。可以运行如下的命令查看当前项目的已解析依赖：
mvn dependency:list
- 进一步了解已解析依赖的信息。将直接在当前项目POM声明的依赖定义为顶层依赖，而这些顶层依赖的
依赖则定义为第二层依赖，以此类推，有第三、第四层依赖。当这些依赖经Maven解析后，就会构成一个依赖树，通过这棵依赖树就能很清楚地看到某个依赖是通过哪条传递路径引入的。
mvn dependency: tree
- 使用dependency：list和dependency：tree可以帮助我们详细了解项目中所有依赖的具体信息，在此基础上，还有dependency：analyze工具可以帮助分析当前项目的依赖。
mvn dependency: analyze
[WARNING] Used undeclared dependencies found:
[WARNING]    org.springframework:spring-context:jar:2.5.6:compile
[WARNING] Unused declared dependencies found:
[WARNING]    org.springframework:spring-core:jar:2.5.6:compile
[WARNING]    org.springframework:spring-beans:jar:2.5.6:compile

- 首先是Used undeclared dependencies，意指项目中使用到的，但是没有显式声明的依赖， 这里是spring-context。
- 这种依赖意味着潜在的风险，当前项目直接在使用它们，例如有很多相关的Java import声明，而这种依赖是通过直
接依赖传递进来的，当升级直接依赖的时候，相关传递性依赖的版本也可能发生变化，这种变化不易察觉，但是有可能导致当前项目出错。例如由于接口的改变，当前项目中的相关代码无法编译。这种隐藏的、潜在的威胁一旦出现，就往往需要耗费大量的时间来查明真相。因此，显式声明任何项目中直接用到的依赖。
- Unused declared dependencies，意指项目中未使用的，但显式声明的依赖，这里有spring-core和spring-beans。
- 需要注意的是，对于这样一类依赖，我们不应该简单地直接删除其声明，而是应该仔细分析。由于dependency：analyze只会分析"编译"主代码和测试代码需要用到的依赖，一些执行测试和运行时需要的依赖它就发现不了。很显然，该例中的spring-core和spring-beans是运行SpringFramework项目必要的类库，因此不应该删除依赖声明。当然，有时候确实能通过该信息找到一些没用的依赖，但一定要小心测试。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter6　Repository
总而言之 （Repository）
1) 何为Maven repository?
1.1）坐标和依赖是任何一个构件在Maven世界中的逻辑表示方式；而构件的物理表示方式是文件，Maven通过仓库来统一管理这些文件。
1.2）aritifact: dependency, plugin, project build output jar/war
1.3) 得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是repository。
1.4) 实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中）， Maven 会自动根据坐标找到仓库中的构件，并使用它们。
1.5) 为了实现重用，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其他项目使用
2) repository layout
2.1) 任何一个构件都有其唯一的坐标(groupId/artifactId/version/classifier/packaging)，根据这个坐标可以定义其在仓库中的唯一存储路径， 这便是Maven的仓库布局方式。
2.2) 路径与坐标的大致对应关系为groupId/artifactId/version/artifactId-version.packaging; e.g. dependency log4j：log4j：1.2.15对应的 仓库路径为log4j/log4j/1.2.15/log4j-1.2.15.jar.
2.3) Maven仓库是基于简单文件系统存储的，我们也理解了其存储方式，当遇到一些与仓库相关的问题时，可以方便地查找相关文件，定位问题。
2.4) 例如，当Maven无法获得项目声明的依赖时，可以查看该依赖对应的文件在仓库中是否存在，如果不存在，查看是否有其他版本可用
3) local and remote repository
3.1) 当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；
3.2) 如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。
3.3) 如果本地仓库和远程仓库都没有需要的构件，Maven就会报错。
4) remote repository
4.1) 中央仓库是Maven核心自带的远程仓库，它包含了绝大部分开源的构件。 在默认配置下，当本地仓库没有Maven需要的构件的时候， 它就会尝试从中央仓库下载。
4.2) 私服是另一种特殊的远程仓库，为了节省带宽和时间，可以在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。内部的项目还能部署到私服上供其他项目使用。
4.3）除了中央仓库和私服，还有很多其他公开的远程仓库，常见的有Java.net Maven库（http://download.java.net/maven/2/ ）和JBoss Maven库（http://repository.jboss.com/maven2/ ）等。
5）local repository
5.1) 一般来说，在Maven项目目录下，没有诸如lib/样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件， 它总是基于坐标使用本地仓库的依赖文件。
5.2) 默认情况下，不管是在Windows还是Linux上，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。 
5.3) 例如，笔者的用户名是juven，在Windows机器上的本地仓库地址为C：\Users\juven\.m2\repository\，而在Linux上的本地仓库地址为/home/juven/.m2/repository/。 注意，在Linux系统中， 以点（.）开头的文件或目录默认是隐藏的，可以使用ls-a命令显示隐藏文件或目录。
5.4) 有时候，因为某些原因（例如C盘空间不够），用户会想要自定义本地仓库目录地址。这时，可以编辑文件~/.m2/settings.xml,  设置localRepository元素的值为想要的仓库地址: <localRepository>d:/java/repository</localRepository>
5.5) 一个构件只有在本地仓库中之后，才能由其他Maven项目使用，那么构件如何进入到本地仓库中呢？最常见的是依赖Maven从远程仓库下载到本地仓库中。
5.6) 还有一种常见的情况是，将本地项目的构件安装到Maven仓库中。 Maven使用Install插件将该文件复制到本地仓库中，具体的路径根据坐标计算获得。
5.7) 安装好Maven后，如果不执行任何Maven命令，本地仓库目录是不存在的。当用户输入第一条Maven命令之后，Maven才会创建本地仓库，然后根据配置和需要，从远程仓库下载构件至本地仓库。
5.8) 对于Maven来说，每个用户只有一个本地仓库，但可以配置访问很多远程仓库
6) central repository
6.1) 由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置, 可以使用解压工具打开jar文件$MAVEN_HOME/lib/maven-model-builder-3.5.jar,然后访问路径org/apache/maven/model/pom-4.0.0.xml, 即所有Maven项目都会继承的超级POM :
<repositories>
  <repository>
    <id>central</id>
    <name>Central Repository</name>
    <url>https://repo.maven.apache.org/maven2</url>
    <layout>default</layout>
    <snapshots>
      <enabled>false</enabled>
    </snapshots>
  </repository>
</repositories>
6.2）这段配置使用id central对中央仓库进行唯一标识，其名称为Central Repository, 它使用default仓库布局，也就是仓库布局部分介绍的布局。
6.3）最后需要注意的是snapshots元素，其子元素enabled的值为false，表示不从该中央仓库下载快照版本的构件
6.4）中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等
7）私服
7.1）私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。
7.2) 当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。
7.3) 一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用
7.4) 最流行的Maven私服软件——Nexus。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 坐标和依赖是任何一个构件在Maven世界中的逻辑表示方式；而构件的物理表示方式是文件，Maven通过仓库来统一管理这些文件。
#何为Maven仓库
- 任何一个依赖、插件或者项目构建的输出，都可以称为构件。
- 在一台工作站上，可能会有几十个Maven项目，所有项目都使用maven-compiler-plugin，这些项目中的大部分都用到了log4j，有一小部分用到了Spring Framework，还有另外一小部分用到了Struts2。在每个有需要的项目中都放置一份重复的log4j或者struts2显然不是最好的解决方案，这样做不仅造成了磁盘空间的浪费，而且也难于统一管理，文件的复制等操作也会降低构建的速度。而实际情况是，在不使用Maven的那些项目中，我们往往就能发现命名为lib/的目录，各个项目lib/目录下的内容存在大量的重复。
- 得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。
- 实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。
- 为了实现重用，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其他项目使用

#仓库的布局
- 任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。
- 例如，log4j：log4j：1.2.15这一依赖，其对应的仓库路径为log4j/log4j/1.2.15/log4j-1.2.15.jar，细心的读者可以观察到，该路径与坐标的大致对应关系为groupId/artifactId/version/artifactId-version.packaging。
- Maven仓库是基于简单文件系统存储的，我们也理解了其存储方式，因此，当遇到一些与仓库相关的问题时，可以很方便地查找相关文件，方便定位问题。例如，当Maven无法获得项目声明的依赖时，可以查看该依赖对应的文件在仓库中是否存在，如果不存在，查看是否有其他版本可用

#仓库的分类
- 仓库只分为两类：本地仓库和远程仓库
- 当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；
- 如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。
- 如果本地仓库和远程仓库都没有需要的构件，Maven就会报错。
- 在这个最基本分类的基础上，还有必要介绍一些特殊的远程仓库。中央仓库是Maven核心自带的远程仓库，它包含了绝大部分开源的构件。在默认配置下，当本地仓库没有Maven需要的构件的时候，它就会尝试从中央仓库下载。
-私服是另一种特殊的远程仓库，为了节省带宽和时间，应该在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。内部的项目还能部署到私服上供其他项目使用。
- 除了中央仓库和私服，还有很多其他公开的远程仓库，常见的有Java.net Maven库（http://download.java.net/maven/2/ ）和JBoss Maven库（http://repository.jboss.com/maven2/ ）等。

#本地仓库
- 一般来说，在Maven项目目录下，没有诸如lib/样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。
- 默认情况下，不管是在Windows还是Linux上，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。例如，笔者的用户名是juven， 我在Windows机器上的本地仓库地址为C：\Users\juven\.m2\repository\，而我在Linux上的本地仓库地址为/home/juven/.m2/repository/。注意，在Linux系统中， 以点（.）开头的文件或目录默认是隐藏的，可以使用ls-a命令显示隐藏文件或目录。
- 有时候，因为某些原因（例如C盘空间不够），用户会想要自定义本地仓库目录地址。这时，可以编辑文件~/.m2/settings.xml， 设置localRepository元素的 值为想要的仓库地址。
<localRepository>d:/java/repository</localRepository>
- 该用户的本地仓库地址就被设置成了D：\java\repository\。
- 一个构件只有在本地仓库中之后，才能由其他Maven项目使用，那么构件如何进入到本地仓库中呢？最常见的是依赖Maven从远程仓库下载到本地仓库中。还有一种常见的情况是，将本地项目的构件安装到Maven仓库中。
- Maven使用Install插件将该文件复制到本地仓库中，具体的路径根据坐标计算获得。

#远程仓库
- 安装好Maven后，如果不执行任何Maven命令，本地仓库目录是不存在的。当用户输入第一条Maven命令之后，Maven才会创建本地仓库，然后根据配置和需要，从远程仓库下载构件至本地仓库。
- 对于Maven来说，每个用户只有一个本地仓库，但可以配置访问很多远程仓库

#中央仓库
- 由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。
- 可以使用解压工具打开jar文件＄MAVEN_HOME/lib/maven-model-builder-3.5.jar,然后访问路径org/apache/maven/model/pom-4.0.0.xml， 可以看到如下的配置：
<repositories>
  <repository>
    <id>central</id>
    <name>Central Repository</name>
    <url>https://repo.maven.apache.org/maven2</url>
    <layout>default</layout>
    <snapshots>
      <enabled>false</enabled>
    </snapshots>
  </repository>
</repositories>

- 包含这段配置的文件是所有Maven项目都会继承的超级POM，
- 这段配置使用id central对中央仓库进行唯一标识，其名称为Central Repository, 它使用default仓库布局，也就是在第6.2节介绍的仓库布局。
- 最后需要注意的是snapshots元素，其子元素enabled的值为false，表示不从该中央仓库下载快照版本的构件
- 中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。
-由于中央仓库包含了超过2000个开源项目的构件，因此，一般来说，一个简单Maven项目所需要的依赖构件都能从中央仓库下载到。这也解释了为什么Maven能做
到“开箱即用”。
- 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。
- 当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。
- 此外，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用
- 最流行的Maven私服软件——Nexus。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#远程仓库的配置
总而言之 (configuration and authentication of remote repository other than central)
1）在POM中配置, 例如当默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另外一个远程仓库中，如JBoss Maven仓库：
<repositories>
    <repository>
      <id>jboss</id>
      <name>JBOSS repository</name>
      <url>http://repository.jboss.com/maven2/</url>
      <releases>
        <enabled>true</enabled>
      </releases>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <layout>default</layout>
    </repository>
<repositories>
1.1) 在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。
1.2) 该例中声明了一个id为jboss，名称为JBoss Repository的仓库。任何一个仓库声明的id必须是唯一的，Maven自带的中央仓库使用的id为central，如果其他的仓库声明也使用该id，就会覆盖中央仓库的配置。
1.3) url值指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。
1.4) releases和snapshots元素控制Maven对于发布版构件和快照版构件的下载。 releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持， 而snapshots的enabled值为false， 表示关闭JBoss仓库的快照版本的下载支持。
1.5) layout元素值default表示仓库的布局是Maven 2及Maven 3的默认布局，而不是Maven 1的布局。
1.6) 对于releases和snapshots来说，除了enabled，还包含另外两个子元素updatePolicy和checksumPolicy：
<snapshots>
  <enabled>false</enabled>
  <updatePolicy>daily</updatePolicy>
  <checksumPolicy>ignore</checksumPolicy>
</snapshots>
1.7) 元素updatePolicy用来配置Maven从远程仓库检查更新的频率，默认的值是daily，表示Maven每天检查一次。其他值包括：never—从不检查更新；always—每次构建都检查更新；interval：X—每隔X分钟检查一次更新（X为任意整数）。
1.8) 元素checksumPolicy用来配置Maven检查检验和文件的策略。当构件被部署到Maven仓库中时，会同时部署对应的校验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，怎么办？当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail—Maven遇到校验和错误就让构建失败；ignore—使Maven完全忽略校验和错误。
2) authentication of remote repository
2.1) 大部分远程仓库无须认证就可以访问，但有时候出于安全方面的考虑，我们需要提供认证信息才能访问一些远程仓库。
2.2) 例如，组织内部有一个Maven仓库服务器，该服务器为每个项目都提供独立的Maven仓库，为了防止非法的仓库访问，管理员为每个仓库提供了一组用户名及密码。这时，为了能让Maven访问仓库内容，就需要配置认证信息。
2.3) 配置仓库信息可以直接配置在POM文件中，但是认证信息必须配置在settings.xml文件中。这是因为POM往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只放在本机。
<servers>
    <server>
      <id>deploymentRepo</id>
      <username>repouser</username>
      <password>repopwd</password>
    </server>
    <server>
      <id>siteServer</id>
      <privateKey>/path/to/private/key</privateKey>
      <passphrase>optional; leave empty if not used.</passphrase>
    </server>
</servers>
2.4) settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致。换句话说，正是这个id将认证信息与仓库配置联系在了一起。
3) deployment to remote repository
3.1) 私服的一大作用是部署第三方构件，包括组织内部生成的构件以及一些无法从外部仓库直接获取的构件。无论是日常开发中生成的构件，还是正式版本发布的构件，都需要部署到仓库中，供其他团队成员使用。
3.2) 首先，需要编辑项目的pom.xml文件。配置distributionManagement元素,说明构件部署地址等:
<distributionManagement>
  <repository>
    <id>project-releases</id>
    <name>Project Release Repository</name>
    <url>http://192.168.246.170/content/repository/project-releases</url>
  </repository>
  <snapshotRepository>
    <id>project-snapshots</id>
    <name>Project Snapshot Repository</name>
    <url>http://192.168.246.170/content/repository/project-snapshots</url>
  </snapshotRepository>
</distributionManagement>
3.3）distributionManagement包含repository和snapshotRepository子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。
3.4）这两个元素下都需要配置id、name和url，id为该远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。
3.5）往远程仓库部署构件的时候，往往需要认证。 like dependency repository authentication, 在settings.xml中创建一个server元素， 其id与仓库的id匹配，并配置正确的认证信息
3.6）mvn clean deploy：将项目构建输出的artifacts部署到配置的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本仓库地址， 否则就部署到发布版本仓库地址。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 在很多情况下，默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另外一个远程仓库中，如JBoss Maven仓库。这时，可以在POM中配置该仓库:
<repositories>
    <repository>
      <id>jboss</id>
      <name>JBOSS repository</name>
      <url>http://repository.jboss.com/maven2/</url>
      <releases>
        <enabled>true</enabled>
      </releases>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <layout>default</layout>
    </repository>
<repositories>
- 在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。
- 该例中声明了一个id为jboss，名称为JBoss Repository的仓库。任何一个仓库声明的id必须是唯一的，尤其需要注意的是， Maven自带的中央仓库使用的id为central，如果其他的仓库声明也使用该id，就会覆盖中央仓库的配置。
- 该配置中的url值指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。
- 该例配置中的releases和snapshots元素比较重要，它们用来控制Maven对于发布版构件和快照版构件的下载。
- 这里需要注意的是enabled子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。因此，根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。
- 该例中的layout元素值default表示仓库的布局是Maven 2及Maven 3的默认布局，而不是Maven 1的布局。
- 对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy：
<snapshots>
  <enabled>false</enabled>
  <updatePolicy>daily</updatePolicy>
  <checksumPolicy>ignore</checksumPolicy>
</snapshots>
- 元素updatePolicy用来配置Maven从远程仓库检查更新的频率，默认的值是daily，表示Maven每天检查一次。其他可用的值包括：never—从不检查更新；always—每次构建都检查更新；interval：X—每隔X分钟检查一次更新（X为任意整数）。
- 元素checksumPolicy用来配置Maven检查检验和文件的策略。当构件被部署到Maven仓库中时，会同时部署对应的校验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，怎么办？当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail—Maven遇到校验和错误就让构建失败；ignore—使Maven完全忽略校验和错误。

#远程仓库的认证
- 大部分远程仓库无须认证就可以访问，但有时候出于安全方面的考虑，我们需要提供认证信息才能访问一些远程仓库。
- 例如，组织内部有一个Maven仓库服务器，该服务器为每个项目都提供独立的Maven仓库，为了防止非法的仓库访问，管理员为每个仓库提供了一组用户名及密码。这时，为了能让Maven访问仓库内容，就需要配置认证信息。
- 配置认证信息和配置仓库信息不同，仓库信息可以直接配置在POM文件中，但是认证信息必须配置在settings.xml文件中。这是因为POM往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只放在本机。
<servers>
    <server>
      <id>deploymentRepo</id>
      <username>repouser</username>
      <password>repopwd</password>
    </server>
    <server>
      <id>siteServer</id>
      <privateKey>/path/to/private/key</privateKey>
      <passphrase>optional; leave empty if not used.</passphrase>
    </server>
  </servers>
- Maven使用settings.xml文件中并不显而易见的servers元素及其server子元素配置仓库认证信息。
- 该仓库的认证用户名为repo-user，认证密码为repo-pwd。
- 这里的关键是id元素，settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致。换句话说，正是这个id将认证信息与仓库配置联系在了一起。

#部署至远程仓库
- 私服的一大作用是部署第三方构件，包括组织内部生成的构件以及一些无法从外部仓库直接获取的构件。无论是日常开发中生成的构件，还是正式版本发布的构件，都需要部署到仓库中，供其他团队成员使用。
- Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构建部署到仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素,配置构件部署地址:
<distributionManagement>
  <repository>
    <id>project-releases</id>
    <name>Project Release Repository</name>
    <url>http://192.168.246.170/content/repository/project-releases</url>
  </repository>
  <snapshotRepository>
    <id>project-snapshots</id>
    <name>Project Snapshot Repository</name>
    <url>http://192.168.246.170/content/repository/project-snapshots</url>
  </snapshotRepository>
</distributionManagement>
- distributionManagement包含repository和snapshotRepository子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。
- 这两个元素下都需要配置id、name和url，id为该远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。
- 往远程仓库部署构件的时候，往往需要认证。 like dependency repository authentication, 在settings.xml中创建一个server元素， 其id与仓库的id匹配，并配置正确的认证信息
- 不论从远程仓库下载构件，还是部署构件至远程仓库，当需要认证的时候，配置的方式是一样的。
- 配置正确后，在命令行运行mvn clean deploy ，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本仓库地址，否则就部署到发布版本仓库地址。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#快照版本
总而言之 (snapshot)
1) 在Maven的世界中，任何一个项目或者构件都必须有自己的版本。
2) 版本的值可能是1.0.0、1.3-alpha-4、2.0、2.1-SNAPSHOT或者2.1-20091214.221414-13。
3) 其中，1.0.0、1.3-alpha-4和2.0是稳定的发布版本，而2.1-SNAPSHOT和2.1-20091214.221414-13是不稳定的快照版本。
4) SNAPSHOT is used to solve the problem of frequent version publishing. instead of creating many small versions, keep the version as SNAPSHOT. When Maven build a project and see the version has SNAPSHOT, it will create a version of artifact using timestamp and install to remote repository.
5) When another developer confiure the snapshot dependency, maven will check the most recent arctifact of the SNAPSHOT, if a newer version is found, then download to local repository.
6) 默认情况下，Maven每天检查一次更新（由季MM项目pom.xml仓库配置的updatePolicy控制）
7) 用户也可以使用命令行-U参数强制让Maven检查更新，如mvn clean install-U
8) 项目经过完善的测试后发布的时候，就应该将快照版本更改为发布版本。例如，将2.1-SNAPSHOT更改为2.1，表示该版本已经稳定，且只对应了唯一的构件。
9) 2.1-SNAPSHOT往往对应了大量的带有不同时间戳的构件，这也决定了其不稳定性。
10) 快照版本只应该在组织内部的项目或模块间依赖使用，因为组织对于这些快照版本的依赖具有完全的理解及控制权。
11) 项目不应该依赖于任何组织外部的快照版本依赖，由于快照版本的不稳定性，这样的依赖会造成潜在的危险。 即使项目构建今天是成功的， 由于外部的快照版本依赖实际对应的构件随时可能变化，项目的构建就可能由于这些外部的不受控制的因素而失败。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 在Maven的世界中，任何一个项目或者构件都必须有自己的版本。
- 版本的值可能是1.0.0、1.3-alpha-4、2.0、2.1-SNAPSHOT或者2.1-20091214.221414-13。
- 其中，1.0.0、1.3-alpha-4和2.0是稳定的发布版本，而2.1-SNAPSHOT和2.1-20091214.221414-13是不稳定的快照版本。
- Maven为什么要区分发布版和快照版呢？简单的1.0.0、1.2、2.1等不就够了吗？为什么还要有2.1-SNAPSHOT，甚至是长长的
2.1-20091214.221414-13？
- 试想一下这样的情况，小张在开发模块A的2.1版本，该版本还未正式发布，与模块A一同开发的还有模块B，它由小张的同事季MM开发，B的功能依赖于A。在开发的过程中，小张需要经常将自己最新的构建输出，交给季MM，供她开发和集成调试，问题是，这个工作如何进行呢？
1.方案一, 让季MM自己签出模块A的源码进行构建。 她不得自己不去构建模块A, build may fail and she is unlikely to be able to fix it.
2.方案二, 重复部署模块A的2.1版本供季MM下载, 如果季MM在本机的本地仓库包含了模块A的2.1版本构件，Maven就不会再对照远程仓库进行更新。
3.方案三，不停更新版本2.1.1、2.1.2、2.1.3……。 小张和季MM两人都需要频繁地更改POM，如果有更多的模块依赖于模块A， 就会涉及更多的POM更改；
- Maven的快照版本机制就是为了解决上述问题。在该例中，小张只需要将模块A的版本设定为2.1-SNAPSHOT，然后发布到私服中，在发布的过程中，Maven会自动为构件打上时间戳。
- 比如2.1-20091214.221414-13就表示2009年12月14日22点14分14秒的第13次快照。有了该时间戳，Maven就能随时找到仓库中该构件2.1-SNAPSHOT版本最新的文件。
- 季MM配置对于模块A的2.1-SNAPSHOT版本的依赖，当她构建模块B的时候，Maven会自动从仓库中检查模块A的2.1-SNAPSHOT的最新构件，当发现有更新时便进行下载
- 默认情况下，Maven每天检查一次更新（由仓库配置的updatePolicy控制）
- 用户也可以使用命令行-U参数强制让Maven检查更新，如mvn clean install-U, 使用参数后，Maven就会忽略<updatePolicy>的配置。 。
- 当项目经过完善的测试后需要发布的时候，就应该将快照版本更改为发布版本。例如，将2.1-SNAPSHOT更改为2.1，表示该版本已经稳定，且只对应了唯一的构件。相比之下，2.1-SNAPSHOT往往对应了大量的带有不同时间戳的构件，这也决定了其不稳定性。
- 快照版本只应该在组织内部的项目或模块间依赖使用，因为这时，组织对于这些快照版本的依赖具有完全的理解及控制权。
- 项目不应该依赖于任何组织外部的快照版本依赖，由于快照版本的不稳定性，这样的依赖会造成潜在的危险。
- 也就是说，即使项目构建今天是成功的，由于外部的快照版本依赖实际对应的构件随时可能变化，项目的构建就可能由于这些外部的不受控制的因素而失败。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#从仓库解析依赖的机制
总而言之 （resolving dependency from repository）
1）当本地仓库没有依赖构件的时候，Maven会自动从远程仓库下载
2）当依赖版本为快照版本的时候，Maven会自动找到最新的快照
3）依赖解析机制
3.1) 当依赖的范围是system的时候，Maven直接从本地文件系统解析构件。
3.2) 根据依赖坐标计算仓库路径后，尝试直接从本地仓库寻找构件，如果发现相应构件，则解析成功。
3.3) 在本地仓库不存在相应构件的情况下，如果依赖的版本是显式的发布版本构件，如1.2、2.1-beta-1等，则遍历所有的远程仓库，发现后，下载并解析使用。
3.4) 如果依赖的版本是SNAPSHOT，则"基于更新策略"读取所有远程仓库的元数据groupId/artifactId/version/maven-metadata.xml，
将其与本地仓库的对应元数据合并后，"得到最新快照版本的值"，然后基于该值检查本地仓库，或者从远程仓库下载
3.5) 如果最后解析得到的构件版本是时间戳格式的快照，如1.4.1-20091104.121450-121，则复制其时间戳格式的文件至非时间戳格式，如SNAPSHOT，并使用该非时间戳格式的构件。
3.6) 如果依赖的版本是RELEASE或者LATEST，则基于更新策略读取所有远程仓库的元数据groupId/artifactId/mavenmetadata.xml， 将其与本地仓库的对应元数据合并后，计算出RELEASE或者LATEST真实的值，然后基于这个真实的值检查本地和远程仓库，如步骤2）和3）。
4) 机制要点：
4.1）当依赖的版本不明晰的时候，如RELEASE、LATEST和SNAPSHOT，Maven就需要基于更新远程仓库的更新策略来检查更新。
4.2）仓库配置中，与依赖解析机制有关的一些配置：
4.2.1) <releases><enabled>和<snapshots><enabled>:只有仓库开启了对于发布版本的支持时才能访问该仓库的发布版本构件信息，对于快照版本也是同理
4.2.2) <releases>和<snapshots>的子元素<updatePolicy>，该元素配置了检查更新的频率，每日检查更新、永远检查更新、从不检查更新、 自定义时间间隔检查更新等。
4.2.3) 用户还可以从命令行加入参数-U，强制检查更新，使用参数后，Maven就会忽略<updatePolicy>的配置。
4.3) 当Maven检查完更新策略，并决定检查依赖更新的时候，就需要检查仓库元数据maven-metadata.xml。
4.4) 回顾一下前面提到的RELEASE和LATEST版本，它们分别对应了仓库中存在的该构件的最新发布版本和最新版本（包含快照），而这两个“最新”是基于groupId/artifactId/maven-metadata.xml计算出来的
4.5) 该XML文件列出了仓库中存在的该构件所有可用的版本，同时latest元素指向了这些版本中最新的那个版本，该例中是1.4.2-SNAPSHOT
4.6) 而release元素指向了这些版本中最新的发布版本，该例中是1.4.0。
4.7) Maven通过合并多个远程仓库及本地仓库的元数据，就能计算出基于所有仓库的latest和release分别是什么，然后再解析具体的构件。
4.8) 需要注意的是，在依赖声明中使用LATEST和RELEASE是不推荐的做法，因为Maven随时都可能解析到不同的构件，可能今天LATEST是1.3.6，明天就成为1.4.0-SNAPSHOT了，且Maven不会明确告诉用户这样的变化。当这种变化造成构建失败的时候，发现问题会变得比较困难。
4.9) RELEASE因为对应的是最新发布版构建，还相对可靠，LATEST就非常不可靠了，为此，Maven 3不再支持在插件配置中 使用LATEST和RELEASE
4.10) 如果不设置插件版本，其效果就和RELEASE一样，Maven只会解析最新的发布版本构件。不过即使这样，也还存在潜在的问题。例如，某个依赖的1.1版本与1.2版本可能发生一些接口的变化，从而导致当前Maven构建的失败。
4.11) 当依赖的版本设为快照版本的时候，Maven也需要检查更新，Maven会检查仓库元数据groupId/artifactId/version/mavenmetadata.xml，
4.12) 该XML文件的snapshot元素包含了timestamp和buildNumber两个子元素，分别代表了这一快照的时间戳和构建号，基于这两个元素可以得到该仓库中此快照的最新构件版本实际为1.4.2-20091214.221414-13。通过合并所有远程仓库和本地仓库的元数据，Maven就能知道所有仓库中该构件的最新快照。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Maven是根据怎样的规则从仓库解析并使用依赖构件的呢？ 
- 当本地仓库没有依赖构件的时候，Maven会自动从远程仓库下载；当依赖版本为快照版本的时候，Maven会自动找到最新的快照。
- 这背后的依赖解析机制可以概括如下：
1）当依赖的范围是system的时候，Maven直接从本地文件系统解析构件。
2）根据依赖坐标计算仓库路径后，尝试直接从本地仓库寻找构件，如果发现相应构件，则解析成功。
3）在本地仓库不存在相应构件的情况下，如果依赖的版本是显式的发布版本构件，如1.2、2.1-beta-1等，则遍历所有的远程仓库，发现后，下载并解析使用。
4）如果依赖的版本是RELEASE或者LATEST，则基于更新策略读取所有远程仓库的元数据groupId/artifactId/mavenmetadata.xml， 将其与本地仓库的对应元数据合并后，计算出RELEASE或者LATEST真实的值，然后基于这个真实的值检查本地和
远程仓库，如步骤2）和3）。
5）如果依赖的版本是SNAPSHOT，则基于更新策略读取所有远程仓库的元数据groupId/artifactId/version/maven-metadata.xml，
将其与本地仓库的对应元数据合并后，得到最新快照版本的值，然后基于该值检查本地仓库，或者从远程仓库下载。
6）如果最后解析得到的构件版本是时间戳格式的快照，如1.4.1-20091104.121450-121，则复制其时间戳格式的文件至非时间戳格式，如SNAPSHOT，并使用该非时间戳格式的构件。

- 当依赖的版本不明晰的时候，如RELEASE、LATEST和SNAPSHOT，Maven就需要基于更新远程仓库的更新策略来检查更新。
- 仓库配置中，有一些配置与此有关：首先是<releases><enabled>和<snapshots><enabled>，只有仓库开启了对于发布版本的支持时， 才能访问该仓库的发布版本构件信息，对于快照版本也是同理；
- 其次要注意的是<releases>和<snapshots>的子元素<updatePolicy>，该元素配置了检查更新的频率，每日检查更新、 永远检查更新、从不检查更新、自定义时间间隔检查更新等。
- 最后，用户还可以从命令行加入参数-U，强制检查更新，使用参数后，Maven就会忽略<updatePolicy>的配置。
- 当Maven检查完更新策略，并决定检查依赖更新的时候，就需要检查仓库元数据maven-metadata.xml。
- 回顾一下前面提到的RELEASE和LATEST版本，它们分别对应了仓库中存在的该构件的最新发布版本和最新版本（包含快照），而这两个“最新”是基于groupId/artifactId/maven-metadata.xml计算出来的
- 该XML文件列出了仓库中存在的该构件所有可用的版本，同时latest元素指向了这些版本中最新的那个版本，该例中是1.4.2-
SNAPSHOT
- 而release元素指向了这些版本中最新的发布版本，该例中是1.4.0。Maven通过合并多个远程仓库及本地仓库的元数据，就能计算出基于所有仓库的latest和release分别是什么，然后再解析具体的构件。
- 需要注意的是，在依赖声明中使用LATEST和RELEASE是不推荐的做法，因为Maven随时都可能解析到不同的构件，可能今
天LATEST是1.3.6，明天就成为1.4.0-SNAPSHOT了，且Maven不会明确告诉用户这样的变化。当这种变化造成构建失败的时候，
发现问题会变得比较困难。
- RELEASE因为对应的是最新发布版构建，还相对可靠，LATEST就非常不可靠了，为此，Maven 3不再支持在插件配置中 使用LATEST和RELEASE
- 如果不设置插件版本，其效果就和RELEASE一样，Maven只会解析最新的发布版本构件。不过即使这样，也还存在潜在的问题。例如，某个依赖的1.1版本与1.2版本可能发生一些接口的变化，从而导致当前Maven构建的失败。
- 当依赖的版本设为快照版本的时候，Maven也需要检查更新，这时，Maven会检查仓库元数据groupId/artifactId/version/mavenmetadata.xml，
- 该XML文件的snapshot元素包含了timestamp和buildNumber两个子元素，分别代表了这一快照的时间戳和构建号，基于这两个元素可以得到该仓库中此快照的最新构件版本实际为1.4.2-20091214.221414-13。通过合并所有远程仓库和本地仓库的元数据，Maven就能知道所有仓库中该构件的最新快照。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#镜像
总而言之 （mirror）
1) 如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。 换句话说，任何一个可以从仓库Y获得的构件，都能够从它的镜像中获取。
2) e.g. http://maven.net.cn/content/groups/public/ 是中央仓库http://repo1.maven.org/maven2/ 在中国的镜像，
3) 编辑settings.xml, 配置该镜像来替代中央仓库。
<mirrors>
  <mirror>
    <id>maven.net.cn</id>
    <mirrorOf>central</mirrorOf>
    <name>one of the mirrors of central in China</name>
    <url>http://maven.net.cn/content/groups/public/</url>
  </mirror>
</mirrors>
4) <mirrorOf>的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像，
5) 用户也可以使用同样的方法配置其他仓库的镜像。
6) 另外三个元素id、name、url与一般仓库配置无异，表示该镜像仓库的唯一标识符、名称以及地址。
7) 如果该镜像需要认证，也可以基于该id配置仓库认证。
8) 镜像的一个更为常见的用法是结合私服。由于私服可以代理任何外部的公共仓库（包括中央仓库），因此，对于组织内部的Maven用户来说，使用一个私服地址就等于使用了所有需要的外部仓库，这可以将配置集中到私服，从而简化Maven本身的配置
8.1) 在这种情况下，任何需要的构件都可以从私服获得，私服就是所有仓库的镜像
<mirrors>
  <mirror>
    <id>internal-repository</id>
    <mirrorOf>*</mirrorOf>
    <name>Internal Repository Manager</name>
    <url>http://192.168.1.100/maven2/</url>
  </mirror>
</mirrors>
8.2) 该例中<mirrorOf>的值为星号，表示该配置是所有Maven仓库的镜像，任何对于远程仓库的请求都会被转至http://192.168.1.100/maven2/ 。
8.3) 如果该镜像仓库需要认证，则配置一个id为internal-repository的<server>
8.4) 为了满足一些复杂的需求，Maven还支持更高级的镜像配置：
<mirrorOf>*</mirrorOf>： 匹配所有远程仓库。
<mirrorOf>external：*</mirrorOf>： 匹配所有远程仓库，使用localhost的除外，使用file：// 协议的除外。也就是说， 匹配所有不在本机上的远程仓库。
<mirrorOf>repo1，repo2</mirrorOf>： 匹配仓库repo1和repo2，使用逗号分隔多个远程仓库。
<mirrorOf>*，！repo1</mirrorOf>： 匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。
8.5) 由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库。
9) 我们可能只知道需要使用类库的项目名称，但添加Maven依赖要求提供确切的Maven坐标。这时，就可以使用仓库搜索服务来根据关键字得到Maven坐标。
- MVNrepository: http://mvnrepository.com/
- Sonatype Nexus: http://repository.sonatype.org/

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。
- 换句话说，任何一个可以从仓库Y获得的构件，都能够从它的镜像中获取。
- 举个例子，http://maven.net.cn/content/groups/public/ 是中央仓库http://repo1.maven.org/maven2/ 在中国的镜像， 由于地理位置的因素，该镜像往往能够提供比中央仓库更快的服务。
- 因此，可以配置Maven使用该镜像来替代中央仓库。编辑settings.xml
<mirrors>
  <mirror>
    <id>maven.net.cn</id>
    <mirrorOf>central</mirrorOf>
    <name>one of the mirrors of central in China</name>
    <url>http://maven.net.cn/content/groups/public/</url>
  </mirror>
</mirrors>
- <mirrorOf>的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像，
- 用户也可以使用同样的方法配置其他仓库的镜像。
- 另外三个元素id、name、url与一般仓库配置无异，表示该镜像仓库的唯一标识符、名称以及地址。
- 类似地，如果该镜像需要认证，也可以基于该id配置仓库认证。
- 关于镜像的一个更为常见的用法是结合私服。由于私服可以代理任何外部的公共仓库（包括中央仓库），因此，对于组织内部的Maven用户来说，使用一个私服地址就等于使用了所有需要的外部仓库，这可以将配置集中到私服，从而简化Maven本身的配置
- 在这种情况下，任何需要的构件都可以从私服获得，私服就是所有仓库的镜像
<mirrors>
  <mirror>
    <id>internal-repository</id>
    <mirrorOf>*</mirrorOf>
    <name>Internal Repository Manager</name>
    <url>http://192.168.1.100/maven2/</url>
  </mirror>
</mirrors>
- 该例中<mirrorOf>的值为星号，表示该配置是所有Maven仓库的镜像，任何对于远程仓库的请求都会被转至http://192.168.1.100/maven2/ 。
- 如果该镜像仓库需要认证，则配置一个id为internal-repository的<server>
- 为了满足一些复杂的需求，Maven还支持更高级的镜像配置：
<mirrorOf>*</mirrorOf>： 匹配所有远程仓库。
<mirrorOf>external：*</mirrorOf>： 匹配所有远程仓库，使用localhost的除外，使用file：// 协议的除外。也就是说， 匹配所有不在本机上的远程仓库。
<mirrorOf>repo1，repo2</mirrorOf>： 匹配仓库repo1和repo2，使用逗号分隔多个远程仓库。
<mirrorOf>*，！repo1</mirrorOf>： 匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。
- 需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像
仓库，因而将无法下载构件。

#仓库搜索服务
- 使用Maven进行日常开发的时候，一个常见的问题就是如何寻找需要的依赖，我们可能只知道需要使用类库的项目名称，但
添加Maven依赖要求提供确切的Maven坐标。这时，就可以使用仓库搜索服务来根据关键字得到Maven坐标。
- 几个常用的、功能强大的公共Maven仓库搜索服务。
- Sonatype Nexus: http://repository.sonatype.org/
- Nexus提供了关键字搜索、类名搜索、坐标搜索、校验和搜索等功能。搜索后，页面清晰地列出了结果构件的坐标及所属仓库。用户可以直接下载相应构件，还可以直接复制已经根据坐标自动生成的XML依赖声明，

MVNrepository: http://mvnrepository.com/
- MVNrepository的界面比较清新，它提供了基于关键字的搜索、依赖声明代码片段、构件下载、依赖与被依赖关系信息、构件所含包信息等功能。MVNrepository还能提供一个简单的图表，显示某个构件各版本间的大小变化。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter 7 生命周期和插件
总而言之 （Lifecycle）
1）在Maven的日常使用中，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。
2）生命周期和插件两者协同工作，密不可分：Maven的生命周期是抽象的，其实际行为都由插件来完成，如package阶段的任务可能由maven-jar-plugin完成。
3）Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。
4) Maven的生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。
5) Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，在Maven的设计中，实际的任务（如编译源代码）都交由插件来完成。
6) 这种思想与设计模式中的模板方法（Template Method）非常相似。
public abstract class AbstractBuild
{
    public void build()
    {
        initialize();
        compile();
        test();
        packagee();
        integrationTest();
        deploy();
    }
    protected abstract void initialize();
    protected abstract void compile();
    protected abstract void test();
    protected abstract void packagee();
    protected abstract void integrationTest();
    protected abstract void deploy();
}
7) 生命周期抽象了构建的各个步骤，定义了它们的次序，但没有提供具体实现。
8) 那么谁来实现这些步骤呢？Maven设计了插件机制。 每个构建步骤都可以绑定一个或者多个插件行为
9) 而且Maven为大多数构建步骤编写并绑定了默认插件。 例如，针对编译的插件有maven-compiler-plugin，针对测试的插件有maven-surefire-plugin等。
10) 当用户有特殊需要的时候，也可以"配置插件定制构建行为"，甚至"自己编写插件"。
11) Maven定义的生命周期和插件机制一方面保证了所有Maven项目有一致的构建标准，另一方面又通过默认插件简化和稳定了实际项目的构建。此外，该机制还提供了足够的扩展空间，用户可以通过配置现有插件或者自行编写插件来自定义构建行为。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 除了坐标、依赖以及仓库之外，Maven另外两个核心概念是生命周期和插件。
- 在有关Maven的日常使用中，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。
- Maven的生命周期是抽象的，其实际行为都由插件来完成，如package阶段的任务可能就会由maven-jar-plugin完成。生命周期和插件两者协同工作，密不可分

#何为生命周期
- 在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理、编译、测试及部署。
- 虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。有的项目以手工的方式在执行编译测试，有的项目写了自动化脚本执行编译测试。
- 可以想象的是，虽然各种手工方式十分类似，但不可能完全一样；同样地，对于自动化脚本，大家也是各写各的，能满足自身需求即可，换个项目就需要重头再来。

- Maven的生命周期就是为了对所有的构建过程进行抽象和统一。
- Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完善的、易扩展的生命周期。
- 这个生命周期包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。
- 几乎所有项目的构建，都能映射到这样一个生命周期上。

- Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，
- 在Maven的设计中，实际的任务（如编译源代码）都交由插件来完成。
- 这种思想与设计模式中的模板方法（Template Method）非常相似。模板方法模式在父类中定义算法的整体结构，子类可以通过实现 或者重写父类的方法来 控制实际的行为， 这样既保证了算法有足够的可扩展性，又能够严格控制算法的整体结构。
- 如下的模板方法抽象类能够很好地体现Maven生命周期的概念:
public abstract class AbstractBuild
{
    public void build()
    {
        initialize();
        compile();
        test();
        packagee();
        integrationTest();
        deploy();
    }
    protected abstract void initialize();
    protected abstract void compile();
    protected abstract void test();
    protected abstract void packagee();
    protected abstract void integrationTest();
    protected abstract void deploy();
}
....
- 这段代码非常简单，build（）方法定义了整个构建的过程，依次初始化、编译、测试、打包（由于package与Java关键字冲突，这里使用了单词packagee）、集成测试和部署，但是这个类中没有具体实现初始化、编译、测试等行为，它们都交由子类去实现。
- 生命周期抽象了构建的各个步骤，定义了它们的次序，但没有提供具体实现。
- 那么谁来实现这些步骤呢？不能让用户为了编译而写一堆代码，为了测试又写一堆代码，那不就成了大家在重复发明轮子吗？Maven当然必须考虑这一点，因此它设计了插件机制。每个构建步骤都可以绑定一个或者多个插件行为，
- 而且Maven为大多数构建步骤编写并绑定了默认插件。例如，针对编译的插件有maven-compiler-plugin，针对测试的插件有maven-surefire-plugin等。虽然在大多数时间里，用户几乎都不会觉察到插件的存在，但实际上编译是由maven-compilerplugin完成的，而测试是由maven-surefire-plugin完成的。
- 当用户有特殊需要的时候，也可以配置插件定制构建行为，甚至自己编写插件。

**Maven定义的生命周期和插件机制一方面保证了所有Maven项目有一致的构建标准，另一方面又通过默认插件简化和稳定了实际项目的构建。此外，该机制还提供了足够的扩展空间，用户可以通过配置现有插件或者自行编写插件来自定义构建行为。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#三套生命周期
总而言之 （3 sets of lifecycles)
1) Maven拥有三套相互独立的生命周期，它们分别为clean、default和site。clean生命周期的目的是清理项目; default生命周期的目的是构建项目; 而site生命周期的目的是建立项目站点。
2) 每个生命周期包含一些阶段（phase），这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，
3) 三套生命周期本身是相互独立的，可以仅仅调用clean生命周期的某个阶段，或者仅仅调用default生命周期的某个阶段，而不会对其他生命周期产生任何影响
4) clean生命周期: 
4.1）pre-clean 执行一些清理前需要完成的工作。
4.2）clean 清理上一次构建生成的文件。
4.3）post-clean 执行一些清理后需要完成的工作。
5) default生命周期:  default生命周期定义了真正构建时所需要执行的所有步骤，它是所有生命周期中最核心的部分:
5.1) validate
5.2) initialize
5.3) generate-sources
5.4) process-sources 处理项目主资源文件。对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。
5.5) generate-resources
5.6) process-resources
5.7) compile 编译项目的主源码。一般来说，是编译src/main/java目录下的Java文件至项目输出的主classpath目录中。
5.8) process-classes
5.9) generate-test-sources
5.10) process-test-sources 处理项目测试资源文件。对src/test/resources目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中。
5.11) generate-test-resources
5.12) process-test-resources
5.13) test-compile 编译项目的测试代码。一般来说，是编译src/test/java目录下的Java文件至项目输出的测试classpath目录中。
5.14) process-test-classes
5.15) test 使用单元测试框架运行测试，测试代码不会被打包或部署。
5.16) prepare-package
5.17) package 接受编译好的代码，打包成可发布的格式，如JAR。
5.18) pre-integration-test
5.19) integration-test
5.20) post-integration-test
5.21) verify
5.22) install 将包安装到Maven本地仓库，供本地其他Maven项目使用。
5.23) deploy 将最终的包复制到远程仓库，供其他开发人员和Maven项目使用。
5.24) 参阅官方的解释：http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html 。
6) site生命周期: 基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。
6.1) pre-site 执行一些在生成项目站点之前需要完成的工作。
6.2) site 生成项目站点文档。
6.3) post-site 执行一些在生成项目站点之后需要完成的工作。
6.4) site-deploy 将生成的项目站点发布到服务器上。
7) command line vs. lifecycle
7.1) 从命令行执行Maven任务的最主要方式就是调用Maven的生命周期阶段。
7.2) 各个生命周期是相互独立的，而一个生命周期的阶段是有前后依赖关系的。
7.3) $mvn clean： 调用clean生命周期的clean阶段。实际执行的阶段为clean生命周期的pre-clean和clean阶段。
7.4) $mvn test： 调用default生命周期的test阶段。实际执行的阶段为default生命周期的validate、initialize等，直到test的所有阶段。这也解释了为什么在执行测试的时候，项目的代码能够自动得以编译。
7.5) $mvn clean install：调用clean生命周期的clean阶段和default生命周期的install阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期的从validate至install的所有阶段。 该命令结合了两个生命周期，在执行真正的项目构建之前清理项目是一个很好的实践。
7.6) $mvn clean deploy site-deploy： 调用clean生命周期的clean阶段、default生命周期的deploy阶段，以及site生命周期的site-deploy阶段。 实际执行的阶段为clean生命周期的pre-clean、clean阶段，default生命周期的所有阶段，以及site生命周期的所有阶段。该命令结合了Maven所有三个生命周期，且deploy为default生命周期的最后一个阶段，site-deploy为site生命周期的最后一个阶段。
7.7) Maven中主要的生命周期阶段并不多，而常用的Maven命令实际都是基于这些阶段简单组合而成的

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- Maven拥有三套相互独立的生命周期，它们分别为clean、default和site。
- clean生命周期的目的是清理项目，
- default生命周期的目的是构建项目
- 而site生命周期的目的是建立项目站点。

- 每个生命周期包含一些阶段（phase），这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，
- 用户和Maven最直接的交互方式就是调用这些生命周期阶段
- 以clean生命周期为例，它包含的阶段有pre-clean、clean和post-clean。
- 当用户调用pre-clean的时候，只有pre-clean阶段得以执行；当用户调用clean的时候，pre-clean和clean阶段会得以顺序执行；当用户调用post-clean的时候，pre-clean、clean和post-clean会得以顺序执行。
- 较之于生命周期阶段的前后依赖关系，三套生命周期本身是相互独立的，用户可以仅仅调用clean生命周期的某个阶段，或者仅仅调用default生命周期的某个阶段，而不会对其他生命周期产生任何影响
- 例如，当用户调用clean生命周期的clean阶段的时候，不会触发default生命周期的任何阶段，反之亦然，当用户调用default生命周期的compile阶段的时候，也不会触发clean生命周期的任何阶段。

#clean生命周期: 
目的是清理项目，它包含三个阶段：
1）pre-clean 执行一些清理前需要完成的工作。
2）clean 清理上一次构建生成的文件。
3）post-clean 执行一些清理后需要完成的工作。

default生命周期
- default生命周期定义了真正构建时所需要执行的所有步骤，它是所有生命周期中最核心的部分，其包含的阶段如下：
·validate
·initialize
·generate-sources
·process-sources 处理项目主资源文件。一般来说，是对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。
·generate-resources
·process-resources
·compile 编译项目的主源码。一般来说，是编译src/main/java目录下的Java文件至项目输出的主classpath目录中。
·process-classes
·generate-test-sources
·process-test-sources 处理项目测试资源文件。一般来说，是对src/test/resources目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中。
·generate-test-resources
·process-test-resources
·test-compile 编译项目的测试代码。一般来说，是编译src/test/java目录下的Java文件至项目输出的测试classpath目录中。
·process-test-classes
·test 使用单元测试框架运行测试，测试代码不会被打包或部署。
·prepare-package
·package 接受编译好的代码，打包成可发布的格式，如JAR。
·pre-integration-test
·integration-test
·post-integration-test
·verify
·install 将包安装到Maven本地仓库，供本地其他Maven项目使用。
·deploy 将最终的包复制到远程仓库，供其他开发人员和Maven项目使用。

- 参阅官方的解释：http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html 。

#site生命周期
- site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。
·pre-site 执行一些在生成项目站点之前需要完成的工作。
·site 生成项目站点文档。
·post-site 执行一些在生成项目站点之后需要完成的工作。
·site-deploy 将生成的项目站点发布到服务器上。

#命令行与生命周期
- 从命令行执行Maven任务的最主要方式就是调用Maven的生命周期阶段。
- 需要注意的是，各个生命周期是相互独立的，而一个生命周期的阶段是有前后依赖关系的。
·＄mvn clean： 该命令调用clean生命周期的clean阶段。实际执行的阶段为clean生命周期的pre-clean和clean阶段。

·＄mvn test：该命令调用default生命周期的test阶段。实际执行的阶段为default生命周期的validate、initialize等， 直到test的所有阶段。 这也解释了为什么在执行测试的时候，项目的代码能够自动得以编译。

·＄mvn clean install： 该命令调用clean生命周期的clean阶段和default生命周期的install阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段， 以及default生命周期的从validate至install的所有阶段。该命令结合了两个生命周期，在执行真正的项目构建之前清理项目是一个很好的实践。

·＄mvn clean deploy site-deploy： 该命令调用clean生命周期的clean阶段、default生命周期的deploy阶段，以及site生命周期的site-deploy阶段。 实际执行的阶段为clean生命周期的pre-clean、clean阶段，default生命周期的所有阶段，以及site生命周期的所有阶段。该命令结合了Maven所有三个生命周期，且deploy为default生命周期的最后一个阶段，site-deploy为site生命周期的最后一个阶段。

- 由于Maven中主要的生命周期阶段并不多，而常用的Maven命令实际都是基于这些阶段简单组合而成的，因此只要对Maven生命周期有一个基本的理解，读者就可以正确而熟练地使用Maven命令。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#插件目标
总而言之 （plugin goal）
1）plugin goal: 在进一步详述插件和生命周期的绑定关系之前，必须先了解插件目标（Plugin Goal）的概念。
1.1）Maven的核心仅仅定义了抽象的生命周期，具体的任务是交由插件完成的，插件以独立的构件形式存在，Maven会在需要的时候下载并使用插件。
1.2）插件目标是插件一个功能：对于插件本身，为了能够复用代码，它往往能够完成多个任务。为每个功能编写一个独立的插件显然是不可取的，因为这些任务背后有很多可以复用的代码，因此，这些功能聚集在一个插件里，每个功能就是一个插件目标。
1.3）maven-dependency-plugin有十多个目标，每个目标对应了一个功能。它能够分析项目依赖，帮助找出潜在的无用依赖；它能够列出项目的依赖树，帮助分析依赖来源；它能够列出项目所有已解析的依赖，这几个功能分别对应的插件目标为dependency：analyze、dependency：tree和dependency：list；  compiler：compile是maven-compiler-plugin的compile目标; surefire：test是maven-surefire-plugin的test目标。
1.4）这是一种通用插件目标的写法，冒号前面是插件前缀，冒号后面是插件目标。
2) 插件绑定
2.1) Maven的生命周期与插件相互绑定，用以完成实际的构建任务。
2.2) 具体而言，是生命周期的阶段<->插件目标相互绑定，以完成某个具体的构建任务。
2.3) 例如项目编译这一任务，对应了default生命周期的compile这一阶段，而maven-compiler-plugin这一插件的compile目标能够完成该任务。因此，将它们绑定，就能实现项目编译的目的
3) 内置绑定
3.1) 为了能让用户几乎不用任何配置就能构建Maven项目，Maven为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，
对应的插件目标就会执行相应的任务
3.2) clean生命周期仅有pre-clean、clean和post-clean三个阶段，其中的clean与maven-clean-plugin：clean绑定。maven-clean-plugin仅有clean这一个目标，其作用就是删除项目的输出目录。
3.3) site生命周期有pre-site、site、post-site和site-deploy四个阶段，site阶段和maven-site-plugin：site目标相互绑定，site-deploy阶段和maven-site-plugin：depoy目标绑定。 maven-site-plugin：site目标用来生成项目站点，maven-site-plugin：deploy目标用来将项目站点部署到远程服务器上。
3.4）default生命周期与插件目标的绑定关系较为复杂。因为对于任何项目来说，例如jar项目和war项目，它们的项目清理和站点生成任务是一样的，不过构建过程会有区别。例如jar项目需要打成JAR包，而war项目需要打成WAR包。
3.5）default生命周期的内置插件绑定关系及具体任务（打包类型：jar）:
生命周期阶段            插件目标                              Tasks
process-resources      maven-resources-plugin:resources     copy main resources to main output directory                    
compile                maven-compiler-plugin:compile        compile main sources to main output directory                      
process-test-resources maven-resources-plugin:testResources copy test resources to test output directory                         
test-compile           maven-compiler-plugin:testCompile    compile test sources to test output directory                      
test                   maven-surefire-plugin:test           run test cases             
package                maven-jar-plugin:jar                 create jar from main output directory                           
install                maven-install-plugin:install         install jar to local repo                 
deploy                 maven-deploy-plugin:deploy           deploy jar to remote repo
3.6) 上表只列出了拥有插件绑定关系的阶段，default生命周期还有很多其他阶段，默认它们没有绑定任何插件，因此也没有任何实际行为。
3.7) 除了默认的打包类型jar之外，常见的打包类型还有war、pom、maven-plugin、ear等。它们的default生命周期与插件目标的绑定关系可参阅Maven官方文
档：http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Built-in_Lifecycle_Bindings
4) 自定义绑定
4.1) 除了内置绑定以外，用户还能够自己选择"将某个插件:目标绑定到生命周期的某个阶段上"，这种自定义绑定方式能让Maven项目在构建过程中执行更多更富特色的任务。
4.2) 一个常见的例子是创建项目的源码jar包，内置的插件绑定关系中并没有涉及这一任务，因此需要用户自行配置。
4.3) maven-source-plugin的jar-no-fork目标能够将项目的主代码打包成jar文件，将其绑定到default生命周期的verify阶段上，在执行完集成测试后、安装构件前创建源码jar包。
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.1.1</version>
    <executions>
        <execution>
            <id>attach-sources</id>
            <phase>verify</phase>
            <goals>
                <goal>jar-no-fork</goal>
            </goals>
        </execution>
    </executions>
</plugin>
4.4）pom.xml中，在build/plugins/plugin中定义插件的绑定，声明插件坐标，该例中用到的是maven-source-plugin，其groupId=org.apache.maven.plugins，这也是Maven官方插件的groupId，artifactId=maven-source-plugin，version=2.1.1。
4.5）对于自定义绑定的插件，用户应该声明一个非快照版本，这样可以避免由于插件版本变化造成的构建不稳定性。
4.6）插件执行配置，executions/execution子元素可以用来配置执行一个任务。配置了一个id为attach-sources的任务，通过phase配置将其绑定到verify生命周期阶段上，再通过goals配置指定要执行的插件目标。
4.7）mvn verify：当执行verify生命周期阶段的时候，maven-source-plugin：jar-no-fork会得以执行，它会创建一个以-sources.jar结尾的源码文件包。
4.8）有时候，即使不通过phase元素配置生命周期阶段，插件目标也能够绑定到生命周期中去。例如，可以尝试删除上述配置中的phase一行，再次执行mvn verify ，仍然可以看到maven-source-plugin：jar-no-fork得以执行。原因是有很多插件的目标在编写时已经定义了默认绑定阶段。
4.9）可以使用maven-help-plugin查看插件详细信息，了解插件目标的默认绑定阶段 - Bound to phase: package。
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1 -Ddetail
Description: Aggregate sources for all modules in an aggregator project.
  Implementation: org.apache.maven.plugin.source.AggregatorSourceJarMojo
  Language: java
  Bound to phase: package
  Before this mojo executes, it will call:
    Phase: 'generate-sources'
4.10）当插件目标被绑定到不同的生命周期阶段的时候，其执行顺序会由生命周期阶段的先后顺序决定。
4.11）当多个插件目标绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。   
5）插件配置
5.1）完成了插件和生命周期的绑定之后，用户还可以配置插件目标的参数，进一步调整插件目标所执行的任务，以满足项目的需求。
5.2）几乎所有Maven插件的目标都有一些可配置的参数，用户可以通过命令行和POM配置等方式来配置这些参数。
5.3）命令行插件配置
5.3.1）在日常的Maven使用中，我们会经常从命令行输入并执行Maven命令。 如果能够方便地更改某些插件的行为，无疑会十分方便。
5.3.2）很多插件目标的参数都支持从命令行配置，用户可以在Maven命令中使用-D参数，并伴随一个参数键=参数值的形式，来配置插件目标的参数。
5.3.3）例如，maven-surefire-plugin提供了一个maven.test.skip参数，当其值为true的时候，就会跳过执行测试：
mvn install -Dmaven.test.skip=true
5.3.4）参数-D是Java自带的，其功能是通过命令行设置一个Java系统属性，Maven简单地重用了该参数，在准备插件的时候检查系统属性，便实现了插件参数的配置。
5.4）pom.xml中插件全局配置
5.4.1）并不是所有的插件参数都适合从命令行配置，有些参数的值从项目创建到项目发布都不会改变，或者说很少改变，对于这种情况，在POM文件中一次性配置比重复在命令行输入要方便。
5.4.2）可以在声明插件的时候进行一个全局的配置。所有使用该插件的任务，都会使用这些配置。
5.4.3）例如，我们通常会需要配置maven-compiler-plugin告诉它编译Java 1.5版本的源文件，生成与JVM 1.5兼容的字节码文件
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.5</source>
        <target>1.5</target>
    </configuration>
</plugin>
5.4.4）不管绑定到compile阶段的maven-compiler-plugin：compile任务，还是绑定到test-compiler阶段的maven-compiler-plugin：testCompile任务，就都能够使用该配置，基于Java 1.5版本进行编译。
5.5）pom.xml中插件任务配置
5.5.1）除了为插件配置全局的参数，用户还可以为某个插件任务配置特定的参数。
5.5.2）以maven-antrun-plugin为例，它有一个目标run，可以用来在Maven中调用Ant任务。用户将maven-antrun-plugin：run绑定到多个生命周期阶段上，再加以不同的配置，就可以让Maven在不同的生命阶段执行不同的任务，
6）获取插件信息
6.1）仅仅理解如何配置使用插件是不够的。当遇到一个构建任务的时候，用户还需要知道去哪里寻找合适的插件，以帮助完成任务。
6.2）找到正确的插件之后，还要详细了解该插件的配置点。
6.3）在线插件信息
6.3.1）基本上所有主要的Maven插件都来自Apache和Codehaus。详细的列表可以在这个地址得到：http://maven.apache.org/plugins/index.html，单击某个插件的链接便可以得到进一步的信息。所有官方插件能在这里下载：http://repo1.maven.org/maven2/org/apache/maven/plugins/ 。
6.3.2）Codehaus上的Mojo项目也提供了大量了Maven插件，详细的列表可以访问：http://mojo.codehaus.org/plugins.html。 所有Codehaus的Maven插件能在这里下载：http://repository.codehaus.org/org/codehaus/mojo/ 。
6.3.3）通过阅读插件文档中的使用介绍和实例，应该能够很好地使用该插件。但想了解非常细节的目标参数时，就需要进一步访问该插件每个目标的文档
6.3.4）文档详细解释了该参数的作用、类型等信息。基于该信息，用户可以在POM中配置maven-surefire-plugin的skip参数为true来跳过测试。从命令行传入的参数不同于该插件目标的参数名称。命令行参数是由该插件参数的表达式（Expression）决定的。surefire：test skip参数的表达式为＄{maven.test.skip}， 它表示可以在命令行以-Dmaven.test.skip=true的方式配置该目标。并不是所有插件目标参数都有表达式，一些插件目标参数只能在POM中配置。
6.4）使用maven-help-plugin描述插件
6.4.1）除了访问在线的插件文档之外，还可以借助maven-help-plugin来获取插件的详细信息：
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin:2.1
6.4.2）执行的是maven-help-plugin的describe目标，在参数plugin中输入插件的groupId、artifactId和version。Maven输出plugin的简要信息，包括该插件的坐标、目标前缀和目标等
6.4.3）目标前缀（Goal Prefix），其作用是方便在命令行直接运行插件。 maven-compiler-plugin的目标前缀是compiler。
6.4.4) 在描述插件的时候，还可以省去版本信息，让Maven自动获取最新版本:
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin
6.4.5) 可以使用插件目标前缀替换坐标
mvn help:describe -Dplugin=compiler
6.4.6) 如果想仅仅描述某个插件目标的信息，可以加上goal参数：
mvn help:describe -Dplugin=compiler -Dgoal=compile
6.4.7) 如果想输出更详细的信息，可以加上detail参数：
mvn help:describe -Dplugin=compiler -Dgoal=compile -Ddetail

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 在进一步详述插件和生命周期的绑定关系之前，必须先了解插件目标（Plugin Goal）的概念。
- 我们知道，Maven的核心仅仅定义了抽象的生命周期，具体的任务是交由插件完成的，插件以独立的构件形式存在，Maven会在需要的时候下载并使用插件。
- 对于插件本身，为了能够复用代码，它往往能够完成多个任务。
- 例如maven-dependency-plugin，它能够基于项目依赖做很多事情。它能够分析项目依赖，帮助找出潜在的无用依赖；它能够列出项目的依赖树，帮助分析依赖来源；它能够列出项目所有已解析的依赖，等等。
- 为每个这样的功能编写一个独立的插件显然是不可取的，因为这些任务背后有很多可以复用的代码，因此，这些功能聚集在一个插件里，"每个功能就是一个插件目标"。
- maven-dependency-plugin有十多个目标，每个目标对应了一个功能，上述提到的几个功能分别对应的插件目标为dependency：analyze、dependency：tree和dependency：list。这是一种通用的写法，冒号前面是插件前缀，冒号后面是该插件的目标。
- 类似地，还可以写出compiler：compile（这是maven-compiler-plugin的compile目标）和surefire：test（这是maven-surefire-plugin的test目标）。

#插件绑定
- Maven的生命周期与插件相互绑定，用以完成实际的构建任务。
- 具体而言，是生命周期的阶段与插件的目标相互绑定，以完成某个具体的构建任务。
- 例如项目编译这一任务，它对应了default生命周期的compile这一阶段，而maven-compiler-plugin这一插件的compile目标能够完成该任务。因此，将它们绑定，就能实现项目编译的目的，

#内置绑定
- 为了能让用户几乎不用任何配置就能构建Maven项目，Maven在核心为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，对应的插件目标就会执行相应的任务
- clean生命周期仅有pre-clean、clean和post-clean三个阶段，其中的clean与maven-clean-plugin：clean绑定。maven-clean-plugin仅有clean这一个目标，其作用就是删除项目的输出目录。
- site生命周期有pre-site、site、post-site和site-deploy四个阶段，其中，site和maven-site-plugin：site相互绑定，site-deploy和maven-site-plugin：depoy相互绑定。maven-site-plugin有很多目标，其中，site目标用来生成项目站点，deploy目标用来将项目站点部署到远程服务器上。
- 对于clean和site生命周期来说，default生命周期与插件目标的绑定关系就显得复杂一些。这是因为对于任何项目来说，例如jar项目和war项目，它们的项目清理和站点
生成任务是一样的，不过构建过程会有区别。例如jar项目需要打成JAR包，而war项目需要打成WAR包。
- default生命周期的内置插件绑定关系及具体任务（打包类型：jar）:
生命周期阶段            插件目标                              Tasks
process-resources      maven-resources-plugin:resources     copy main resources to main output directory                    
compile                maven-compiler-plugin:compile        compile main sources to main output directory                      
process-test-resources maven-resources-plugin:testResources copy test resources to test output directory                         
test-compile           maven-compiler-plugin:testCompile    compile test sources to test output directory                      
test                   maven-surefire-plugin:test           run test cases             
package                maven-jar-plugin:jar                 create jar from main output directory                           
install                maven-install-plugin:install         install jar to local repo                 
deploy                 maven-deploy-plugin:deploy           deploy jar to remote repo

-上表只列出了拥有插件绑定关系的阶段，default生命周期还有很多其他阶段，默认它们没有绑定任何插件，因此也没有任何实际行为。
- 除了默认的打包类型jar之外，常见的打包类型还有war、pom、maven-plugin、ear等。它们的default生命周期与插件目标的绑定关系可参阅Maven官方文
档：http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Built-in_Lifecycle_Bindings

#自定义绑定
- 除了内置绑定以外，用户还能够自己选择"将某个插件:目标绑定到生命周期的某个阶段上"，这种自定义绑定方式能让Maven项目在构建过程中执行更多更富特色的任务。
- 一个常见的例子是创建项目的源码jar包，内置的插件绑定关系中并没有涉及这一任务，因此需要用户自行配置。
- maven-source-plugin可以帮助我们完成该任务，它的jarno-fork目标能够将项目的主代码打包成jar文件，可以将其绑定到default生命周期的verify阶段上，在执行完集成测试后和安装构件之前创建源码jar包。
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.1.1</version>
    <executions>
        <execution>
            <id>attach-sources</id>
            <phase>verify</phase>
            <goals>
                <goal>jar-no-fork</goal>
            </goals>
        </execution>
    </executions>
</plugin>
- 在POM的build元素下的plugins子元素中声明插件的使用，该例中用到的是maven-source-plugin，其groupId为org.apache.maven.plugins，这也是Maven官方插件的groupId，紧接着artifactId为maven-source-plugin，version为2.1.1。
- 对于自定义绑定的插件，用户总是应该声明一个非快照版本，这样可以避免由于插件版本变化造成的构建不稳定性。
- 除了基本的插件坐标声明外，还有插件执行配置，executions下每个execution子元素可以用来配置执行一个任务。该例中配置了一个id为attach-sources的任
务，通过phrase配置，将其绑定到verify生命周期阶段上，再通过goals配置指定要执行的插件目标。至此，自定义插件绑定完成。
mvn verify
- 当执行verify生命周期阶段的时候，maven-source-plugin：jar-no-fork会得以执行，它会创建一个以-sources.jar结尾的源码文件包。

- 有时候，即使不通过phase元素配置生命周期阶段，插件目标也能够绑定到生命周期中去。例如，可以尝试删除上述配置中的phase一行，再次执行mvn verify ，仍然可
以看到maven-source-plugin：jar-no-fork得以执行。原因是有很多插件的目标在编写时已经定义了默认绑定阶段。

- 可以使用maven-help-plugin查看插件详细信息，了解插件目标的默认绑定阶段。
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1 -Ddetail

Description: Aggregate sources for all modules in an aggregator project.
  Implementation: org.apache.maven.plugin.source.AggregatorSourceJarMojo
  Language: java
  Bound to phase: package
  Before this mojo executes, it will call:
    Phase: 'generate-sources'

- 我们知道，当插件目标被绑定到不同的生命周期阶段的时候，其执行顺序会由生命周期阶段的先后顺序决定。
- 当多个插件目标绑定到同一个阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。   

#插件配置
- 完成了插件和生命周期的绑定之后，用户还可以配置插件目标的参数，进一步调整插件目标所执行的任务，以满足项目的需求。
- 几乎所有Maven插件的目标都有一些可配置的参数，用户可以通过命令行和POM配置等方式来配置这些参数。

#命令行插件配置
- 在日常的Maven使用中，我们会经常从命令行输入并执行Maven命令。 在这种情况下，如果能够方便地更改某些插件的行为，无疑会十分方便。
- 很多插件目标的参数都支持从命令行配置，用户可以在Maven命令中使用-D参数，并伴随一个参数键=参数值的形式，来配置插件目标的参数。
- 例如，maven-surefire-plugin提供了一个maven.test.skip参数，当其值为true的时候，就会跳过执行测试。 于是，在运行命令的时候，加上如下-D参数就能跳过测试：
mvn install -Dmaven.test.skip=true
- 参数-D是Java自带的，其功能是通过命令行设置一个Java系统属性，Maven简单地重用了该参数，在准备插件的时候检查系统属性，便实现了插件参数的配置。

#POM中插件全局配置
- 并不是所有的插件参数都适合从命令行配置，有些参数的值从项目创建到项目发布都不会改变，或者说很少改变，对于这种情况，在POM文件中一次性配置就显然比
重复在命令行输入要方便。
- 用户可以在声明插件的时候，对此插件进行一个全局的配置。也就是说，所有该基于该插件目标的任务，都会使用这些配置。
- 例如，我们通常会需要配置maven-compiler-plugin告诉它编译Java 1.5版本的源文件，生成与JVM 1.5兼容的字节码文件
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.5</source>
        <target>1.5</target>
    </configuration>
</plugin>
- 这样，不管绑定到compile阶段的maven-compiler-plugin：compile任务，还是绑定到test-compiler阶段的maven-compiler-plugin：testCompiler任务，就都能够使用该配置，基于Java 1.5版本进行编译。

#POM中插件任务配置
- 除了为插件配置全局的参数，用户还可以为某个插件任务配置特定的参数。
- 以maven-antrun-plugin为例，它有一个目标run，可以用来在Maven中调用Ant任务。用户将maven-antrun-plugin：run绑定到多个生命周期阶段上，再加以不同的配置，就可以让Maven在不同的生命阶段执行不同的任务，

#获取插件信息
- 仅仅理解如何配置使用插件是不够的。当遇到一个构建任务的时候，用户还需要知道去哪里寻找合适的插件，以帮助完成任务。
- 找到正确的插件之后，还要详细了解该插件的配置点。由于Maven的插件非常多，而且这其中的大部分没有完善的文档，因此，使用正确的插件并进行正确的配置，其实并不是一件容易的事。

#在线插件信息
- 基本上所有主要的Maven插件都来自Apache和Codehaus。
- 由于Maven本身是属于Apache软件基金会的，因此它有很多官方的插件，每天都有成千上万的Maven用户在使用这些插件，它们具有非常好的稳定性。详细的列表可以在这个地址得到：http://maven.apache.org/plugins/index.html，单击某个插件的链接便可以得到进一步的信息。所有官方插件能在这里下载：http://repo1.maven.org/maven2/org/apache/maven/plugins/ 。

- 除了Apache上的官方插件之外，托管于Codehaus上的Mojo项目也提供了大量了Maven插件，详细的列表可以访问：http://mojo.codehaus.org/plugins.html。 需要注意的是，这些插件的文档和可靠性相对较差，在使用时，如果遇到问题，往往只能自己去看源代码。所有Codehaus的Maven插件能在这里下载：http://repository.codehaus.org/org/codehaus/mojo/ 。
- 一般来说，通过阅读插件文档中的使用介绍和实例，就应该能够在自己的项目中很好地使用该插件。但当我们想了解非常细节的目标参数时，就需要进一步访问该插
件每个目标的文档
- 文档详细解释了该参数的作用、类型等信息。基于该信息，用户可以在POM中配置maven-surefire-plugin的skip参数为true来跳过测试。这个时候读者可能会不理解了，
之前在命令行传入的参数不是maven.test.skip吗？的确如此，虽然对于该插件目标的作用是一样的，但从命令行传入的参数确实不同于该插件目标的参数名称。命令行参数
是由该插件参数的表达式（Expression）决定的。surefire：test skip参数的表达式为＄{maven.test.skip}，它表示可以在命令行以-Dmaven.test.skip=true的方
式配置该目标。并不是所有插件目标参数都有表达式，也就是说，一些插件目标参数只能在POM中配置。

#使用maven-help-plugin描述插件
- 除了访问在线的插件文档之外，还可以借助maven-help-plugin来获取插件的详细信息。可以运行如下命令来获取maven-compiler-plugin 2.1版本的信息：
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin:2.1
- 这里执行的是maven-help-plugin的describe目标，在参数plugin中输入需要描述插件的groupId、artifactId和version。Maven在命令行输出maven-compiler-plugin的简要信息，包括该插件的坐标、目标前缀和目标等
Name: Maven Compiler Plugin
Description: The Compiler Plugin is used to compile the sources of your
  project.
Group Id: org.apache.maven.plugins
Artifact Id: maven-compiler-plugin
Version: 2.1
Goal Prefix: compiler

This plugin has 3 goals:

compiler:compile
  Description: Compiles application sources

compiler:help
  Description: Display help information on maven-compiler-plugin.
    Call
      mvn compiler:help -Ddetail=true -Dgoal=<goal-name>
    to display parameter details.

compiler:testCompile
  Description: Compiles application test sources.

For more information, run 'mvn help:describe [...] -Ddetail'

- 目标前缀（Goal Prefix），其作用是方便在命令行直接运行插件。 maven-compiler-plugin的目标前缀是compiler。
- 在描述插件的时候，还可以省去版本信息，让Maven自动获取最新版本来进行表述
mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin
- 进一步简化，可以使用插件目标前缀替换坐标
mvn help:describe -Dplugin=compiler
- 如果想仅仅描述某个插件目标的信息，可以加上goal参数：
mvn help:describe -Dplugin=compiler -Dgoal=compile
如果想让maven-help-plugin输出更详细的信息，可以加上detail参数：
mvn help:describe -Dplugin=compiler -Dgoal=compile -Ddetail
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#从命令行调用插件
总而言之 (调用plugin+插件解析机制)
1）在命令行运行mvn -h 来显示mvn命令帮助: usage: mvn [options] [<goal(s)>] [<phase(s)>]
2) 该信息告诉了我们mvn命令的基本用法，options表示可用的选项，mvn命令有20多个选项。
3) 除了选项之外，mvn命令后面可以添加一个或者多个goal和phase，它们分别是指插件目标和生命周期阶段。
4) 可以通过mvn命令激活生命周期阶段，从而执行那些绑定在生命周期阶段上的插件目标。
5) Maven还支持直接从命令行调用插件目标。 Maven支持这种方式是因为有些任务不适合绑定在生命周期上，
6) 例如maven-help-plugin：describe，我们不需要在构建项目的时候去描述插件信息，又如maven-dependency-plugin：tree，我们也不需要在构建项目的时候去显示依赖树。因此这些插件目标应该通过如下方式使用：
mvn org.apache.maven.plugins:maven-help-plugin:describe -Dplugin=compiler or mvn help:describe -Dplugin=compiler
mvn org.apache.maven.plugins:maven-dependency-plugin:2.1:tree or mvn dependency：tree
7) 目标前缀: help是maven-help-plugin的目标前缀，dependency是maven-dependency-plugin的前缀，通过插件前缀，Maven就能找到对应的artifactId。除了artifactId，Maven还需要得到groupId和version才能精确定位到某个插件。
8）插件解析机制
8.1）为了方便用户使用和配置插件，Maven不需要用户提供完整的插件坐标信息，就可以解析得到正确的插件，Maven的这一特性是一把双刃剑，虽然它简化了插件的使用和配置，可一旦插件的行为出现异常，用户就很难快速定位到出问题的插件构件。
8.2）e.g. mvn help：system 到底执行了什么插件？该插件的groupId、artifactId和version分别是什么？这个构件是从哪里来的？
#　插件仓库
8.3)与依赖构件一样，插件构件同样基于坐标存储在Maven仓库中。在需要的时候，Maven会从本地仓库寻找插件，如果不存在，则从远程仓库查找。 找到插件之后，再下载到本地仓库使用。
8.4) Maven会区别对待依赖的远程仓库与插件的远程仓库，依赖远程仓库配置只对一般依赖有效果。
8.5）当Maven需要的插件在本地仓库不存在时，它就不会去依赖远程仓库查找，而去插件远程仓库查找。
8.6）不同于repositories及其repository子元素，插件的远程仓库使用pluginRepositories和pluginRepository配置。Maven内置了如下的插件远程仓库配置
<pluginRepositories>
    <pluginRepository>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
      <layout>default</layout>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
    </pluginRepository>
</pluginRepositories>
8.7）除了pluginRepositories和pluginRepository标签不同之外，其余所有子元素表达的含义与依赖远程仓库配置完全一样。
8.8）这个默认插件仓库的地址就是中央仓库，它关闭了对SNAPSHOT的支持，以防止引入SNAPSHOT版本的插件而导致不稳定的构建。
8.9）一般来说，中央仓库所包含的插件完全能够满足我们的需要，不需要配置其他的插件仓库。只有在很少的情况下，项目使用的插件无法在中央仓库找到，或者
自己编写了插件，这个时候可以参考上述的配置，在POM或者settings.xml中加入其他的插件仓库配置。
8.10）在POM中配置插件的时候，如果该插件是Maven的官方插件（即如果其groupId为org.apache.maven.plugins），就可以省略groupId配置； 不推荐使用Maven的这一机制，虽然这么做可以省略一些配置，但这样的配置会让团队中不熟悉Maven的成员感到费解
9）解析插件版本
9.1）为了简化插件的配置和使用，在用户没有提供插件版本的情况下，Maven会自动解析插件版本
9.2) Maven在超级POM中为所有核心插件设定了版本，超级POM是所有Maven项目的父POM，所有项目都继承这个超级POM的配置，
9.3) 因此，即使用户不加任何配置，Maven使用核心插件的时候，它们的版本就已经确定了。这些核心插件包括maven-clean-plugin、maven-compiler-plugin、maven-surefire-plugin等。
9.4）如果用户使用某个插件时没有设定版本，而这个插件又不属于核心插件的范畴，Maven就会去检查所有仓库中可用的版本，然后做出选择。
9.5）以maven-compiler-plugin为例，它在中央仓库的仓库元数据为http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-compiler-plugin/maven-metadata.xml:
<metadata>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <versioning>
        <latest>3.7.0</latest>
        <release>3.7.0</release>
        <versions>
            <version>2.0-beta-1</version>
            <version>2.0</version>
            <version>2.0.1</version>
            <version>2.0.2</version>
            <version>2.1</version>
            <version>2.2</version>
            <version>2.3</version>
            <version>2.3.1</version>
            <version>2.3.2</version>
            <version>2.4</version>
            <version>2.5</version>
            <version>2.5.1</version>
            <version>3.0</version>
            <version>3.1</version>
            <version>3.2</version>
            <version>3.3</version>
            <version>3.5</version>
            <version>3.5.1</version>
            <version>3.6.0</version>
            <version>3.6.1</version>
            <version>3.6.2</version>
            <version>3.7.0</version>
        </versions>
        <lastUpdated>20170904193138</lastUpdated>
    </versioning>
</metadata>
9.6）Maven3当插件没有声明版本的时候，解析使用release版本， 即3.7.0。
9.7）依赖Maven解析插件版本其实是不推荐的做法，即使Maven 3将版本解析到最新的非快照版，也还是会有潜在的不稳定性。
9.8) 例如，可能某个插件发布了一个新的版本，而这个版本的行为与之前的版本发生了变化，这种变化就可能导致项目构建失败。因此，使用插件的时候，应该一直显式地设定版本，这也解释了Maven为什么要在超级POM中为核心插件设定版本。
10) 解析插件前缀
10.1) mvn命令行支持使用插件前缀来简化插件的调用，Maven如何根据插件前缀解析得到插件的坐标?
10.2) 插件前缀与groupId：artifactId是一一对应的，这种匹配关系存储在仓库元数据中。
10.3) 与之前提到的groupId/artifactId/maven-metadata.xml不同，这里的仓库元数据为groupId/maven-metadata.xml
10.4) 默认使用org.apache.maven.plugins和org.codehaus.mojo两个groupId。 因为主要的插件都位于http://repo1.maven.org/maven2/org/apache/maven/plugins/和http://repository.codehaus.org/org/codehaus/mojo/；也可以通过配置settings.xml让Maven检查其他groupId上的插件仓库元数据：
<pluginGroups>
   <pluginGroup>com.your.plugins</pluginGroup>
</pluginGroups>
10.5）基于该配置，Maven就不仅仅会检查org/apache/maven/plugins/maven-metadata.xml和org/codehaus/mojo/maven-metadata.xml，还会检查com/your/plugins/maven-metadata.xml。
10.6）从中央仓库的org.apache.maven.plugins groupId下插件仓库元数据中截取的一些片段：http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-metadata.xml
<plugin>
    <name>Apache Maven Clean Plugin</name>
    <prefix>clean</prefix>
    <artifactId>maven-clean-plugin</artifactId>
</plugin>
<plugin>
    <name>Maven Clover Plugin</name>
    <prefix>clover</prefix>
    <artifactId>maven-clover-plugin</artifactId>
</plugin>
<plugin>
    <name>Apache Maven Compiler Plugin</name>
    <prefix>compiler</prefix>
    <artifactId>maven-compiler-plugin</artifactId>
</plugin>
10.7）从这段数据中就能看到maven-clean-plugin的前缀为clean，maven-compilerplugin的前缀为compiler，maven-dependency-plugin的前缀为dependency。
10.8）完整过程：当Maven解析到dependency：tree这样的命令后，它首先基于默认的groupId归并所有插件仓库的元数据org/apache/maven/plugins/maven-metadata.xml； 其次检查归并后的元数据，找到对应的artifactId为maven-dependency-plugin；然后结合当前元数据的groupId org.apache.maven.plugins；解析得到version， 这时就得到了完整的插件坐标。如果org/apache/maven/plugins/maven-metadata.xml 没有记录该插件前缀，则接着检查其他groupId下的元数据，如org/codehaus/mojo/maven-metadata.xml，以及用户自定义的插件组。 如果所有元数据中都不包含该前缀，则报错。

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
- 在命令行运行mvn -h 来显示mvn命令帮助:
usage: mvn [options] [<goal(s)>] [<phase(s)>]
Options:
...
- 该信息告诉了我们mvn命令的基本用法，options表示可用的选项，mvn命令有20多个选项。
- 除了选项之s外，mvn命令后面可以添加一个或者多个goal和phase，它们分别是指插件目标和生命周期阶段。
- 第7.2.5节已经详细介绍了如何通过该参数控制Maven的生命周期。现在我们关心的是另外一个参数：goal。
- 我们知道，可以通过mvn命令激活生命周期阶段，从而执行那些绑定在生命周期阶段上的插件目标。
- 但Maven还支持直接从命令行调用插件目标。Maven支持这种方式是因为有些任务不适合绑定在生命周期上，
- 例如maven-help-plugin：describe，我们不需要在构建项目的时候去描述插件信息，又如maven-dependency-plugin：tree，我们也不需要在构建项目的时候去显示依赖树。因此这些插件目标应该通过如下方式使用：
mvn org.apache.maven.plugins:maven-help-plugin:describe -Dplugin=compiler == mvn help:describe -Dplugin=compiler
mvn org.apache.maven.plugins:maven-dependency-plugin:2.1:tree == mvn dependency：tree
- Maven引入了目标前缀的概念，help是maven-help-plugin的目标前缀，dependency是maven-dependency-plugin的前缀，有了插件前缀，Maven就能找到对应的artifactId。不过，除了artifactId，Maven还需要得到groupId和version才能精确定位到某个插件

#插件解析机制
- 为了方便用户使用和配置插件，Maven不需要用户提供完整的插件坐标信息，就可以解析得到正确的插件，Maven的这一特性是一把双刃剑，虽然它简化了插件的使用和配置，可一旦插件的行为出现异常，用户就很难快速定位到出问题的插件构件。
- 例如mvn help：system 这样一条命令，它到底执行了什么插件？该插件的groupId、artifactId和version分别是什么？这个构件是从哪里来的？本节就详细介绍Maven的运行机制，以让读者不仅知其然，更知其所以然。

#　插件仓库
- 与依赖构件一样，插件构件同样基于坐标存储在Maven仓库中。在需要的时候，Maven会从本地仓库寻找插件，如果不存在，则从远程仓库查找。找到插件之后，再下
载到本地仓库使用。
- 值得一提的是，Maven会区别对待依赖的远程仓库与插件的远程仓库，第6.4节介绍了如何配置远程仓库，但那种配置只对一般依赖有效果。
- 当Maven需要的依赖在本地仓库不存在时，它会去所配置的远程仓库查找，可是当Maven需要的插件在本地仓库不存在时，它就不会去这些远程仓库查找。
- 不同于repositories及其repository子元素，插件的远程仓库使用pluginRepositories和pluginRepository配置。例如，Maven内置了如下的插件远程仓库配置:
<pluginRepositories>
    <pluginRepository>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
      <layout>default</layout>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
    </pluginRepository>
</pluginRepositories>

- 除了pluginRepositories和pluginRepository标签不同之外，其余所有子元素表达的含义与第6.4节所介绍的依赖远程仓库配置完全一样。
- 我们甚至看到，这个默认插件仓库的地址就是中央仓库，它关闭了对SNAPSHOT的支持，以防止引入SNAPSHOT版本的插件而导致不稳定的构建。
- 一般来说，中央仓库所包含的插件完全能够满足我们的需要，因此也不需要配置其他的插件仓库。只有在很少的情况下，项目使用的插件无法在中央仓库找到，或者
自己编写了插件，这个时候可以参考上述的配置，在POM或者settings.xml中加入其他的插件仓库配置。

#插件的默认groupId
在POM中配置插件的时候，如果该插件是Maven的官方插件（即如果其groupId为org.apache.maven.plugins），就可以省略groupId配置:
<plugin>
    <!--<groupId>org.apache.maven.plugins</groupId>-->
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.5</source>
        <target>1.5</target>
    </configuration>
</plugin>
- 上述配置中省略了maven-compiler-plugin的groupId，Maven在解析该插件的时候，会自动用默认groupId org.apache.maven.plugins补齐。
- 不推荐使用Maven的这一机制，虽然这么做可以省略一些配置，但这样的配置会让团队中不熟悉Maven的成员感到费解

#解析插件版本
- 同样是为了简化插件的配置和使用，在用户没有提供插件版本的情况下，Maven会自动解析插件版本
- 首先，Maven在超级POM中为所有核心插件设定了版本，超级POM是所有Maven项目的父POM，所有项目都继承这个超级POM的配置，
- 因此，即使用户不加任何配置，Maven使用核心插件的时候，它们的版本就已经确定了。这些插件包括maven-clean-plugin、maven-compiler-plugin、maven-surefire-plugin等。
- 如果用户使用某个插件时没有设定版本，而这个插件又不属于核心插件的范畴，Maven就会去检查所有仓库中可用的版本，然后做出选择。
- 读者可以回顾一下第6.6节中介绍的仓库元数据groupId/artifactId/maven-metadata.xml。以maven-compiler-plugin为例，它在中央仓库的仓库元数据
为http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-compiler-plugin/maven-metadata.xml:
<metadata>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <versioning>
        <latest>3.7.0</latest>
        <release>3.7.0</release>
        <versions>
            <version>2.0-beta-1</version>
            <version>2.0</version>
            <version>2.0.1</version>
            <version>2.0.2</version>
            <version>2.1</version>
            <version>2.2</version>
            <version>2.3</version>
            <version>2.3.1</version>
            <version>2.3.2</version>
            <version>2.4</version>
            <version>2.5</version>
            <version>2.5.1</version>
            <version>3.0</version>
            <version>3.1</version>
            <version>3.2</version>
            <version>3.3</version>
            <version>3.5</version>
            <version>3.5.1</version>
            <version>3.6.0</version>
            <version>3.6.1</version>
            <version>3.6.2</version>
            <version>3.7.0</version>
        </versions>
        <lastUpdated>20170904193138</lastUpdated>
    </versioning>
</metadata>

- Maven 3调整了解析机制，当插件没有声明版本的时候，不再解析至latest，而是使用release。这样就可以避免由于快照频繁更新而导致的插件行为不稳定。
- 依赖Maven解析插件版本其实是不推荐的做法，即使Maven 3将版本解析到最新的非快照版，也还是会有潜在的不稳定性。
- 例如，可能某个插件发布了一个新的版本，而这个版本的行为与之前的版本发生了变化，这种变化就可能导致项目构建失败。因此，使用插件的时候，应该一直显式地设定版本，这也解释了Maven为什么要在超级POM中为核心插件设定版本。

#解析插件前缀
- 前面讲到mvn命令行支持使用插件前缀来简化插件的调用，现在解释Maven如何根据插件前缀解析得到插件的坐标。
- 插件前缀与groupId：artifactId是一一对应的，这种匹配关系存储在仓库元数据中。
- 与之前提到的groupId/artifactId/maven-metadata.xml不同，这里的仓库元数据为groupId/maven-metadata.xml，那么这里的groupId是什么呢？ 
- 第7.6.1节提到主要的插件都位于http://repo1.maven.org/maven2/org/apache/maven/plugins/和http://repository.codehaus.org/org/codehaus/mojo/ ，相应地，Maven在解析插件仓库元数据的时候，会默认使用org.apache.maven.plugins和org.codehaus.mojo两个groupId。也可以通过配置settings.xml让Maven检查其他groupId上的插件仓库元数据：
<pluginGroups>
   <pluginGroup>com.your.plugins</pluginGroup>
</pluginGroups>
- 基于该配置，Maven就不仅仅会检查org/apache/maven/plugins/maven-metadata.xml和org/codehaus/mojo/maven-metadata.xml，还会检查com/your/plugins/maven-metadata.xml。

http://repo1.maven.org/maven2/org/apache/maven/plugins/maven-metadata.xml
<plugin>
    <name>Apache Maven Clean Plugin</name>
    <prefix>clean</prefix>
    <artifactId>maven-clean-plugin</artifactId>
</plugin>
<plugin>
    <name>Maven Clover Plugin</name>
    <prefix>clover</prefix>
    <artifactId>maven-clover-plugin</artifactId>
</plugin>
<plugin>
    <name>Apache Maven Compiler Plugin</name>
    <prefix>compiler</prefix>
    <artifactId>maven-compiler-plugin</artifactId>
</plugin>
- 上述内容是从中央仓库的org.apache.maven.pluginsgroupId下插件仓库元数据中截取的一些片段，从这段数据中就能看到maven-clean-plugin的前缀为clean，
maven-compilerplugin的前缀为compiler，maven-dependency-plugin的前缀为dependency。
- 当Maven解析到dependency：tree这样的命令后，它首先基于默认的groupId归并所有插件仓库的元数据org/apache/maven/plugins/maven-metadata.xml；其次检查归并后的元
数据，找到对应的artifactId为maven-dependency-plugin；然后结合当前元数据的groupId org.apache.maven.plugins；最后使用第7.8.3节描述的方法解析得到version， 这时就得到了完整的插件坐标。如果org/apache/maven/plugins/maven-metadata.xml没有记录该插件前缀，则接着检查其他groupId下的元数据，如org/codehaus/mojo/maven-metadata.xml，以及用户自定义的插件组。如果所有元数据中都不包含该前缀，则报错。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Chapter8 聚合与继承
- 软件本身也变得越来越复杂,往往会需要划分模块，以得到更清晰的设计及更高的重用性。
- 当把Maven应用到实际项目中的时候，也需要将项目分成不同的模块，本书的背景案例账户注册服务就被划分成了accountemail、account-persist等五个模块。
- Maven的聚合特性能够把项目的各个模块聚合在一起构建，
- 而Maven的继承特性则能帮助抽取各模块相同的依赖和插件等配置，在简化POM的同时，还能促进各个模块配置的一致性。
- account-persist: 在讨论多模块Maven项目的聚合与继承之前，本书先引入账户注册服务的account-persist模块。该模块负责账户数据的持久化，以XML文件的形式保存账户数据，并支持账户的创建、读取、更新、删除等操作。
- account-persist的POM
- 该模块groupId和version与account-email模块完全一致，而且artifactId也有相同的前缀。
- 一般来说，一个项目的子模块都应该使用同样的groupId，如果它们一起开发和发布，还应该使用同样的version，此外，它们的artifactId
还应该使用一致的前缀，以方便同其他项目区分。
- 接着是build元素，它先是包含了一个testResources子元素，这是为了开启资源过滤。
- build元素下还包含了两个插件的配置。首先是配置maven-compiler-plugin支持Java1.5，我们知道，虽然这里没有配置插件版本，但由于maven-compiler-plugin是核心插件，它的版本已经在超级POM中设定了。
- 如果这里不配置groupId，会使用默认的groupId org.apache.maven.plugins。
- 除了maven-compiler-plugin， 这里还配置了mavenre-sources-plugin使用UTF-8编码处理资源文件。

- SpringFramework的定义要求项目classpath下有一个名为account-service.properties的文件，并且该文件中需要包含一个persist.file属性，以定义文件存储的位置。为了能够测试账户数据的持久化，在测试资源目录下创建属性文件account-service.properties。
- persist.file=${project.build.testOutputDirectory}/persist-data.xml
- persist.file包含了＄{project.build.testOutputDirectory}。这是一个Maven属性，表示了Maven的测试输出目录， 其默认的地址为项目根目录下的target/test-classes文件夹。

#聚合
- 到目前为止，本书实现了用户注册服务的两个模块，它们分别是account-email和account-persist。
- 一个简单的需求就会自然而然地显现出来：我们会想要一次构建两个项目，而不是到两个模块的目录下分别执行mvn命令。
- Maven聚合（或者称为多模块）这一特性就是为该需求服务的。
- 为了能够使用一条命令就能构建account-email和account-persist两个模块，我们需要创建一个额外的名为account-aggregator的模块，然后通过该模块构建整个项目的所有模块。
- account-aggregator本身作为一个Maven项目，它必须要有自己的POM，不过，同时作为一个聚合项目，其POM又有特殊的地方。
- 如下为account-aggregator的pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-aggregator</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>Account Aggregator</name>
  <modules>
    <module>account-email</module>
    <module>account-persist</module>
    <module>account-parent</module>
  </modules>
</project>
- 上述POM依旧使用了账户注册服务共同的groupId com.juvenxu.mvnbook.account，artifactId为独立的account-aggregator， 
- 版本也与其他两个模块一致， 为1.0.0-SNAPSHOT。 
- 这里的第一个特殊的地方为packaging，其值为POM。 回顾account-email和account-persist，它们都没有声明packaging，即使用了默认值jar。 
- 对于聚合模块来说，其打包方式packaging的值必须为pom，否则就无法构建。
- POM的name字段是为了给项目提供一个更容易阅读的名字。
- 之后是本书之前都没提到过的元素modules，这是实现聚合的最核心的配置。 
- 用户可以通过在一个打包方式为pom的Maven项目中声明任意数量的module元素来实现模块的聚合。
- 这里每个module的值都是一个当前POM的相对目录，譬如该例中，account-aggregator的POM的路径为D：\…\code\ch-8\account-aggregator\pom.xml，那么account-email就对应了目录D：\…\code\ch-8\account-aggregator\account-email/，而account-persist对应于目录D：\…\code\ch-
8\account-aggregator\account-persist/。 这两个目录各自包含了pom.xml、src/main/java/、src/test/java/等内容， 离开account-aggregator也能独立构建。
- 一般来说，为了方便快速定位内容，模块所处的目录名称应当与其artifactId一致，不过这不是Maven的要求，用户也可以将account-email项目放到email-account/目录下。
- 这时，聚合的配置就需要相应地改成<module>email-account</module>。
- 了方便用户构建项目，通常将聚合模块放在项目目录的最顶层，其他模块则作为聚合模块的子目录存在，这样当用户得到源码的时候，第一眼发现的就是聚合模块
的POM，不用从多个模块中去寻找聚合模块来构建整个项目。
- account-aggregator的内容仅是一个pom.xml文件，它不像其他模块那样有src/main/java、src/test/java等目录。 因为聚合模块仅仅是帮助聚合其他模块构建的工具， 它本身并无实质的内容。
- 关于目录结构还需要注意的是，聚合模块与其他模块的目录结构并非一定要是父子关系
- 如果使用平行目录结构，聚合模块的POM也需要做相应的修改，以指向正确的模块目录：
<modules>
    <module>../account-email</module>
    <module>../account-persist</module>
    <module>../account-parent</module>
</modules>
- mvn clean install
- 首先解析聚合模块的POM、分析要构建的模块、并计算出一个反应堆构建顺序（Reactor Build Order），然后根据这个顺序依次构建各个模块。 
- 反应堆是所有模块组成的一个构建结构。
- 上述输出中显示的是各模块的名称，而不是artifactId，这也解释了为什么要在POM中配置合理的name字段，其目的是让Maven的构建输出更清晰。

#继承
- 到目前为止，我们已经能够使用Maven的聚合特性通过一条命令同时构建account-email和account-persist两个模块，不过这仅仅解决了多模块Maven项目的一个问题。
- 这两个POM有着很多相同的配置，有相同的groupId和version，有相同的spring-core、spring-beans、spring-context
和junit依赖，还有相同的maven-compiler-plugin与maven-resources-plugin配置。这是重复！
- 在Maven的世界中，也有类似的机制能让我们抽取出重复的配置，这就是POM的继承。

#account-parent
- 向对象设计中，程序员可以建立一种类的父子结构，然后在父类中声明一些字段和方法供子类继承，这样就可以做到“一处声明，多处使用”。
- 我们需要创建POM的父子结构，然后在父POM中声明一些配置供子POM继承，以实现“一处声明，多处使用”的目的。
- 在account-aggregator下创建一个名为account-parent的子目录，然后在该子目录下建立一个所有除account-aggregator之外模块的父模
块。为此，在该子目录创建一个pom.xml文件:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-parent</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>Account Parent</name>  
</project>
- 该POM使用了与其他模块一致的groupId和version，使用的artifactId为account-parent表示这是一个父模块。
- packaging为pom，这一点与聚合模块一样，作为父模块的POM，其打包类型也必须为pom。
- 由于父模块只是为了帮助消除配置的重复，因此它本身不包含除POM之外的项目文件，也就不需要src/main/java/之类的文件夹了。
- 有了父模块，就需要让其他模块来继承它。首先将account-email的POM修改如下:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>  
  <parent>
    <groupId>com.juvenxu.mvnbook.account</groupId>
    <artifactId>account-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <relativePath>../account-parent/pom.xml</relativePath>
  </parent>
  
  <artifactId>account-email</artifactId>
  <name>Account Email</name>

  <dependencies>
    ...
  </dependencies>

  <build>
    <plugins>
    ...
    </plugins>
  </build>
</project>
- 上述POM中使用parent元素声明父模块，parent下的子元素groupId、artifactId和version指定了父模块的坐标，这三个元素是必须的。元素relativePath表示父模块POM的相对路径，该例中的../account-parent/pom.xml表示父POM的位置在与account-email/目录平行的account-parent/目录下。 
- 当项目构建时，Maven会首先根据relativePath检查父POM，如果找不到，再从本地仓库查找。relativePath的默认值是../pom.xml， 也就是说， Maven默认父POM在上一层目录下。正确设置relativePath非常重要。
- 考虑这样一个情况，开发团队的新成员从源码库签出一个包含父子模块关系的Maven项目。由于只关心其中的某一个子模块，它就直接到该模块的目录下执行构建，这个时候，父模块是没有被安装到本地仓库的，因此如果子模块没有设置正确的relativePath，Maven将无法找到父POM，这将直接导致构建失败。如果Maven能够根据relativePath找到父POM，它就不需要再去检查本地仓库。
- 这个更新过的POM没有为account-email声明groupId和version，不过这并不代表account-email没有groupId和version。实际上，这个子模块隐式地从父模块继承了这两个元素，这也就消除了一些不必要的配置。在该例中，父子模块使用同样的groupId和version，如果遇到子模块需要使用和父模块不一样的groupId或者version的情况，那么用户完全可以在子模块中显式声明。
- 对于artifactId元素来说，子模块应该显式声明，一方面，如果完全继承groupId、artifactId和version，会造成坐标冲突；另一方面，即使使用
不同的groupId或version，同样的artifactId容易造成混淆。
- 以下是account-persist更新后的POM:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>  
  <parent>
    <groupId>com.juvenxu.mvnbook.account</groupId>
    <artifactId>account-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <relativePath>../account-parent/pom.xml</relativePath>
  </parent>  
  <artifactId>account-persist</artifactId>
  <name>Account Persist</name>

  <dependencies>
    ...
  </dependencies>

  <build>
    <testResources>
      <testResource>
        <directory>src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
  </build>

- 还需要把account-parent加入到聚合模块account-aggregator中
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-aggregator</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>Account Aggregator</name>
  <modules>
    <module>account-email</module>
    <module>account-persist</module>
    <module>account-parent</module>
  </modules>
</project>

#可继承的POM元素
- groupId和version是可以被继承的，那么还有哪些POM元素可以被继承呢?
·groupId：项目组ID，项目坐标的核心元素。
·version：项目版本，项目坐标的核心元素。
·description：项目的描述信息。
·organization：项目的组织信息。
·inceptionYear：项目的创始年份。
·url：项目的URL地址。
·developers：项目的开发者信息。
·contributors：项目的贡献者信息。
·distributionManagement：项目的部署配置。
·issueManagement：项目的缺陷跟踪系统信息。
·ciManagement：项目的持续集成系统信息。
·scm：项目的版本控制系统信息。
·mailingLists：项目的邮件列表信息。
·properties：自定义的Maven属性。
·dependencies：项目的依赖配置。
·dependencyManagement：项目的依赖管理配置。
·repositories：项目的仓库配置。
·build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等。
·reporting：包括项目的报告输出目录配置、报告插件配置等。

#依赖管理
- 可继承元素列表包含了dependencies元素，说明依赖是会被继承的，这时我们就会很容易想到将这一特性应用到account-parent中。子模块account-email和
account-persist同时依赖了org.springframework：spring-core：2.5.6、org.springframework：spring-beans：2.5.6、org.springframework：spring-context：2.5.6和junit：junit：4.7，因此可以将这些依赖配置放到父模块account-parent中，两个子模块就能移除这些依赖，简化配置。
- 上述做法是可行的，但却存在问题。到目前为止，我们能够确定这两个子模块都包含那四个依赖，不过我们无法确定将来添加的子模块就一定需要这四个依赖。 假设将来项目中需要加入一个account-util模块，该模块只是提供一些简单的帮助工具，与springframework完全无关，难道也让它依赖spring-core、spring-beans和spring-context吗？那显然是不合理的。
- Maven提供的dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。
- 在dependencyManagement元素下的依赖声明不会引入实际的依赖，不过它能够约束dependencies下的依赖使用。例如，可以在account-parent中加入这样的dependencyManagement配置:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-parent</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>Account Parent</name>
  <properties>
    <springframework.version>2.5.6</springframework.version>
    <junit.version>4.7</junit.version>
  </properties>
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-support</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
      </dependency>
    </dependencies>
  </dependencyManagement> 
</project>
- 首先该父POM将springframework和junit依赖的版本以Maven变量的形式提取了出来，不仅消除了一些重复，也使得各依赖的版本处于更加明显的位置。 
- 这里使用dependencyManagement声明的依赖既不会给account-parent引入依赖，也不会给它的子模块引入依赖，不过这段配置是会被继承的。
- 现在修改account-email的POM如下:
<properties>
    <javax.mail.version>1.4.1</javax.mail.version>
    <greenmail.version>1.3.1b</greenmail.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>    
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-beans</artifactId>     
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>     
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context-support</artifactId>     
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>javax.mail</groupId>
      <artifactId>mail</artifactId>
      <version>${javax.mail.version}</version>
    </dependency>   
    <dependency>
      <groupId>com.icegreen</groupId>
      <artifactId>greenmail</artifactId>
      <version>${greenmail.version}</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
- 上述POM中的依赖配置较原来简单了一些，所有的springframework依赖只配置了groupId和artifactId，省去了version，而junit依赖不仅省去了version，还省去了依赖范围scope。
- 这些信息可以省略是因为account-email继承了account-parent中的dependencyManagement配置，完整的依赖声明已经包含在父POM中，子模块只需要配置简单的groupId和artifactId就能获得对应的依赖信息，从而引入正确的依赖。
- 使用这种依赖管理机制似乎不能减少太多的POM配置，但父POM中使用dependencyManagement声明依赖能够统一项目范围中依赖的版本，当依赖版本在父POM中声明之后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用依赖版本不一致的情况。这可以帮助降低依赖冲突的几率。
- 如果子模块不声明依赖的使用，即使该依赖已经在父POM的dependencyManagement中声明了，也不会产生任何实际的效果：
<properties>
    <dom4j.version>1.6.1</dom4j.version>
</properties>
<dependencies>
  <dependency>
    <groupId>dom4j</groupId>
    <artifactId>dom4j</artifactId>
    <version>${dom4j.version}</version>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
  </dependency>
  <dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
  </dependency>
</dependencies>
- 这里没有声明spring-context-support，那么该依赖就不会被引入。这正是dependencyManagement的灵活性所在。

- 在介绍依赖范围的时候提到了名为import的依赖范围，推迟到现在介绍是因为该范围的依赖只在dependencyManagement元素下才有效果
- 使用该范围的依赖通常指向一个POM，作用是将目标POM中的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中。
- 例如想要在另外一个模块中使用与代码清单8-14完全一样的dependencyManagement配置，除了复制配置或者继承这两种方式之外，还可以使用import范围依赖将这一配置导入:
- 使用import范围依赖导入依赖管理配置
<dependencyManagement>
  <dependencies>
    <groupId>com.juvenxu.mvnbook.account</groupId>
    <artifactId>account-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <type>pom</type>
    <scope>import</scope>
   ...
</dependencyManagement>
- 上述代码中依赖的type值为pom，import范围依赖由于其特殊性，一般都是指向打包类型为pom的模块。
- 如果有多个项目，它们使用的依赖版本都是一致的，则就可以定义一个使用dependencyManagement专门管理依赖的POM，然后在各个项目中导入这些依赖管理配置。

#插件管理
- Maven提供了dependencyManagement元素帮助管理依赖，类似地，Maven也提供了pluginManagement元素帮助管理插件。
- 在该元素中配置的依赖不会造成实际的插件调用行为，当POM中配置了真正的plugin元素，并且其groupId和artifactId与pluginManagement中配置的插件匹配时，pluginManagement的配置才会影响实际的插件行为。
- 7.4.2节中配置了maven-source-plugin，将其jar-no-fork目标绑定到了verity生命周期阶段，以生成项目源码包。
- 如果一个项目中有很多子模块，并且需要得到所有这些模块的源码包，那么很显然，为所有模块重复类似的插件配置不是最好的办法。这时更好的方法是在父POM中使用pluginManagement配置插件，
- 在父POM中配置pluginManagement：
<build>
  <pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-source-plugin</artifactId>
        <version>2.1.1</version>
        <executions>
            <execution>
                <id>attach-sources</id>
                <phase>verify</phase>
                <goals>
                    <goal>jar-no-fork</goal>
                </goals>
            </execution>
        </executions>
      </plugin>
    </plugins>
  </pluginManagement>
</build>

- 当子模块需要生成源码包的时候，只需要如下简单的配置：
<build>  
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-source-plugin</artifactId>        
      </plugin>
    </plugins>
</build>
- 子模块声明使用了maven-source-plugin插件，同时又继承了父模块的pluginManagement配置，两者基于groupId和artifactId匹配合并之后就相当于7.4.2节中的插件配置。
- 如果子模块不需要使用父模块中pluginManagement配置的插件，可以尽管将其忽略。
- 如果子模块需要不同的插件配置，则可以自行配置以覆盖父模块的pluginManagement配置。

- 有了pluginManagement元素，account-email和account-persist的POM也能得以简化了，它们都配置了maven-compiler-plugin和maven-resources-plugin。可以将这两个插件的配置移到account-parent的pluginManagement元素中
<build>
  <pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>1.5</source>
          <target>1.5</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-resources-plugin</artifactId>
        <configuration>
          <encoding>UTF-8</encoding>
        </configuration>
      </plugin>
    </plugins>
  </pluginManagement>
</build>

- account-email和account-persist可以完全地移除关于maven-compiler-plugin和maven-resources-plugin的配置，但它们仍能享受这两个插件的服务，前一插件开启了Java 5编译的支持，后一插件也会使用UTF-8编码处理资源文件。
- 这背后涉及了很多Maven机制，首先，内置的插件绑定关系将两个插件绑定到了account-email和account-persist的生命周期上；
- 其次，超级POM为这两个插件声明了版本；
- 最后，account-parent中的pluginManagement对这两个插件的行为进行了配置。
- 当项目中的多个模块有同样的插件配置时，应当将配置移到父POM的pluginManagement元素中。即使各个模块对于同一插件的具体配置不尽相同，也应当使用父POM的pluginManagement元素统一声明插件的版本。甚至可以要求将所有用到的插件的版本在父POM的pluginManagement元素中声明，子模块使用插件时不配置版本信息，这么做可以统一项目的插件版本，避免潜在的插件不一致或者不稳定问题，也更易于维护。

#聚合与继承的关系
- 多模块Maven项目中的聚合与继承其实是两个概念，其目的完全是不同的。
- 前者主要是为了方便快速构建项目，后者主要是为了消除重复配置。
- 对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。
- 对于继承关系的父POM来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父POM是什么。
- 如果非要说这两个特性的共同点，1)聚合POM与继承关系中的父POM的packaging都必须是pom，2)聚合模块与继承关系中的父模块除了POM之外都没有实际的内容，
- 在现有的实际项目中，读者往往会发现一个POM既是聚合POM，又是父POM，这么做主要是为了方便。
- 一般来说，融合使用聚合与继承也没有什么问题，例如可以将account-aggregator和account-parent合并成一个新的account-parent:
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-parent</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>Account Parent</name>
  <modules>
    <module>account-email</module>
    <module>account-persist</module>
  </modules>
  <properties>
    <springframework.version>2.5.6</springframework.version>
    <junit.version>4.7</junit.version>
  </properties>  
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-support</artifactId>
        <version>${springframework.version}</version>
      </dependency>
      <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <configuration>
            <source>1.5</source>
            <target>1.5</target>
          </configuration>
        </plugin>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-resources-plugin</artifactId>
          <configuration>
            <encoding>UTF-8</encoding>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
- 该POM的打包方式为pom，
- 包含了一个modules元素，表示用来聚合account-persist和account-email两个模块，
- 还包含了properties、dependencyManagement和pluginManagement元素供子模块继承。
- 相应地，account-email和account-persist的POM配置也要做微小的修改。本来account-parent和它们位于同级目录，因此需要使用值为../account-parent/pom.xml的relativePath元素。现在新的account-parent在上一层目录， 这是Maven默认能识别的父模块位置， 因此不再需要配置relativePath，
- 当父模块在上级目录时不再需要relativePath

<parent>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>account-parent</artifactId>
  <version>1.0.0-SNAPSHOT</version>
</parent>

<artifactId>account-email</artifactId>
<name>Account Email</name>

#约定优于配置
- Maven提倡“约定优于配置”（Convention Over Configuration），这是Maven最核心的设计理念之一。
- 那么为什么要使用约定而不是自己更灵活的配置呢？原因之一是，使用约定可以大量减少配置。先看一个简单的Ant配置文件：
- 这段代码做的事情就是清除构建目录、创建目录、编译代码、复制依赖至目标目录，最后打包。这是一个项目构建要完成的最基本的事情，不过为此还是需要写很多的XML配置：源码目录是什么、编译目标目录是什么、分发目录是什么，等等。用户还需要记住各种Ant任务命令，如delete、mkdir、javac和jar。 
- 做同样的事情，Maven需要什么配置呢？Maven只需要一个最简单的POM
- 构建简单项目使用的Maven配置文件
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>my-project</artifactId>
  <version>1.0</version>
</project>
- 这段配置简单得令人惊奇，但为了获得这样简洁的配置，用户是需要付出一定的代价的，那就是遵循Maven的约定。 Maven会假设用户的项目是这样的：
·源码目录为src/main/java/
·编译输出目录为target/classes/
·打包方式为jar
·包输出目录为target/
- 遵循约定虽然损失了一定的灵活性，用户不能随意安排目录结构，但是却能减少配置。
- 更重要的是，遵循约定能够帮助用户遵守构建标准。
- 如果没有约定，10个项目可能使用10种不同的项目目录结构，这意味着交流学习成本的增加，当新成员加入项目的时候，它就不得不花时间去学习这种构建配置。而有了Maven的约定，大家都知道什么目录放什么内容。
- 此外，与Ant的自定义目标名称不同，Maven在命令行暴露的用户接口是统一的，像mvn clean install这样的命令可以用来构建几乎任何的 Maven项目。
- 也许这时候有读者会问，如果我不想遵守约定该怎么办？这时，请首先问自己三遍，你真的需要这么做吗？如果仅仅是因为喜好，就不要耍个性，个性往往意味着牺牲通用性，意味着增加无谓的复杂度。
- Maven允许你自定义源码目录:
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>my-project</artifactId>
  <version>1.0</version>
  <build>
    <sourceDirectory>src/java</sourceDirectory>
  </build>
</project>
- 该例中源码目录就成了src/java而不是默认的src/main/java。但这往往会造成交流问题，习惯Maven的人会奇怪，源代码去哪里了？ 当这种自定义大量存在的时候， 交流成本就会大大提高。
- 只有在一些特殊的情况下，这种自定义配置的方式才应该被正确使用以解决实际问题。例如你在处理遗留代码，并且没有办法更改原来的目录结构，
这个时候就只能让Maven妥协。
- 本书曾多次提到超级POM，任何一个Maven项目都隐式地继承自该POM，这有点类似于任何一个Java类都隐式地继承于Object类。因此，大量超级POM的配置都会被所有Maven项目继承，这些配置也就成为了Maven所提倡的约定。

- 对于Maven 3，超级POM在文件＄MAVEN_HOME/lib/maven-model-builder-x.x.x.jar中的org/apache/maven/model/pom-4.0.0.xml路径下：
- 超级POM中关于仓库的定义:
  <repositories>
    <repository>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
      <layout>default</layout>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
    </repository>
  </repositories>

  <pluginRepositories>
    <pluginRepository>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
      <layout>default</layout>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
    </pluginRepository>
  </pluginRepositories>
- 首先超级POM定义了仓库及插件仓库，两者的地址都为中央仓库https://repo.maven.org/maven2 ，并且都关闭了SNAPSHOT的支持。 这也就解释了为什么Maven默认就可以按需要从中央仓库下载构件。
- 超级POM中关于项目结构的定义:
  <build>
    <directory>${project.basedir}/target</directory>
    <outputDirectory>${project.build.directory}/classes</outputDirectory>
    <finalName>${project.artifactId}-${project.version}</finalName>
    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>
    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>
    <scriptSourceDirectory>${project.basedir}/src/main/scripts</scriptSourceDirectory>
    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>
    <resources>
      <resource>
        <directory>${project.basedir}/src/main/resources</directory>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>${project.basedir}/src/test/resources</directory>
      </testResource>
    </testResources>
   ...
  </build>
- 依次定义了项目的主输出目录、主代码输出目录、最终构件的名称格式、测试代码输出目录、主源码目录、脚本源码目录、测试源码目录、主资源目录和测试资源目录。这就是Maven项目结构的约定。
- ？？ ${project.basedir}从哪里获得？
- 　超级POM中关于插件版本的定义：
    <pluginManagement>
      <!-- NOTE: These plugins will be removed from future versions of the super POM -->
      <!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) -->
      <plugins>
        <plugin>
          <artifactId>maven-antrun-plugin</artifactId>
          <version>1.3</version>
        </plugin>
        <plugin>
          <artifactId>maven-assembly-plugin</artifactId>
          <version>2.2-beta-5</version>
        </plugin>
        <plugin>
          <artifactId>maven-dependency-plugin</artifactId>
          <version>2.8</version>
        </plugin>
        <plugin>
          <artifactId>maven-release-plugin</artifactId>
          <version>2.3.2</version>
        </plugin>
      </plugins>
    </pluginManagement>

- Maven设定核心插件的原因是防止由于插件版本的变化而造成构建不稳定。 
- 超级POM的最后是关于项目报告输出目录的配置和一个关于项目发布的profile
- 从超级POM能够知晓Maven约定的由来，不仅理解了什么是约定，为什么要遵循约定，还能明白约定是如何实现的。
- ??但Maven 3.5 没有默认插件版本, Maven3.5是如何知道使用那个版本的呢？

#Reactor
- 在一个多模块的Maven项目中，Reactor是指所有模块组成的一个构建结构。对于单模块的项目，反应堆就是该模块本身，
- 对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序。

#反应堆的构建顺序
- 首先，为了能更清楚地解释反应堆的构建顺序，将account-aggregator的聚合配置修改如下
- 构建acco上述输出告诉了我们反应堆的构建顺序，它们依次为account-aggregator、account-parent、account-email和account-persist。unt-aggregator会看到如下的输出：上述输出告诉了我们反应堆的构建顺序，它们依次为account-aggregator、account-parent、account-email和account-persist。
- POM的读取次序不足以决定反应堆的构建顺序，Maven还需要考虑模块之间的继承和依赖关系，
- account-email和account-persist依赖于account-parent，那么account-parent就必须先于另外两个模块构建。
- 实际的构建顺序是这样形成的：Maven按序读取POM，如果该POM没有依赖模块，那么就构建该模块，否则就先构建其依赖模块，如果该依赖还依赖于其他模块，则进一步先构建依赖的依赖。 account-aggregator没有依赖模块，因此先构建它，接着到account-email，它依赖于account-parent模块，必须先构建account-parent，然后再构建account-email，最后到account-persist的时候，由于其依赖模块已经被构建，因此直接构建它。

#裁剪反应堆
一般来说，用户会选择构建整个项目或者选择构建单个模块，
- 但有些时候，用户会想要仅仅构建完整反应堆中的某些个模块。换句话说，用户需要实时地裁剪反应堆。
- Maven提供很多的命令行选项支持裁剪反应堆，输入mvn -h可以看到这些选项：
·-am，--also-make同时构建所列模块的依赖模块
·-amd --also-make-dependents同时构建依赖于所列模块的模块
·-pl，--projects<arg> 构建指定的模块，模块间用逗号分隔
·-rf-resume-from<arg>从指定的模块回复反应堆
- 默认情况从account-aggregator执行mvn clean install 会得到如下完整的反应堆：
Reactor Build Order:
Account Parent
Account Email
Account Persist
Account Aggregator]
- 使用-pl选项指定构建某几个模块: mvn clean install -pl account-email,account-persist
Reactor Build Order:
Account Email
Account Persist
- 使用-am选项可以同时构建所列模块的依赖模块: mvn clean install -pl account-email -am
Reactor Build Order:
Account Parent
Account Email
- 使用-amd选项可以同时构建依赖于所列模块的模块: mvn clean install -pl account-parent -amd
Reactor Build Order:
Account Parent
Account Email
Account Persist
- 使用-rf (--resume-from)选项可以在完整的反应堆构建顺序基础上指定从哪个模块开始构建: mvn clean install -rf account-email
Reactor Build Order:
Account Email
Account Persist
Account Aggregator
- 在-pl-am或者-pl-amd的基础上，还能应用-rf参数，以对裁剪后的反应堆再次裁剪: 
mvn clean install -pl account-parent -amd -rf account-email
- 在开发过程中，灵活应用上述4个参数，可以帮助我们跳过无须构建的模块，加速构建。在项目庞大、模块特别多的时候，这种效果就会异常明显。

Chapter9  使用Nexus创建私服
- 私服不是Maven的核心概念，它仅仅是一种衍生出来的特殊的Maven仓库
- 通过建立自己的私服，就可以降低中央仓库负荷、节省外网带宽、加速Maven构建、自己部署构件等，从而高效地使用Maven。
- 有三种专门的Maven仓库管理软件可以用来帮助大家建立私服：Apache基金会的Archiva、JFrog的Artifactory和Sonatype的Nexus。
- 其中，Archiva是开源的，而Artifactory和Nexus的核心也是开源的。

-Nexus分为开源版和专业版，其中开源版本基于GPLv3许可证，其特性足以满足大部分Maven用户的需要。以下是一些Nexus开源版本的特性：
·较小的内存占用（最少仅为28MB）
·基于ExtJS的友好界面
·基于Restlet的完全REST API
·支持代理仓库、宿主仓库和仓库组
·基于文件系统，不需要数据库
·支持仓库索引和搜索
·支持从界面上传Maven构件
·细粒度的安全控制

- Nexus专业版本是需要付费购买的，除了开源版本的所有特性之外，它主要包含一些企业安全控制、发布流程控制等需要的特性
- 安装Nexus： Nexus是典型的Java Web应用，它有两种安装包，一种是包含Jetty容器的Bundle包，另一种是不包含Web容器的war包。

#Bundle方式安装Nexus
- Nexus的Bundle自带了Jetty容器，因此用户不需要额外的Web容器就能直接启动Nexus。
- 首先将Bundle文件解压（例如笔者将其解压到D：\bin\目录），这时就会得到如下两个子目录：
·nexus-webapp-1.7.2/： 该目录包含了Nexus运行所需要的文件，如启动脚本、依赖jar包等。
·sonatype-work/： 该目录包含Nexus生成的配置文件、日志文件、仓库文件等。
- 其中，第一个目录是运行Nexus所必需的，而且所有相同版本Nexus实例所包含的该目录内容都是一样的。而第二个目录不是必须的，Nexus会在运行的时候动态创建该目录，不过它的内容对于各个Nexus实例是不一样的，因为不同用户在不同机器上使用的Nexus会有不同的配置和仓库内容。
- 当用户需要备份Nexus的时候，默认备份sonatype-work/目录，因为该目录包含了用户特定的内容， 而nexus-webapp-1.7.2目录下的内容是可以从安装包直接获得的。 用户只需要调用对应操作系统的脚本就可以启动Nexus， 这里介绍主流的在Windows和Linux平台上启动Nexus的方式
- 在Windows操作系统上，用户需进入nexus-3.5.1-02-win64\nexus-3.5.1-02\bin目录
nexus.exe /run
安装：nexus.exe /install
卸载：nexus.exe /unistall
启动：nexus.exe /start
停止：neuxs.exe /stop
- localhost:8081
- right up corner: sign-> admin, admin123

#仓库配置
仓库配置详见官方文档：http://books.sonatype.com/nexus-book/reference3/admin.html#admin-repositories

#Nexus的仓库与仓库组
- 作为Maven仓库服务软件，仓库自然是Nexus中最重要的概念。Nexus包含了各种类型的仓库概念，包括代理仓库、宿主仓库和仓库组等。每一种仓库都提供了丰富实用的配置参数，方便用户根据需要进行定制。
- 点击页面上部的齿轮进入配置页面：
- 单击Nexus界面左边导航栏中的Repositories链接：
- 这个列表已经包含了所有类型的Nexus仓库。
- repository type：group（仓库组）、hosted（宿主）、proxy（代理). 
- format: 每个仓库的格式为maven2, docker, raw, nuget。
- url: 仓库的路径。
- online: ture/false
Maven 2
- version policy: release/snapshot/mixed
- Layout: strict/permissive
Storage:
blob storage: default

maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar 
maven-releases：私库发行版jar 
maven-snapshots：私库快照（调试版本）jar 
maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。

- 举一个简单的例子。假设某公司建立了Maven项目X，公司内部建立了Nexus私服，为所有Maven项目提供服务。
- 项目X依赖于很多流行的开源类库如JUnit等，这些构件都能从Maven中央仓库获得，因此Maven Central代理仓库会被用来代理中央仓库的内容， 并在私服上缓存下来， 
- X还依赖于某个Google Code的项目，其构件在中央仓库中不存在，只存在于Google Code的仓库中，因此上述列表中的Google Code代理仓库会被用来代理并缓存这样的构件。
- X还依赖于Oracle的JDBC驱动，由于版权的因素，该类库无法从公共仓库获得，因此公司管理员将其部署到3rd party宿主仓库中， 供X使用。
- X的快照版本构件成功后，会被部署到Snapshots宿主仓库中，供其他项目使用。当X发布正式版本的时候，其构件会被部署到Release宿主仓库中。
- 由于X用到了上述列表中的很多仓库，为每个仓库声明Maven配置又比较麻烦，因此可以直接使用仓库组Public Repositories和Public Snapshot Repositories，当X需要JUnit的时候，它直接从Public Repositories下载，Public Repositories会选择Maven Central提供实际的内容。

#Nexus仓库分类的概念
- hosted, proxy and group:  
- Maven可以直接从宿主仓库下载构件； 
- Maven也可以从代理仓库下载构件，代理仓库会间接地从远程仓库下载并缓存构件； 
- Maven可以从仓库组下载构件，而仓库组没有实际内容（图中用虚线表示），它会转向其包含的宿主仓库或者代理仓库获得实际构件的内容。

#创建Nexus宿主仓库
- 要创建一个宿主仓库，首先单击界面左边导航栏中的Repositories链接，单击create repository-> select recipe-> maven(hosted)
- 填入仓库的ID和名称，
- version policy，根据自己的需要来配置该仓库是发布版构件仓库(release)还是快照版构件仓库(snapshot) or mixed。
- layout policy??: strict/permissive
- Deployment Policy用来配置该仓库的部署策略，选项有read only只读（禁止部署）、 disable redeploy关闭重新部署（同一构件只能部署一次）以及 allow redploy允许重新部署。
- Storage/Blob store=default: custom repository local storage (you can define custom blob store and ref blob store as storage location)

#创建Nexus代理仓库
- 对于代理仓库来说，最重要的是远程仓库的地址，即Remote Storage，用户必须在这里输入有效的值。
- Authentication: 远程仓库认证配置
- Maximum Component Age: 前者表示构件缓存的最长时间. 对于发布版仓库来说，默认值为-1， 表示构件缓存后就一直保存着，不再重新下载; 对于快照版仓库来说，默认值为1440分钟，表示每隔一天重新缓存代理的构件。
- Maximum Metadata age: 仓库元数据文件缓存的最长时间。
- HTTP Request Settings: Nexus访问远程仓库时HTTP请求的参数

#创建Nexus仓库组
- 要创建一个仓库组，首先单击界面左边导航栏中的Repositories链接，单击create repository
- Name等信息这里不再赘述。 
- 在配置界面中，用户可以非常直观地选择Nexus中仓库，将其聚合成一个虚拟的仓库组。
- 仓库组所包含的仓库的顺序决定了仓库组遍历其所含仓库的次序，因此最好将常用的仓库放在前面，当用户从仓库组下载构件的时候，就能够尽快地访问到包含构件的仓库。

#Nexus的索引与构件搜索
- 既然Nexus能够维护宿主仓库并代理缓存远程仓库（如Maven中央库），那么一个简单的需求就自然浮现出来了，这就是搜索。
- Maven中央库有几十万构件供用户使用，但有时我们往往仅仅知道某个关键字，如Ehcache，而不知道其确切的Maven坐标。
- Nexus通过维护仓库的索引来提供搜索功能，能在很大程度上方便Maven用户定位构件坐标。
- 6.8.1节介绍了Sonatype提供的在线免费搜索服务，其实用户可以很方便地自己维护一个Nexus实例，并提供搜索服务。
- 为了能够搜索Maven中央库，首先需要设置Nexus中的Maven Central代理仓库下载远程索引。需要注意的是，默认这个配置的值是关闭的。 (??) 
- 由于中央库的内容比较多，因此其索引文件比较大，Nexus下载该文件也需要比较长的时间。 可以想象到，Nexus在后台运行了一个任务来下载中央仓库的索引，幸运的是，用户可以通过界面直接观察这一任务的状态。单击界面左边导航栏中的Scheduled Tasks (??)
- 有了索引，用户即可搜索Maven构件了。Nexus界面上部有一个快捷搜索框，在其中输入关键字后，单击搜索按钮就能快速得到搜索结果
- Nexus Repository Manager 3.2 does NOT support usage of remote index for searches (and other purposes) at all. If you want this feature I suggest to stick with Nexus Repository Manager 2 for now.
- 该例使用了ehcache关键字进行搜索，因此得到了大量与ehcache相关的结果，结果中的每一行都表示了一类构件，信息包括GroupId、ArtifactId、最新版本以及最新版本的相关文件下载等。单击其中的某一行，界面的下端会浮出一个更具体的构件信息面板
- 该面板除了显示构件的坐标，还包含了一段XML依赖声明，用户可以直接复制粘贴到项目的POM中。
- 此外，用户还能从该面板获知构件在仓库中的相对位置。
- 除了简单的关键字搜索，Nexus还提供了GAV搜索、类名搜索和校验和搜索等功能，用户可以单击搜索页面左上角的下拉菜单选择高级搜索功能：
·GAV搜索 （GAV Search）允许用户通过设置GroupId、ArtifactId和Version等信息来进行更有针对性的搜索。
·类名搜索 （Classname Search）允许用户搜索包含某个Java类的构件。
·校验和搜索 （Checksum Search）允许用户直接使用构件的校验和来搜索该构件。

#本地maven库配置settings.xml
- 有了中央仓库的索引，用户不仅能够搜索构件，还能够直接浏览中央仓库的内容。这便是Nexus的索引浏览功能。 在Repositories页面中， 选择Browse Index选项卡，就能看到中央仓库内容的树形结构，
- 以上的搜索及浏览功能都是基于Nexus索引而实现的，确切地应该称之为nexus-indexer。Nexus能够遍历一个Maven仓库所有的内容，搜集它们的坐标、校验和及所含的Java类信息，然后以nexus-indexer的形式保存起来。中央仓库维护了这样的一个nexus-indexer，因此本地的Nexus下载到这个索引之后，就能在此基础上提供搜索和浏览等服务。
- 不是任何一个公共仓库都提供nexus-indexer，对于那些不提供索引的仓库来说，我们就无法对其进行搜索。
- 除了下载使用远程仓库的索引，我们也能为宿主仓库和代理仓库建立索引。只需要在仓库上右击，从弹出的快捷菜单中选择ReIndex即可，如图9-15所示。待索引编纂任务完成之后，就能搜索该仓库所包含的构件。
- 对于宿主仓库来说，ReIndex任务会扫描该仓库包含的所有构件建立索引。对于代理仓库来说，ReIndex任务会扫描所有缓存的构件建立索引，如果远程仓库也有索引，则下载后与本地的索引合并。对于仓库组来说，ReIndex任务会合并其包含的所有仓库的索引。

#配置Maven从Nexus下载构件
- 6.4节与7.5.1节已经详细介绍了如何在POM中为Maven配置仓库和插件仓库。例如，当需要为项目添加Nexus私服上的public仓库时:
- 在POM中配置Nexus仓库
<repositories>
    <repository>
      <id>nexus</id>
      <name>Nexus</name>
      <url>http://localhost:8081/repository/maven-public/</url>
      <releases><enabled>true</enabled></releases>
      <snapshots><enabled>true</enabled></snapshots>      
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
      <id>nexus</id>
      <name>Nexus</name>
      <url>http://localhost:8081/repository/maven-public/</url>
      <releases><enabled>true</enabled></releases>
      <snapshots><enabled>true</enabled></snapshots>    
    </pluginRepository>
</pluginRepositories>
- 这样的配置只对当前Maven项目有效，想要通过一次配置就能让本机所有的Maven项目都使用自己的Maven私服。
- settings.xml文件中的配置对所有本机Maven项目有效，但是settings.xml并不支持直接配置repositories和pluginRepositories。所幸Maven还提供了Profile机制，能让用户将仓库配置放到setting.xml中的Profile中:
- 在settings.xml中配置Nexus仓库：
<profiles>
  <profile>
    <id>nexus</id>
      <repositories>
        <repository>
          <id>nexus</id>
          <name>Nexus</name>
          <url>http://localhost:8081/repository/maven-public/</url>
          <releases>
            <enabled>true</enabled>
          </releases>
          <snapshots>
            <enabled>true</enabled>
          </snapshots>      
        </repository>
      </repositories>
      <pluginRepositories>
        <repository>
          <id>nexus</id>
          <name>Nexus</name>
          <url>http://localhost:8081/repository/maven-public/</url>
          <releases>
            <enabled>true</enabled>
          </releases>
          <snapshots>
            <enabled>true</enabled>
          </snapshots>      
        </repository>
      </pluginRepositories>
    </repositories>
  </profile>
  <activeProfiles>
    <activeProfile>nexus</activeProfile>
  </activeProfiles>
</profiles>
- 该配置中使用了一个id为nexus的profile，这个profile包含了相关的仓库配置，同时配置中又使用activeProfile元素将nexus这个profile激活，这样当执行Maven构建的时候，激活的profile会将仓库配置应用到项目中去
- 配置已经能让本机所有的Maven项目从Nexus私服下载构件, 然而，Maven除了从Nexus下载构件之外，还会不时地访问中央仓库central，我们希望的是所有Maven下载请求都仅仅通过Nexus，以全面发挥私服的作用。这个时候就需要借助于Maven镜像配置了。可以创建一个匹配任何仓库的镜像，镜像的地址为私服，这样，Maven对任何仓库的构件下载请求都会转到私服中。
- 配置镜像让Maven只使用私服：  
  <mirrors>
    <mirror>
      <id>nexus</id>
      <mirrorOf>*</mirrorOf>
      <url>http://localhost:8081/repository/maven-public/</url>
    </mirror>
  </mirrors>

  <profiles>
    <profile>
      <id>nexus</id>
      <repositories>
        <repository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>true</enabled></snapshots>
        </repository>
      </repositories>
     <pluginRepositories>
        <pluginRepository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>true</enabled></snapshots>
        </pluginRepository>
      </pluginRepositories>
    </profile>
  </profiles>

  </profiles>
  <activeProfiles>
    <activeProfile>nexus</activeProfile>
  </activeProfiles>
- 关于镜像、profile及profile激活的配置不再赘述，这里需要解释的是仓库及插件仓库配置，它们的id都为central，也就是说，覆盖了超级POM中央仓库的配置，它们的url已无关紧要，因为所有请求都会通过镜像访问私服地址。配置仓库及插件仓库的主要目的是开启对快照版本下载的支持，当Maven需要下载发布版或快照版构件的时候，
它首先检查central，看该类型的构件是否支持，得到正面的回答之后，再根据镜像匹配规则转而访问私服仓库地址。

#部署构件至Nexus
- 如果只为代理外部公共仓库，那么Nexus的代理仓库就已经能够完全满足需要了。对于另一类Nexus仓库——宿主仓库来说，它们的主要作用是储存组织内部的，或者一些无法从公共仓库中获得的第三方构件，供大家下载使用。用户可以配置Maven自动部署构件至Nexus的宿主仓库，也可以通过界面手动上传构件。
- 日常开发生成的快照版本构件可以直接部署到Nexus中策略为Snapshot的宿主仓库中，项目正式发布的构件则应该部署到Nexus中策略为Release的宿主仓库中。POM的配置方式:
<distributionManagement>
    <repository>
      <id>project-releases</id>
      <!--<id>nexus</id>-->
      <name>Project Release Repository</name>
      <url>http://localhost:8081/repository/maven-releases/</url>
    </repository>
    <snapshotRepository>
      <id>project-snapshots</id>
      <!--<id>nexus</id>-->
      <name>Project Snapshot Repository</name>
      <url>http://localhost:8081/repository/maven-snapshots/</url>
    </snapshotRepository>
  </distributionManagement>

Nexus的仓库对于匿名用户是只读的。为了能够部署构件，还需要在settings.xml中配置认证信息:
    <server>
      <id>project-releases</id>
      <username>admin</username>
      <password>admin123</password>
    </server>

    <server>
      <id>project-snapshots</id>
      <username>admin</username>
      <password>admin123</password>
    </server>

#手动部署第三方构件至Nexus
- 某些Java Jar文件（如Oracle）的JDBC驱动，由于许可证的因素，它们无法公开地放在公共仓库中。
- 大量的小型开源项目，它们没有把自己的构件分发到中央仓库中，也没有维护自己的仓库，因此也无法从公共仓库获得。这个时候用户就需要将这类构件手动下载到本地，然后通过Nexus的界面上传到私服中。 
- 把nexus换成2.x的版本就好了，看样子是nexus3把管理第三方jar包给阉割掉了。

- 选择maven2(hosted), 可以上传私有的项目到hosted，以及配置proxy以获取第三方的依赖（比如可以配置中央仓库的地址）。
    <repository>
      <id>3rdParty</id>
      <name>3rdParty Repository</name>
      <url>http://localhost:8081/repository/3rdParty/</url>
    </repository>
- 如果已经有了jar包，可以通过下面的命令直接上传，cmd中输入下列命令
mvn deploy:deploy-file -DgroupId=com.alibaba.alipay -DartifactId=alipay-sdk-java -Dversion=0.0.1 -Dpackaging=jar -Dfile="C:\Users\wenda\Documents\1 Apps\060 webmall\webmall\target\mmall-1.0-SNAPSHOT\WEB-INF\lib\alipay-sdk-java20161213173952.jar" -Durl=http://localhost:8081/repository/3rdParty/ -DrepositoryId=3rdParty
mvn deploy:deploy-file -DgroupId=com.alibaba.alipay -DartifactId=alipay-trade-sdk -Dversion=0.0.1 -Dpackaging=jar -Dfile="C:\Users\wenda\Documents\1 Apps\060 webmall\webmall\target\mmall-1.0-SNAPSHOT\WEB-INF\lib\alipay-trade-sdk-20161215.jar" -Durl=http://localhost:8081/repository/3rdParty/ -DrepositoryId=3rdParty

#Nexus的权限管理
- 在组织中使用Nexus的时候往往会有一些安全性需求，例如希望只有管理员才能配置Nexus，只有某些团队成员才能部署构件，
- 或者更细一些的要求，例如每个项目有自己的Nexus宿主仓库，且只能部署项目构件至该仓库中。
- Nexus提供了全面的权限控制特性，能让用户自由地根据需要配置Nexus用户、角色、权限等。

#Nexus的访问控制模型
- Nexus是基于权限（Privilege）做访问控制的，服务器的每一个资源都有相应的权限来控制，因此用户执行特定的操作时就必须拥有必要的权限。管理员必须以角色（Role）的方式将权限赋予Nexus用户。
- 例如要访问Nexus界面，就必须拥有Status-（read）这个权限，而Nexus默认配置的角色UI：Basic UI Privileges就包含了这个权限，再
将这个角色分配给某个用户，这个用户就能访问Nexus界面了。
- 用户可以被赋予一个或者多个角色，角色可以包含一个或者多个权限，角色还可以包含一个或者多个其他角色。
- Nexus预定义了两个用户，以admin登录后，单击页面左边导航栏中的User链接，就能看到所有已定义用户的列表
对应了三个权限级别：
·admin： 该用户拥有对Nexus服务的完全控制，默认密码为admin123。
·anonymous： 该用户对应了所有未登录的匿名用户，它们可以浏览仓库并进行搜索。
- 在Users页面中，管理员还可以添加用户。单击上方的Add按钮，选择Nexus User，然后在用户配置面板中配置要添加用户的ID、 名称、Email、状态、密码以及包含的角色，最后单击Save按钮即可。
- Nexus包含了一个特殊的匿名用户角色（Nexus Anonymous Role），默认配置下没有登录的用户都会拥有该匿名角色的权限。 这个匿名用户角色实际包含了上述所列角色中，除Repo：All Repositories（Full Control）之外的所有角色所包含的权限。 也就是说，匿名用户可以访问基本的Nexus界面、浏览仓库内容及搜索构件。

#为项目分配独立的仓库
- 在组织内部，如果所有项目都部署快照及发布版构件至同样的仓库，就会存在潜在的冲突及安全问题，我们不想让项目A的部署影响到项目B，反之亦然。
- 解决的方法就是为每个项目分配独立的仓库，并且只将仓库的部署、修改和删除权限赋予该项目的成员，其他用户只能读取、 下载和搜索该仓库的内容。 
- 假设项目名称为foo，首先为该项目建立两个宿主仓库Foo Snapshots和Foo Releases，分别用来部署快照构件和发布构件。 。
- 有了仓库之后，就需要创建基于仓库的增、删、改、查权限。
- 在Nexus中，这样的权限是基于Repository Target建立的，Repository Target实际上是一系列正则表达式，在访问仓库某路径下内容的时候， Nexus会将仓库路径与Repository Target的正则表达式一一匹配，以检查权限是否正确。
。。。

#其他私服软件
- Nexus不是唯一的Maven私服软件，正如本章一开始所提到的，用户还有另外两个选择，它们分别为Apache的Archiva与JFrog的Artifactory。
- 在Nexus发布之前，笔者曾一度是Artifactory的忠实用户，当时它是唯一的支持从用户界面配置仓库的私服。Artifactory的一大特点是使用数据库来存储仓库内容。读者可以自行访问JFrog

#使用Maven进行测试
- 随着敏捷开发模式的日益流行，软件开发人员也越来越认识到日常编程工作中单元测试的重要性。
- Maven的重要职责之一就是自动运行单元测试，它通过mavensurefire-plugin与主流的单元测试框架JUnit 3、JUnit 4以及TestNG集成， 并且能够自动生成丰富的结果报告。
- 本章将介绍Maven关于测试的一些重要特性，但不会深入解释单元测试框架本身及相关技巧，重点是介绍如何通过Maven控制单元测试的运行。

- 报告中的Failures、Errors、Skipped信息来源于JUnit测试框架。
- Failures（失败）表示要测试的结果与预期值不一致，例如测试代码期望返回值为true，但实际为false；
- Errors（错误）表示测试代码或产品代码发生了未预期的错误，例如产品代码抛出了一个空指针错误，该错误又没有被测试代码捕捉到；
- Skipped表示那些被标记为忽略的测试方法，在JUnit中用户可以使用@Ignore注解标记忽略测试方法。

#maven-surefire-plugin简介
- Maven本身并不是一个单元测试框架，Java世界中主流的单元测试框架为JUnit（http://www.junit.org/ ）和TestNG（http://testng.org/ ）。
- Maven所做的只是在构建执行到特定生命周期阶段的时候，通过插件来执行JUnit或者TestNG的测试用例。这一插件就是maven-surefire-plugin，可以称之为测试运行器（Test Runner），它能很好地兼容JUnit 3、JUnit 4以及TestNG。
- 可以回顾一下default生命周期，其中的test阶段被定义为“使用单元测试框架运行测试”。我们知道，生命周期阶段需要绑定到某个插件的目标才能完成真正的工作，test阶段正是与maven-surefire-plugin的test目标相绑定了，这是一个内置的绑定。
- 在默认情况下，maven-surefire-plugin的test目标会自动执行测试源码路径（默认为src/test/java/所有符合一组命名模式的测试类。 这组模式为：
·**/Test*.java： 任何子目录下所有命名以Test开头的Java类。
·**/*Test.java： 任何子目录下所有命名以Test结尾的Java类。
·**/*TestCase.java： 任何子目录下所有命名以TestCase结尾的Java类。
- 只要将测试类按上述模式命名，Maven就能自动运行它们，用户也就不再需要定义测试集合（TestSuite）来聚合测试用例（TestCase）。
- 如果有需要，可以自己定义要运行测试类的模式，此外，maven-surefire-plugin还支持更高级的TestNG测试集合xml文件。
- 为了能够运行测试，Maven需要在项目中引入测试框架的依赖，本书已经多次涉及了如何添加JUnit测试范围依赖.

#10.3　跳过测试
- 日常工作中，软件开发人员总有很多理由来跳过单元测试，“我敢保证这次改动不会导致任何测试失败”，“测试运行太耗时了，暂时跳过一下”，“有持续集成服务跑所有测试呢，我本地就不执行啦”。
- 在大部分情况下，这些想法都是不对的，任何改动都要交给测试去验证，测试运行耗时过长应该考虑优化测试，更不要完全依赖持续集成服务来报告错误，测试错误应该尽早在尽小范围内发现，并及时修复。
- Maven跳过测试在命令行加入参数skipTests就可以了
mvn clean package -DskipTests
--- maven-surefire-plugin:2.12.4:test (default-test) @ account-captcha ---
Tests are skipped.
- 也可以在POM中配置maven-surefire-plugin插件来提供该属性，如代码清单10-12所示。但这是不推荐的做法，如果配置POM让项目长时间地跳过测试，则还要测试代码做什么呢？
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <configuration>
            <skipTests>true</skipTests>
          </configuration>
        </plugin>
mvn clean compile:
Tests are skipped.
- 有时候用户不仅仅想跳过测试运行，还想临时性地跳过测试代码的编译，Maven也允许你这么做，但记住这是不推荐的：
mvn package -Dmaven.test.skip=skipTests
--- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ account-captcha ---
Nothing to compile - all classes are up to date
--- maven-surefire-plugin:2.12.4:test (default-test) @ account-captcha ---
Tests are skipped.
- 参数maven.test.skip同时控制了maven-compiler-plugin和maven-surefire-plugin两个插件的行为，测试代码编译和测试运行都跳过了。

#动态指定要运行的测试用例
- 反复运行单个测试用例是日常开发中很常见的行为。例如，项目代码中有一个失败的测试用例，开发人员就会想要再次运行这个测试以获得详细的错误报告，在修复该测试的过程中，开发人员也会反复运行它，以确认修复代码是正确的。
- 如果仅仅为了一个失败的测试用例而反复运行所有测试，未免太浪费时间了，当项目中测试的数目比较大的时候，这种浪费尤为明显。
- maven-surefire-plugin提供了一个test参数让Maven用户能够在命令行指定要运行的测试用例。例如，如果只想运行account-captcha的RandomGeneratorTest，就可以使用如下命令：
mvn test -Dtest=RandomGeneratorTest
- 这里test参数的值是测试用例的类名，这行命令的效果就是只有RandomGeneratorTest这一个测试类得到运行。
- maven-surefire-plugin的test参数还支持高级一些的赋值方式，能让用户更灵活地指定需要运行的测试用例。例如：
mvn test -Dtest=Random*Test -DfailIfNoTests=false
Running com.juvenxu.mvnbook.account.captcha.RandomGeneratorTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.037 sec
- 除了星号匹配，还可以使用逗号指定多个测试用例：
mvn test -Dtest=RandomGeneratorTest,AccountCaptchaServiceTest
- 也可以结合使用星号和逗号
mvn test -Dtest=Random*Test,AccountCaptchaServiceTest
- 上述几种从命令行动态指定测试类的方法都应该只是临时使用，如果长时间只运行项目的某几个测试，那么测试就会慢慢失去其本来的意义。
- test参数的值必须匹配一个或者多个测试类，如果maven-surefire-plugin找不到任何匹配的测试类，就会报错并导致构建失败。
mvn test -Dtest
- 根据错误提示可以加上-DfailIfNoTests=false，告诉maven-surefire-plugin即使没有任何测试也不要报错：
mvn test -Dtest -DfailIfNoTests=false
- 实际上使用命令行参数-Dtest-DfailIfNoTests=false是另外一种跳过测试的方法。
- 使用test参数用户可以从命令行灵活地指定要运行的测试类。可惜的是，maven-surefire-plugin并没有提供任何参数支持用户从命令行跳过指定的测试类，好在用户可以通过在POM中配置maven-surefire-plugin排除特定的测试类。
#包含与排除测试用例
- 10.2节介绍了一组命名模式，符合这一组模式的测试类将会自动执行。
- Maven提倡约定优于配置原则，因此用户应该尽量遵守这一组模式来为测试类命名。
- 即便如此，maven-surefire-plugin还是允许用户通过额外的配置来自定义包含一些其他测试类，或者排除一些符合默认命名模式的测试类。
- 例如，由于历史原因，有些项目所有测试类名称都以Tests结尾，这样的名字不符合默认的3种模式，因此不会被自动运行，可以配置让Maven自动运行这些测试
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.5</version>
          <configuration>
            <includes>
              <include>**/*Tests.java</include>
            </includes>
          </configuration>
        </plugin>
类似地，也可以使用excludes元素排除一些符合默认命名模式的测试类
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.5</version>
          <configuration>
            <excludes>
              <exclude>**/*ServiceTests.java</exclude>
              <exclude>**/TempDaoTest.java</exclude>
            </excludes>
          </configuration>
        </plugin>
- 上述代码清单排除了所有以ServiceTest结尾的测试类，以及一个名为TempDaoTest的测试类。它们都符合默认的命名模式**/*Test.java，不过，有了excludes配置后，maven-surefire-plugin将不再自动运行它们。

#测试报告
- 除了命令行输出，Maven用户可以使用maven-surefire-plugin等插件以文件的形式生成更丰富的测试报告。
#基本的测试报告
- 默认情况下，maven-surefire-plugin会在项目的target/surefire-reports目录下生成两种格式的错误报告：
·简单文本格式 (获得信息足够了)，
·与JUnit兼容的XML格式 (XML格式的测试报告主要是为了支持工具的解析，如Eclipse的JUnit插件可以直接打开这样的报告)

- 由于这种XML格式已经成为了Java单元测试报告的事实标准，一些其他工具也能使用它们。例如，持续集成服务器Hudson就能使用这样的文件提供持续集成的测试报告。
- 以上展示了一些运行正确的测试报告，实际上，错误的报告更具价值
- 报告说明了哪个测试方法失败、哪个断言失败以及具体的堆栈信息，用户可以据此快速地寻找失败原因。
- 该测试的XML格式报告用Eclipse JUnit插件打开

#测试覆盖率报告
- 测试覆盖率是衡量项目代码质量的一个重要的参考指标。 
- Cobertura是一个优秀的开源测试覆盖率统计工具（详见http://cobertura.sourceforge.net/ ），
- Maven通过coberturamaven-plugin与之集成，用户可以使用简单的命令为Maven项目生成测试覆盖率报告
- 例如，可以在account-captcha目录下运行如下命令生成报告：接着打开项目目录target/site/cobertura/下的index.html文件:
mvn cobertura:cobertura

#单击具体的类，还能看到精确到行的覆盖率报告

#运行TestNG测试
- TestNG是Java社区中除JUnit之外另一个流行的单元测试框架。
- NG是Next Generation的缩写，译为“下一代”。TestNG在JUnit的基础上增加了很多特性，http://testng.org/ 
- 使用Maven运行TestNG十分方便。首先需要删除POM中的JUnit依赖，加入TestNG依赖

- 与JUnit类似，TestNG的依赖范围应为test。
- 此外，TestNG使用classifier jdk15和jdk14为不同的Java平台提供支持。
- 下一步需要将对JUnit的类库引用更改成对TestNG的类库引用。
- 将JUnit的类库引用改成TestNG之后，在命令行输入mvn test，Maven就会自动运行那些符合命名模式的测试类。与运行JUnit测试没有区别。
- TestNG允许用户使用一个名为testng.xml的文件来配置想要运行的测试集合。例如，可以在account-captcha的项目根目录下创建一个testng.xml文件，配置只运行RandomGeneratorTest
- 同时再配置maven-surefire-plugin使用该testng.xml
- TestNG较JUnit的一大优势在于它支持测试组的概念，如下的注解会将测试方法加入到两个测试组util和medium中：
- 由于用户可以自由地标注方法所属的测试组，因此这种机制能让用户在方法级别对测试进行归类。 
- 这一点JUnit无法做到，它只能实现类级别的测试归类。 Maven用户可以使用代码清单10-19所示的配置运行一个或者多个TestNG测试组。

#重用测试代码
- 优秀的程序员会像对待产品代码一样细心维护测试代码，尤其是那些供具体测试类继承的抽象类，它们能够简化测试代码的编写。还有一些根据具体项目环境对测试框架的扩展，也会被大范围地重用。
- 在命令行运行mvn package 的时候，Maven会将项目的主代码及资源文件打包，将其安装或部署到仓库之后，这些代码就能为他人使用， 从而实现Maven项目级别的重用。
- 默认的打包行为是不会包含测试代码的，因此在使用外部依赖的时候，其构件一般都不会包含测试代码。 
- 然而，在项目内部重用某个模块的测试代码是很常见的需求，可能某个底层模块的测试代码中包含了一些常用的测试工具类，或者一些高质量的测试基类供继承。这个时候Maven用户就需要通过配置maven-jar-plugin将测试类打包：
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-jar-plugin</artifactId>
          <version>2.2</version>
          <executions>
            <execution>
              <goals>
                <goal>test-jar</goal>
              </goals>
            </execution>
          </executions>
        </plugin>

- maven-jar-plugin有两个目标，分别是jar和test-jar，前者通过Maven的内置绑定在default生命周期的package阶段运行，其行为就是对项目主代码进行打包，而后者并没有内置绑定，因此上述的插件配置显式声明该目标来打包测试代码。通过查询该插件的具体信息可以了解到，test-jar的默认绑定生命周期阶段为package:
mvn clean package
account-captcha-1.0.0-SNAPSHOT-tests.jar
可以通过依赖声明使用这样的测试包构件了:
      dependency>
        <groupId>com.javenxu.mvnbook.account</groupId>
        <artifactId>account-captcha</artifactId>
        <version>1.0.0-SNAPSHOT</version>
        <type>test-jar</type>
        <scope>test</scope>
      </dependency>
上述依赖声明中有一个特殊的元素type，所有测试包构件都使用特殊的test-jar打包类型:

#第11章　使用Hudson进行持续集成
- 作为最核心的敏捷实践之一——持续集成（Continuous Integration）越来越受到广大开发人员的喜爱和推崇。 
- 借助Maven所实现的自动化构建正是持续集成的一个必要前提，持续集成还要求开发人员使用版本控制工具和持续集成服务器。
- 例如Subversion就是当前最流行的版本控制工具，而Hudson则是最流行的开源持续集成服务器软件。
- 本章将简要介绍持续集成的概念和Subversion的基本使用，主要关注如何使用Hudson，尤其是如何结合Maven与Hudson持续集成我们的项目。

- 持续集成的作用、过程和优势
简单地说，持续集成就是快速且高频率地自动构建项目的所有源码，并为项目成员提供丰富的反馈信息。这句话有很多关键的词：
·快速： 集成的速度要尽可能地快，开发人员不希望自己的代码提交半天之后才得到反馈。
·高频率： 频率越高越好，例如每隔一小时就是个不错的选择，这样问题才能尽早地被反映出来。
·自动： 持续集成应该是自动触发并执行的，不应该有手工参与。
·构建： 包括编译、测试、审查、打包、部署等工作。
·所有源码： 所有团队成员提交到代码库里的最新的源代码。
·反馈： 持续集成应该通过各种快捷的方式告诉团队成员最新的集成状态，当集成失败的时候，反馈报告应该尽可能地反映失败的具体细节。

一个典型的持续集成场景是这样的：
- 开发人员对代码做了一些修改，在本地运行构建并确认无误之后，将更改提交到代码库。
- 具有高配置硬件的持续集成服务器每隔30分钟查询代码库一次，发现更新之后，签出所有最新的源代码，然后调用自动化构建工具（如Maven）构建项目，该过程包括编译、测试、审查、打包和部署等。
- 然而不幸的是，另外一名开发人员在这一时间段也提交了代码更改，两处更改导致了某些测试的失败，持续集成服务器基于这些失败的测试创建一个报告，并自动发送给相关开发人员。
- 开发人员收到报告后，立即着手调查原因，并尽快修复。


通过图11-1可知，当持续集成服务器构建项目成功后，还可以自动将项目构件部署到Nexus私服中。
一次完整的集成往往会包括以下6个步骤：
1）持续编译： 所有正式的源代码都应该提交到源码控制系统中（如Subversion），持续集成服务器按一定频率检查源码控制系统，如果有新的代码，就触发一次集
成，旧的已编译的字节码应当全部清除，然后服务器编译所有最新的源码。
2）持续数据库集成： 在很多项目中，源代码不仅仅指Java代码，还包括了数据库SQL脚本，如果单独管理它们，很容易造成与项目其他代码的不一致，并造成混
乱。持续集成也应该包括数据库的集成，每次发现新的SQL脚本，就应该清理集成环境的数据库，重新创建表结构，并填入预备的数据。这样就能随时发现脚本的错误，此外，基于这些脚本的测试还能进一步发现其他相关的问题。
3）持续测试： 有了JUnit之类的框架，自动化测试就成了可能。编写优良的单元测试并不容易，好的单元测试必须是自动化的、可重复执行的、不依赖于环境的，并
且能够自我检查的。除了单元测试，有些项目还会包含一些依赖外部环境的集成测试。所有这些测试都应该在每次集成的时候运行，并且在发生问题的时候能产生具体报告。
4）持续审查： 诸如Checkstyle和PMD之类的工具能够帮我们发现代码中潜在问题，持续集成可以使用这些工具来生成各类报告，如测试覆盖率报告、
Checkstyle报告、PMD报告等。这些报告的生成频率可以低一些，如每日生成一次，当审查发现问题的时候，可以给开发人员反馈警告信息。
5）持续部署： 有些错误只有在部署后才能被发现，它们往往是具体容器或者环境相关的，自动化部署能够帮助我们尽快发现这类问题。
6）持续反馈： 持续集成的最后一步的反馈，通常是一封电子邮件。在重要的时候将正确的信息发送给正确的人。如果开发者一直受到与自己无关的持续集成报告，
他慢慢地就会忽略这些报告。基本的规则是：将集成失败报告发送给这次集成相关的代码提交者，项目经理应该收到所有失败报告。
成本：
- 持续集成需要引入额外的硬件设置，特别是对于持续集成服务器来说，性能越高，集成的速度就越快，反馈的速度也就越快。
- 持续集成还要求开发者使用各种工具，如源码控制工具、自动化构建工具、自动化测试工具、持续集成软件等。
好处：
- 尽早暴露问题： 越早地暴露问题，修复问题代码的成本就越低。持续集成高频率地编译、测试、审查、部署项目代码，能够快速地发现问题并及时反馈。
·减少重复操作： 持续集成是完全自动化的，这就避免了大量重复的手工劳动，开发人员不再需要手动地去签出源码，一步步地编译、测试、审查、部署。
·简化项目发布： 每日高频率的集成保证了项目随时都是可以部署运行的，如果没有持续集成，项目发布之前将不得不手动地集成，然后花大量精力修复集成问题。
·建立团队信心： 一个优良的持续集成环境能让团队随时对项目的状态保持信心，因为项目的大部分问题区域已经由持续集成环境覆盖了。

#　Hudson简介
- 优秀的持续集成工具有很多，如老牌的开源工具CruiseControl、商业的Bamboo和TeamCity等。
- Hudson以其强大的功能和易用的界面征服了大量的用户，它与主流的构建工具、版本控制系统以及自动化测试框架都能进行很好的集成。因此，很多组织和公司选择它作为自己的持续集成工具，如JBoss的http://hudson.jboss.org/hudson/ 和Sonatype的https://grid.sonatype.org/ci/ 。
- Hudson还有一个优秀之处就是它提供了灵活的插件扩展框架，大量开发者基于这种机制对Hudson进行了扩展。

#安装Hudson
- 安装Hudson是十分简便的。需要注意的是，Hudson必须运行在JRE 1.5或更高的版本上。可以从http://hudson-ci.org/ 下载最新版本的安装包。 下载完成之后就能获得一个hudson.war文件。
- 最简单的启动Hudson的方式是在命令行直接运行hudson.war：java -jar hudson.war
- http://localhost:8080访问Hudson的界面
- java -jar hudson.war --httpPort=8082
- 既然安装包是一个war文件，Hudson自然也就可以被部署到各种Web容器中，如Tomcat、Glassfish、Jetty及JBoss等。
- 以Tomcat 6为例，假设Tomcat的安装目录为D：\bin\apache-tomcat-6.0.20\，那么只需要复制hudson.war至Tomcat的部署目录D：\bin\apache-tomcat-6.0.20\webapps
- 然后转到D：\bin\apache-tomcat-6.0.20\bin\目录，运行startup.bat。
- 待Tomcat启动完成之后，打开浏览器访问http://localhost：8080/ hudson就能看到Hudson的界面了。

#准备Subversion仓库
- 在正式创建Hudson持续集成任务之前，需要准备好版本控制系统。
- 常见的版本控制工具有CVS、Subversion、Git、Mercurial等。
- 由于Subversion可能是当前使用范围最广的版本控制工具，因此本书以它为例进行介绍。
- 首先需要安装Subversion服务器软件（本书仅讨论svnserve）。对于大多数Linux发行版和Mac OS 来说，该工具应该已经被预先安装了。
- 在Linux/Mac OS X中检查svnserve安装: svnserve --version
- 对于Windows用户来说，可以安装Slik Subversion（http://www.sliksvn.com/en/download）。 
- 在选择安装类型的时候，需要选择complete安装，否则默认的安装方式将不会安装svnserve
- 接着需要创建一个Subversion仓库： 
mkdir svn-repos
svnadmin create svn-repos/account
- svnadmin是用来创建、维护、监测Subversion仓库的工具，在主流Linux和Mac OS X上一般都是预装的。在Windows上，它也被包含在Slik Subversion中。这里首先创建一个名为svn-repos的目录，然后在这个目录中创建一个Subversion仓库。
- 导入源码至Subversion仓库: svn import -m "initial import" . file:///c:/users/wenda/svn-repos/account/trunk
- 由于笔者的代码和Subversion仓库在一台机器上，因此直接使用file协议导入（导入之前应先使用mvn clean命令清除项目输出文件， 这些文件是可以自动生成的， 不该放入源码库中，
- 上述命令将当前目录的全部内容提交到Subversion仓库的/account/trunk路径下，-m选项表示提交的注释。
- 仓库建立并初始化完毕，就可以启动svnserve服务了：
svnserve -d -r svn-repos --listen-host 0.0.0.0
- 选项-d表示将svnserve服务作为守护进程运行，-r表示Subversion仓库的位置，而参数--listen-host是为了强制将svnserve绑定到IP v4地址（在有些系统上，svnserve会默认绑定IP v6地址，当Hudson使用IP v4地址访问Subversion仓库的时候就会失败）。
- 简单的svn命令检查插件svnserve服务是否可用, 检查Subversion仓库内容
svn list svn://localhost/account/trunk
.classpath
.idea/
.project
.settings/
account-captcha/
account-email/
account-parent.iml
account-persist/
pom.xml
-Subversion仓库就建立完成了，之后Hudson就可以基于这个仓库运行集成任务。
#Hudson的基本系统设置
- 在创建Hudson持续集成任务之前，用户需要对Hudson系统做一些基本的配置，
- 包括JDK安装位置和Maven安装等在内的重要信息都必须首先配置正确。
- Hudson会使用这些配置好的JDK及Maven进行持续集成任务。
- 如果要使用Ant或者Shell来持续集成项目，Ant或Shell的安装位置也应该预先设置正确。
- 用户应该单击Hudson登录页面左边的“系统管理”，然后单击页面右侧的“系统设置”以进入系统设置页面
- 在系统设置页面，首先要配置的是Hudson将使用的JDK
- 选择手动或者自动安装Maven供Hudson使用
- 还可以在该页面配置MAVEN_OPTS环境变量

#　创建Hudson任务
- 要创建一个Hudson任务来持续集成Maven项目，首先单击页面左边的新建任务，然后就需要在页面右边选择任务的名称及类型。
- 对于一般的Maven项目来说，可选择的类型有Build a free-style software project和Build a maven2 project。
- 前者不仅支持Maven项目，还支持其他类型的构建工具，如Ant、Shell。
- 对于Maven用户来说，两者最大的不同在于前者需要用户进行多一点的配置，而后者会使用Hudson自带的Maven，且从项目的POM中获取足够的信息以免去一些配置。
- 除非你已经十分熟悉Hudson，笔者推荐选择free-style类型（见图11-10）。因为这种方式更可控制，当任务出现问题的时候也更容易检查。
- 输入任务名称，并选择free-style类型后，单击OK按钮即可进入详细的任务配置页面。
- 下面依次介绍free-style任务的各种配置。
- 首先是项目的名称和描述。当Hudson任务比较多的时候，简洁且有意义的名称及描述就十分重要。
- 接着是一个重要的选项Discard Old Builds。该选项配置如何抛弃旧的构建。Hudson每执行一次构建任务，就可以保存相应的源代码、构建输出、构建报告等文件。
- 很显然，如果每次构建相关的文件都保存下来，将会渐渐消耗光磁盘空间。为此，Hudson提供两种方式让用户选择保留哪些构建任务的相关文件，它们分别为：
·Days to keep builds： 如果其值为非空的N，就仅保留N天之内的构建文件。
·Max#of builds to keep： 如果#非空，就仅保留最多#个最近构建的相关文件。
- 可供选择的JDK就是用户在系统设置中预先定义好的JDK ??

#Hudson任务的源码仓库配置
接着需要配置项目的源码控制系统。在项目配置页面的Source Code Management部分，选择Subversion单选按钮，然后在Repository URL文本框中输入项目的Subversion仓
库地址:
svn://localhost/account/trunk
- 一般来说，该部分的其他选项保留默认值即可
- 需要注意的是，如果访问Subversion仓库需要认证，Hudson会自动探测并提示用户输入认证信息
- 单击enter credential后，Hudson会弹出一个页面让用户选择认证方式并输入认证信息。输入正确信息之后，Hudson就能读取仓库源代码了。可以采用了用户名和密码
的方式进行认证。

#　Hudson任务的构建触发配置
- 再往下的Build Triggers部分配置的是触发构建的方式。可选的三种方式分别为：
·Build after other projects are built：在其他项目构建完成之后构建本项目。
·Build periodically：周期性地构建本项目。
·Poll SCM：周期性地轮询源码仓库，发现有更新的时候构建本项目。
- 如无特殊高级的需要，一般不会选择第一种方式；
- 而第二种方式显然会造成一些无谓的构建，如果几次构建所基于的源代码没有任何区别，构建的输出往往也就不会有变化；
- 第三种方式就没有这个问题，它能避免无谓的构建，节省持续集成服务器的资源。这种周期轮询源代码仓库的方式实际上也是最常用的构建触发方式。
- 既然是轮询，就需要配置轮询的频率，Hudson使用了著名的UNIX任务调度工具Cron（http://en.wikipedia.org/wiki/Cron ）所使用的配置方式。这种配置方式使用5个字段
表示不同的时间单位（字段之间用空格或制表符分隔）： 分　时　日　月　星期几
每个字段表示的意义及值范围分别为：
·分：一小时中的分钟（0~59）。
·时：一天中的小时（0~23）。
·日：一月中的日期（1~31）。
·月：月份（1~12）。
·星期几：一周中的星期几（0~7，0和7都表示星期天）。
其中每个字段除了可以使用其范围内的值以外，还能使用一些特殊的字符：
·*：星号表示匹配范围内所有值。
·M-N：连字符表示匹配M~N范围内的所有值，如“1-5”。
·A，B，…，Z：逗号表示匹配多个值，如“0，15，0”。
·*/X或M-N/X：范围加上斜杠表示匹配范围内能被X整除的值，如“1-10/3”就等同于“3，6，9”。

- 下面一些例子可以帮助读者理解这种强大的配置方式：
·****：每分钟。
·5****：每小时中的第5分钟。
·*/10****：每隔10分钟。
·4510**1-5：每周一到周五的上午10：45。
·0，30*13*5：每月13号的每半小时，或者每周五的每半小时。

- 对于一个健康的项目来说，常见的做法是：每隔10分钟轮询代码仓库
*/10****
- 在配置轮询的时候，还可以使用“#”添加注释，此外空白的行会被忽略

#Hudson任务的构建配置
- 接下来要告诉Hudson使用运行Maven命令构建项目。
- 单击Build部分中的Add build step下三角按钮，然后选择Invoke top-level Maven targets
- 再选择一个安装好的Maven版本，输入Maven命令如clean deploy就可以了，
- 需要注意的是，日常持续集成任务如果成功的话，都会生成快照版的项目构件。
- 如果维护了一个Maven私服，那么持续集成任务就应当自动将构件部署到私服中，供其他项目使用。这也就是这里的Maven命令应当为clean deploy的原因。
- 至此，一个Hudson任务基本配置完成,可以单击页面左边的“立即生成”来手动触发第一次集成。

#监视Hudson任务状态
- Hudson提供了丰富友好的图形化界面，让用户从各方面了解各个任务的当前及历史状态，这包括整体的列表显示、自定义视图、单个任务的具体信息，如构建日志和
测报报告等。用户应该基于Hudson提供的信息尽可能地将持续集成任务稳定在健康的状态。
#全局任务状态
- Hudson的默认主页面显示了当前服务器上所有集成任务的状态。
这个页面主要由四个部分组成：
·导航菜单： 位于页面左上方，方便用户执行各类Hudson操作，如新建任务、系统管理等。
·生成队列： 页面左边中间的部分，表示等待执行构建的任务，如图11-19中有一个maven3的构建任务在等待生成队列中。
·生成状态： 页面左边下面的部分，表示正在执行构建的任务，如图11-19中有一个account的构建任务正在执行。
·任务状态： 页面右边的部分，显示了所有任务的状态。
- 下面重点介绍任务状态。每一列从左到右分别表示任务当前状态、天气，名称、上次成功的时间、上次失败的时间、上次持续的时间以及左右一个立即执行的按钮 （方便用户手动触发执行任务）。
- 其中需要解释的是当前状态及图中第一列（S）下的球形图标。Hudson使用各种颜色表示任务当前的状态：
·蓝色： 任务最近一次的构建是成功的。
·红色： 任务最近一次的构建是失败的。
·黄色： 任务最近一次的构建表成功了，但不稳定（主要是因为有失败的测试）。
·灰色： 任务从未被执行过或者被禁用了。
- 如果图标在闪烁，表示任务正在执行一次构建。
- 图中的第二列天气（W）也需要稍作解释。Hudson使用一组天气的图标表示任务长期的一个状态，它们分别为：
万里晴空，任务80%以上的集成都是成功的。
稍有乌云，任务有60%~80%的集成是成功的。
乌云密布，任务只有40%~60%的集成是成功的。
阴雨绵绵，任务的集成成功率只有20%~40%。
电闪雷鸣，任务的集成成功率不到20%。
- 关于全局状态需要再次强调的是，当团队看到任务的集成状态不够健康时，应该尽快采取措施修复问题。

#自定义任务视图
- 在一个稍有规模的公司或者组织下，持续集成服务器上往往会有很多的任务，Hudson默认的视图会列出所有服务器上的任务，太多的任务就会造成寻找的不便。
- 为此Hudson能让用户自定义视图，选择只列出感兴趣的任务，甚至还能自定义视图中显示的列。
- 添加了一个名为mvn-book的任务视图，该视图仅包含account一个任务，并且只显示状态、天气、任务名三列。用户可以根据自己的需要，选择要包含的任务和
要显示的列，甚至还能使用正则表达式来匹配要显示的任务名

#单个任务状态
- 在任务视图中，单击某个任务名称就能进一步查看该任务的状态。图11-22显示了account项目任务的一个整体状态。
- 包含了丰富的信息。左下角是构建历史（Build History），该例中显示了最近5次全部成功的构建，包括每次构建的时间。
- 图11-22下方还有3个永久连接，分别指向了最近一次构建、最近一次失败的构建以及最近一次成功的构建。无论构建历史还是永久连接，我们都能单击某一个构建以了解更具体的信息。
- 单击构建历史中的#4构建：
- Hudson>account>#4表示当前的位置是Hudson服务器下account任务的第4次构建。
- 从图11-23中可以了解到这次构建所发生的时间、相关的代码变更等信息。
- 在图11-23中左边的命令行输出链接。当构建失败的时候，了解这次构建的命令行输入至关重要。
- 在图11-22中还有一些链接包含了丰富的信息，例如最近变更集。单击该链接就能看到项目最近的代码变更
- 除了变更集，还可以单击工作区，以图形化的方式查看该Hudson从源码库取得的源码文件及构建输入文件

#Maven项目测试报告
- 还显示了项目的测试结果信息，为了获得这样的信息需要做一些额外的配置。
- maven-surefire-plugin会在项目的target/surefire-reports目录下生成与JUnit兼容的XML格式测试报告，
- Hudson能够基于这种格式的文件生成图形化的测试报告。
- 用户可以配置一个Hudson任务，在配置页面的Post-build Actions部分选择Publish JUnit test result report选项，并且将Test report XMLs赋值为**/target/surefire-reports/TEST-*.xml。
- 该表达式表示匹配任意目录下target/surefire-reports/子目录中以TEST-开头的XML文件，这也就是匹配所有maven-surefire-plugin生成的XML格式报告文件。配置如图11-27
所示。
**/target/surefire-reports/TEST-*.xml
- 有了上述配置之后，就能在任务状态页面中看到最新的测试结果与测试结果趋势
- 单击Latest Test Result就能看到最近一次构建的测试报告。在测试结果趋势图中， 用户也可以单击各个位置得到对应构建的测试报告
- 用户还可以单击图中的链接得到更具体的测试输出，以方便定位并修复问题。
- 如果用户为一个Hudson任务配置了测试报告，就可以同时配置构建命令忽略测试。例如，图11-17中的Maven构建命令可以更改为clean deploy-Dmaven.test.failure.ignore，这样失败的测试就不会导致构建失败。也就是说，构建的状态不会是红色，
- 同时，由于Hudson能够解析测试报告并发现失败的测试，构建的状态也不会是健康的蓝色。用户最终会看到黄色的任务状态，表示构建不稳定。这种配置方式能够帮助用户区分失败的构建与不稳定的构建。

#　Hudson用户管理
- 与一般软件的用户管理方式不同的是，使用Hudson时，不需要主动创建用户，Hudson能够在访问源码仓库的时候自动获取相关用户信息并存储起来。这大大简化了用户管理的步骤。
- 以11.4节建立的Subversion仓库为例，默认该仓库是匿名可读的，认证用户可写，不过我们并没有配置任何用户。现在要关闭匿名可读权限，同时添加一些用户。
- 可以参考《Subversion与版本控制》（http://svnbook.red-bean.com/ ）一书。
- 首先，编辑Subversion仓库下conf/svnserve.conf文件中的［general］小节如下：
[general]
# anon-access = none
# auth-access = write
# password-db = passwd

- 这里的anon-access=none表示匿名用户没有任何权限，auth-access=write表示经认证用户拥有读写权限，而password-db=passwd表示存储用户信息的数据位于同级目录下的passwd文件中。
- 再编辑conf/passwd文件如下：
[users]
# harry = harryssecret
# sally = sallyssecret
# admin = admin123
# juven = juven123
# jason = jason123
- 这里为仓库配置了三个用户，等号左边是用户名，右边则是密码。
- 至此，就完成了一个简单的Subversion仓库用户权限配置。
- 像日常开发一样，接下来在Subversion客户端分别使用这几个用户名对代码进行更改后提交至Subversion仓库。
- 例如，对account-parent模块的pom.xml加入developers配置后，再使用如下svn命令提交更改：
svn commit -m "add developers config" --username juven --password juven123

mkdir ~/svn/account -p
svn checkout svn://localhost/account/trunk

- 然后使用另外两个用户admin与jason分别对代码进行更改并提交，Hudson会很快轮询到Subversion仓库内的更改，然后取得更改的代码信息，并了解到这些更改是由谁提交的。
- 待Hudson得到这些更改并触发集成任务之后，相关的Subversion用户信息就已经被Hudson存储起来了。单击Hudson页面左边的用户，然后就能在页面右边看到相关的用户信息，包括用户名、最近活动时间及相关的Hudson任务

#邮件反馈
- 持续集成中非常重要的一个步骤就是反馈。
- 集成的状态信息（尤其是不健康的状态信息）必须及时地通知给相关团队成员，而最常见的反馈方式就是使用电子邮件。
- 如何配置Hudson来及时地发送集成反馈邮件。
- 首先需要做的是为Hudson配置邮件服务器信息。进入11.5节提到的系统设置页面，找到E-mail Notification部分， 然后输入以下信息：
·SMTP server： SMTP邮件服务器地址。
·Default user e-mail suffix： 默认用户邮件后缀。当用户没有配置邮件地址的时候，Hudson会自动为其加上该邮件后缀。 当用户数量很多，并且邮件地址都是一个域名的时候，该功能就显得尤其重要，例如配置后缀为@foo.com，且用户mike没有配置邮件地址，那么当Hudson需要发邮件给mike的时候就会发送到mike@foo.com。
·System Admin E-mail Address： 系统管理员邮件地址，即Hudson邮件提示所使用的发送地址。
·Hudson URL： Hudson服务器的地址。该地址往往被包含在电子邮件中以方便用户访问Hudson取得进一步的信息，因此要确保该地址在用户机器上是可访问的。
·SMTP Authentication： SMTP相关的认证配置。
- 配置完成后，可以单击图11-32右下角的测试按钮，让Hudson发一封邮件至系统管理员邮件地址以确认配置成功。
- 接下来要做的是配置Hudson任务使用邮件反馈。进入任务的配置页面，然后找到最后Post-build Actions小节中的E-mail Notification复选框，将其选上。
- 现在要关心的是两个问题：什么样的构建会触发邮件反馈？邮件会发送给谁？
关于第一个问题，答案是这样的：
·失败的构建会触发邮件反馈。
·成功构建后的一次不稳定构建会触发邮件反馈。不稳定往往是由失败的测试引起的，因此成功后的一次不稳定往往表示有回归性测试失败。
·失败或不稳定构建后的一次成功构建会触发邮件反馈，以通知用户集成恢复到了健康状态。
·用户可以配置是否每次不稳定构建都触发邮件反馈。
- 关于第二个问题，首先可以在Recipients中配置一个邮件列表（用空格分离），列表中的用户会收到所有邮件反馈。
- 一般来说，项目负责人应该在这个列表中。
- 其次，Hudson还提供一个选项：Send separate e-mails to individuals who broke the build。
- 当用户选择该选项后，邮件会发送给所有与这次构建相关的成员，即那些提交了本地构建代码更新的成员。
- Hudson无法精确地知道到底是谁的代码提交导致了构建失败，因此只能通知所有与代码更新相关的成员。
- 最后需要解释的是，图11-33中的Send e-mail for every unstable build选项表示是否为所有的不稳定构建触发邮件反馈， 如果不将其选中，只有成功构建后的第一次不稳定构建才会触发邮件反馈。推荐的做法是将其选上。敏捷高效的团队不应该忽略持续集成中的任何不健康因素。

#Hudson工作目录
- 到目前为止，本章都是从用户界面的角度介绍Hudson的各种功能。
- 用心的读者可以想象到，Hudson的各种配置、任务、报告肯定是以文件的形式存储在磁盘中的。
- 这就是Hudson的工作目录，了解该目录不仅能帮助读者理解Hudson用户界面中的各种特性，更重要的是，读者需要明白怎样为Hudson分配合理的磁盘空间，长期运行的持续集成服务往往会消耗大量的磁盘空间，理解哪些任务对应的哪些文件消耗了多少磁盘空间，对持续集成服务的维护来说至关重要。
- 默认情况下，Jenkins使用用户目录下的.jenkins/目录作为其工作目录。 ~/.jenkins/
- 由于该目录会渐渐消耗大量的磁盘空间，因此用户往往会希望自定义该工作目录的位置，这时用户可以设置环境变量HUDSON_HOME，例如将其设置为D：\hudson-work。
- 一个典型的Hudson工作目录包含:
·*.xml： 这些XML文件是Hudson核心及相关插件的配置，如config.xml配置了全局的JDK、任务视图等信息，hudson.tasks.Maven.xml配置了Maven安装信息，hudson.tasks.Mailer.xml配置了邮件服务器信息，等等。
·war： 如果用户独立运行hudson.war，那么其内容会被释放到该目录中后再启动。
·users： Hudson所存储的用户信息。
·userContent： 用户可以将任意内容放到该目录下后通过Hudson服务页面的子路径访问，如http://192.168.1.101：8080/userContent/ 。
·updates： 这里存储了各类可更新的插件信息。
·plugins： 所有Hudson插件都被安装在该目录而不会影响到Hudson的核心。
·jobs： 该目录包含了所有Hudson任务的配置、存储的构建、归档的构建输出等内容。本节稍后会详细解释该目录。
- 上述目录中最重要的可能就是jobs子目录了，这里包含了所有Hudson的任务配置、每个任务的工作区、构建历史等信息，jobs目录下有两个子目录account和maven3，它们分别对应了两个Hudson任务。每个任务都会包含如config.xml、nextBuildNumber、scm-polling.log等文件，其中的config.xml包含了该任务的所有配置，如SCM地址、轮询频率等。
- .jenkins目录下会包含一个workspace子目录，这就是该任务的工作区。这里有最近一次构建所包含的源代码及相关输出。

- 任务目录下还有一个builds子目录，该目录包含了所有Hudson记录的历史构建，每个构建对应了一个目录，这些目录都是以构建所发生的时间命名的，如2010-04-15_14-56-08，每个构建目录包含了一些文件记录其成功失败信息、构建日志、测试报告、变更记录等。如果用户为该任务配置了文件归档，那么每次构建归档的内容都会存储在archive子目录下。

#Chapter 12 使用Maven构建Web应用
- 到目前为止，本书讨论的只有打包类型为JAR或者POM的Maven项目。但在现今的互联网时代，我们创建的大部分应用程序都是Web应用，在Java的世界中，Web项目的标准打包方式是WAR
- 还介绍如何借助jetty-maven-plugin来快速开发和测试Web模块，
- 以及使用Cargo实现Web项目的自动化部署

#Web项目的目录结构
- 基于Java的Web应用，其标准的打包方式是WAR。
- WAR与JAR类似，只不过它可以包含更多的内容，如JSP文件、Servlet、Java类、web.xml配置文件、依赖JAR包、静态web资源（如HTML、CSS、JavaScript文件）等。
- 一个典型的WAR文件会有如下目录结构：

-war/
+ META-INF/
+ WEB-INF/
| + classess/
| | + ServletA.class
| | + config.properties
| | + ...
| |
| + lib/
| | + dom4j-1.4.1.jar
| | + mail-1.4.1.jar
| | + ...
| |
| + web.xml
| 
+ img/
| 
+ css/
|
+ js/
|
+ index.html
+ sample.jsp 

- 一个WAR包下至少包含两个子目录：META-INF和WEB-INF。
- 前者包含了一些打包元数据信息，我们一般不去关心；
- 后者是WAR包的核心，WEB-INF下必须包含一个Web资源表述文件web.xml，
- 子目录classes包含所有该Web项目的类，
- 子目录lib则包含所有该Web项目的依赖JAR包，classes和lib目录都会在运行的时候被加入到Classpath中。
- 除了META-INF和WEB-INF外，一般的WAR包都会包含很多Web资源，在WAR包的根目录下看到html或者jsp文件。
- 此外，还能看到一些文件夹如img、css和js，它们会包含对应的文件供页面使用

- 首先用户必须为Web项目显式指定打包方式为war
  <groupId>com.juvenxu.mvnbook.account</groupId>
  <artifactId>sample-web</artifactId>
  <packaging>war</packaging>
  <name>Account Web</name>
  <version>1.0.0-SNAPSHOT</version>
- 如果不显式地指定packaging，Maven会使用默认的jar打包方式，从而导致无法正确打包Web项目。
- 同任何其他Maven项目一样，Maven对Web项目的布局结构也有一个通用的约定。
- Web项目的类及资源文件同一般JAR项目一样，默认位置都是src/main/java/和src/main/resources， 测试类及测试资源文件的默认位置是src/test/java/和src/test/resources/。
- Web项目比较特殊的地方在于：它还有一个Web资源目录，其默认位置是src/main/webapp/。一个典型的Web项目 的Maven目录结构如下：
+ project
|
+ pom.xml
|
+ src/
  + main/
  | + java/
  | | + ServletA.java
  | | + ...
  | + resources/
  | | + config.properties
  | | + ...
  | |
  | + webapp/
  |    + WEB-INF/
  |    | + web.xml
  |    |
  |    + img/
  |    |
  |    + css/
  |    |
  |    + js/
  |    |
  |    +
  |    + index.html
  |    + sample.jsp
  |
  + test/
     + java/
     + resources/

- 在src/main/webapp/目录下，必须包含一个子目录WEB-INF，该子目录还必须要包含web.xml文件。
- src/main/webapp目录下的其他文件和目录包括html、jsp、css、JavaScript等，它们与WAR包中的Web资源完全一致。
- 在使用Maven创建Web项目之前，必须首先理解这种Maven项目结构和WAR包结构的对应关系。
- WAR包中有一个lib目录包含所有依赖JAR包，但Maven项目结构中没有这样一个目录，这是因为依赖都配置在POM中，Maven在用WAR方式打包的时候会根据POM的配置从本地仓库复制相应的JAR文件。

#account-service
- 本章将完成背景案例项目，除了之前实现的account-email、account-persist和account-captcha之外，该项目还包括account-service和account-web两个模块。
-  account-service用来封装底层三个模块的细节，并对外提供简单的接口，
- 而account-web仅包含一些涉及Web的相关内容，如Servlet和JSP等。

#12.2.1　account-service的POM
- account-service用来封装account-email、account-persist和account-captcha三个模块的细节，因此它肯定需要依赖这三个模块:
<modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.juvenxu.mvnbook.account</groupId>
    <artifactId>account-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
  </parent>

  <artifactId>account-service</artifactId>
  <name>Account Service</name>

  <properties>
    <greenmail.version>1.3.1b</greenmail.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>${project.groupId}</groupId>
      <artifactId>account-email</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>${project.groupId}</groupId>
      <artifactId>account-persist</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>${project.groupId}</groupId>
      <artifactId>account-captcha</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>com.icegreen</groupId>
      <artifactId>greenmail</artifactId>
      <version>${greenmail.version}</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <testResources>
      <testResource>
        <directory>src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
  </build>
- account-service继承自account-parent，它依赖于account-email、account-persist和account-captcha三个模块。
- 由于是同一项目中的其他模块，groupId和version都完全一致，因此可以使用Maven属性＄{project.groupId}和＄{project.version}进行替换，这样可以在升级项目版本的时候减少更改的数量。
- 项目的其他配置如junit和greenmail依赖，以及测试资源目录过滤配置，都是为了单元测试。

#account-web
-。由于account-service已经封装了所有下层细节，account-web只需要在此基础上提供一些Web页面，并使用简单Servlet与后台实现交互控制。

account-web的POM: 除了使用打包方式war之外，Web项目的POM与一般项目并没多大的区别
<parent>
    <groupId>com.juvenxu.mvnbook.account</groupId>
    <artifactId>account-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
  </parent>

  <artifactId>account-web</artifactId>
  <packaging>war</packaging>
  <name>Account Web</name>

  <dependencies>
    <dependency>
      <groupId>${project.groupId}</groupId>
      <artifactId>account-service</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.4</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
    </dependency>
  </dependencies>

  <build>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
    </resources>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.mortbay.jetty</groupId>
          <artifactId>jetty-maven-plugin</artifactId>
          <version>7.1.0.RC1</version>
          <configuration>
            <scanIntervalSeconds>10</scanIntervalSeconds>
            <webAppConfig>
              <contextPath>/account</contextPath>
            </webAppConfig>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>

- account-web的packaging元素值为war，表示这是一个Web项目，需要以war方式进行打包。
- account-web依赖于servlet-api和jsp-api这两个几乎所有Web项目都要依赖的包，它们为servlet和jsp的编写提供支持。
- 这两个依赖的范围是provided，表示它们最终不会被打包至war文件中，这是因为几乎所有Web容器都会提供这两个类库，如果war包中重复出现，就会导致潜在的依赖冲突问题。
- account-web还依赖于account-service和spring-web，其中前者为Web应用提供底层支持，后者为Web应用提供Spring的 集成支持。
- 在一些Web项目中，读者可能会看到finalName元素的配置。
- 该元素用来标识项目生成的主构件的名称，该元素的默认值已在超级POM中设定，值为＄{project.artifactId}-＄{project.version}，因此代码清单12-8对应的主构件名称为account-web-1.0.0-SNAPSHOT.war。
- 不过，这样的名称显然不利于部署，不管是测试环境还是最终产品环境，我们都不想在访问页面的时候输入冗长的地址，因此我们会需要名字更为简洁的war包。这时可以如下所示配置finalName元素：
<finalName>account</finalName>
- 经此配置后，项目生成的war包名称就会成为account.war，更方便部署。

#使用jetty-maven-plugin进行测试
- 在进行Web开发的时候，我们总是无法避免打开浏览器对应用进行测试，比如为了验证程序功能、验证页面布局，尤其是一些与页面相关的特性，手动部署到Web容器进行测试似乎是唯一的方法。
- 近年来出现了很多自动化的Web测试技术如Selenium，它能够录制Web操作，生成各种语言脚本，然后自动重复这些操作以进行测试。应该说，这类技术方法是未来的趋势，但无论如何，手动的、亲眼比对验证的测试是无法被完全替代的。
- 测试Web页面的做法通常是将项目打包并部署到Web容器中，本节介绍如何使用jetty-maven-plugin，以使这些步骤更为便捷。
- 在介绍jetty-maven-plugin之前，笔者要强调一点，虽然手动的Web页面测试是必不可少的，但这种方法绝不应该被滥用。
- 现实中常见的情况是，很多程序员即使修改了一些较底层的代码（如数据库访问、业务逻辑），都会习惯性地打开浏览器测试整个应用，这往往是没有必要的。可以用单元测试覆盖的代码就不应该依赖于Web页面测试，且不说页面测试更加耗时耗力，这种方式还无法自动化，更别提重复性了。
- 因此Web页面测试应该仅限于页面的层次，例如JSP、CSS、JavaScript的修改，其他代码修改（如数据访问），请编写单元测试。

- 传统的Web测试方法要求我们编译、测试、打包及部署，这往往会消耗数10秒至数分钟的时间，jetty-maven-plugin能够帮助我们节省时间，它能够周期性地检查项目内容，发现变更后自动更新到内置的Jetty Web容器中。
- 省去了打包和部署的步骤。
- jetty-maven-plugin默认就很好地支持了Maven的项目目录结构。
- 只需要直接在IDE中修改源码，IDE能够执行自动编译，jetty-maven-plugin发现编译后的文件变化后，自动将其更新到Jetty容器，这时就可以直接测试Web页面了。

- 使用jetty-maven-plugin十分简单。指定该插件的坐标，并且稍加配置即可:
      <plugins>
        <plugin>
          <groupId>org.mortbay.jetty</groupId>
          <artifactId>jetty-maven-plugin</artifactId>
          <version>7.1.0.RC1</version>
          <configuration>
            <scanIntervalSeconds>10</scanIntervalSeconds>
            <webAppConfig>
              <contextPath>/account</contextPath>
            </webAppConfig>
          </configuration>
        </plugin>
      </plugins>

- jetty-maven-plugin并不是官方的Maven插件，它的groupId是org.mortbay.jetty，上述代码中使用了Jetty 7的最新版本。
- 在该插件的配置中，scanIntervalSeconds顾名思义表示该插件扫描项目变更的时间间隔，这里的配置是每隔10秒。
- 需要注意的是，如果不进行配置，该元素的默认值是0，表示不扫描，用户也就失去了所谓的自动化热部署的功能。
- 上述代码中webappConfig元素下的contextPath表示项目部署后的context path。
- 默认情况下，只有org.apache.maven.plugins和org.codehaus.mojo两个groupId下的插件才支持简化的命令行调用，即可以运行mvn help：system，但mvn jetty：run就不行了。 因为maven-help-plugin的groupId是org.apache.maven.plugins， 而jetty-maven-plugin的groupId是org.mortbay.jetty。为了能在命令行直接运行mvn jetty：run， 用户需要配置settings.xml如下：

...

- 现在可以运行如下命令启动jetty-maven-plugin：
mvn jetty:run
- jetty-maven-plugin会启动Jetty，并且默认监听本地的8080端口，并将当前项目部署到容器中，同时它还会根据用户配置扫描代码改动。 如果希望使用其他端口，可以添加jetty.port参数。例如：
mvn jetty:run -Djetty.port=9999
- 启动Jetty之后，用户可以在IDE中修改各类文件，如JSP、HTML、CSS、JavaScript甚至是Java类。只要不是修改类名、方法名等较大的操作，jetty-maven-plugin都能够扫描到变更并正确地将变化更新至Web容器中，这无疑在很大程度上帮助了用户实现快速开发和测试。
- 上面的内容仅仅展示了jetty-maven-plugin最核心的配置点，如果有需要，还可以自定义web.xml的位置、项目class文件的位置、web资源目录的位置等信息。
- 用户还能够以WAR包的方式部署项目，甚至在Maven的生命周期中嵌入jetty-maven-plugin。例如，先启动Jetty容器并部署项目，然后执行一些集成测试，最后停止容器。有兴趣进一步研究的读者可以访问该页面：http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin 。
  <pluginGroups>
      <pluginGroup>org.mortbay.jetty</pluginGroup>
  </pluginGroups>

#使用Cargo实现自动化部署
- Cargo是一组帮助用户操作Web容器的工具，它能够帮助用户实现自动化部署，
- 而且它几乎支持所有的Web容器，如Tomcat、JBoss、Jetty和Glassfish等。
- Cargo通过cargo-maven2-plugin提供了Maven集成，Maven用户可以使用该插件将Web项目部署到Web容器中。
- 虽然cargo-maven2-plugin和jetty-maven-plugin的功能看起来很相似，但它们的目的是不同的，jetty-maven-plugin主要用来帮助日常的快速开发和测试，
- cargo-maven2-plugin主要服务于自动化部署。例如专门的测试人员只需要一条简单的Maven命令，就可以构建项目并部署到Web容器中，然后进行功能测试。

#部署至本地Web容器
- Cargo支持两种本地部署的方式，分别为standalone模式和existing模式。
- 在standalone模式中，Cargo会从Web容器的安装目录复制一份配置到用户指定的目录，然后在此基础上部署应用，每次重新构建的时候，这个目录都会被清空，所有配置被重新生成。
<plugin>  
    <groupId>org.codehaus.cargo</groupId>  
    <artifactId>cargo-maven2-plugin</artifactId>  
    <version>1.4.9</version>  
    <configuration>  
        <container>  
            <containerId>tomcat7x</containerId>  
            <home>C:\Program Files\apache-tomcat-7.0.77</home>  
        </container>  
        <configuration>  
            <type>standalone</type>  
            <home>${project.build.directory}/tomcat7x</home>  
            <properties>  
                <!-- 更改监听端口 -->  
                <cargo.servlet.port>8088</cargo.servlet.port>  
            </properties>  
        </configuration>  
    </configuration>  
</plugin>  
- cargo-maven2-plugin的groupId是org.codehaus.cargo，这不属于官方的两个Maven插件groupId，因此用户需要将其添加到settings.xml的pluginGroup元素中以方便命令行调用。
<pluginGroup>org.codehaus.cargo</pluginGroup>
-上述cargo-maven2-plugin的具体配置包括了container和configuration两个元素，configuration的子元素type表示部署的模式（这里是standalone）。与之对应的，configuration的home子元素表示复制容器配置到什么位置，这里的值为＄{project.build.directory}/tomcat7x，表示构建输出目录，即target/下的tomcat7x子目录。
- container元素下的containerId表示容器的类型，home元素表示容器的安装目录。
- 基于该配置，Cargo会从C:\Program Files\apache-tomcat-7.0.77目录下复制配置到当前项目的target/tomcat7x/目录下。
- 让Cargo启动Tomcat并部署应用: mvn cargo:start
- http://localhost:8088/account-web-1.0.0-SNAPSHOT/signup.jsp
<Test Failed> start log ok, failed to connect to http port 8080
- 而在existing模式中，用户需要指定现有的Web容器配置目录，然后Cargo会直接使用这些配置并将应用部署到其对应的位置。
<plugin>  
    <groupId>org.codehaus.cargo</groupId>  
    <artifactId>cargo-maven2-plugin</artifactId>  
    <version>1.4.9</version>  
    <configuration>  
        <container>  
            <containerId>tomcat7x</containerId>  
            <home>C:\Program Files\apache-tomcat-7.0.77</home>  
        </container>  
        <configuration>  
            <type>exisitng</type>  
            <home>${project.build.directory}/tomcat7x</home>  
            <properties>  
                <!-- 更改监听端口 -->  
                <cargo.servlet.port>8088</cargo.servlet.port>  
            </properties>  
        </configuration>  
    </configuration>  
</plugin>  
- 上述代码中configuration元素的type子元素的值为existing，而对应的home子元素表示现有的Web容器目录，基于该配置运行mvn cargo：start之后，便能够在Tomcat的
webapps子目录看到被部署的Maven项目。
- 部署至远程Web容器除了让Cargo直接管理本地Web容器然后部署应用之外，也可以让Cargo部署应用至远程的正在运行的Web容器中。当然，前提是拥有该容器的相应管理员权限。
  <plugin>  
    <groupId>org.codehaus.cargo</groupId>  
    <artifactId>cargo-maven2-plugin</artifactId>  
    <version>1.4.9</version>  
    <configuration>  
        <container>  
            <containerId>tomcat7x</containerId>  
            <type>remote</type>  
        </container>  
        <configuration>  
            <type>runtime</type>  
            <properties>  
                <cargo.tomcat.manager.url>http://localhost:8080/manager/text</cargo.tomcat.manager.url>  
                <cargo.remote.username>admin</cargo.remote.username>  
                <cargo.remote.password>password</cargo.remote.password>  
            </properties>  
        </configuration>        
</plugin>  
- 对于远程部署的方式来说，container元素的type子元素的值必须为remote。
- 如果不显式指定，Cargo会使用默认值installed，并寻找对应的容器安装目录或者安装包，对于远程部署方式来说，安装目录或者安装包是不需要的。
- 上述代码中configuration的type子元素值为runtime，表示既不使用独立的容器配置，也不使用本地现有的容器配置，而是依赖于一个已运行的容器。
- properties元素用来声明一些容器热部署相关的配置。Tomcat 7就需要提供用户名、密码以及管理地址。 
- 这部分部分配置元素对于所有容器来说不是一致的，读者需要查阅对应的Cargo文档。
- mvn cargo:redploy
- 如果容器中已经部署了当前应用，Cargo会先将其卸载，然后再重新部署。
- 由于自动化部署本身就不是简单的事情，再加上Cargo要兼容各种不同类型的Web容器，因此cargo-maven2-plugin的相关配置会显得相对复杂，这个时候完善的文档就显
得尤为重要。如果想进一步了解Cargo，可访问http://cargo.codehaus.org/Maven2+plugin 。

- 本章介绍的是用Maven管理Web项目，
- 因此首先讨论了Web项目的基本结构，
- 开发Web项目的时候，大家往往会使用热部署来实现快速的开发和测试，jetty-maven-plugin可以帮助实现这一目标。
- 本章最后讨论的是自动化部署，这一技术的主角是Cargo，有了它，可以让Maven自动部署应用至本地和远程Web容器中。

#Chapter 13 版本管理
- 一个健康的项目通常有一个长期、合理的版本演变过程。
- 例如JUnit有3.7、3.8、3.8.1、3.8.2、4.0、4.1等版本。
- Maven本身的版本也比较多，如最早的Maven 1；Maven 2有2.0.9、2.0.10、2.1.0、2.2.0、2.2.1等各种版本；Maven 3则拥有3.0-alpha-1、3.0-alpha-2、3.0-alpha-7、3.0-beta-1等版本。 
- 除了这些对外发布的版本之外，6.5节还介绍了Maven特有的快照版本的概念。这些版本中的每个数字代表了什么？alpha、beta是什么意思？快照版和发布版的区别是什么？我们应该如何科学地管理自己的项目版本？本章将会详细解答这些问题。

- 分清版本管理（Version Management）和版本控制（Version Control）的区别。
- 版本管理是指项目整体版本的演变过程管理，如从1.0-SNAPSHOT到1.0，再到1.1-SNAPSHOT。
- 版本控制是指借助版本控制工具（如Subversion）追踪代码的每一个变更。
- 本章重点讲述的是版本管理，但是读者将会看到，版本管理通常也会涉及一些版本控制系统的操作及概念。请在阅读的时候特别留意这两者的关系和区别。

#何为版本管理
- 为了方便团队的合作，在项目开发的过程中，大家都应该使用快照版本，Maven能够很智能地处理这种特殊的版本，解析项目各个模块最新的“快照”。
- 快照版本机制促进团队内部的交流，但是当项目需要对外发布时，我们显然需要提供非常稳定的版本，使用该版本应当永远只能够定位到唯一的构件，而不是像快照版本那
样，定位的构件随时可能发生变化。对应地，我们称这类稳定的版本为发布版。
- 项目发布了一个版本之后，就进入下一个开发阶段，项目也就自然转换到新的快照版本中。
- 版本管理关心的问题之一就是这种快照版和发布版之间的转换。项目经过了一段时间的1.0-SNAPSHOT的开发之后，在某个时刻发布了1.0正式版，然后项目又进入了
1.1-SNAPSHOT的开发，这个版本可能添加了一些有趣的特性，然后在某个时刻发布1.1正式版。项目接着进入1.2-SNAPSHOT的开发。
- 由于快照对应了项目的开发过程，因此往往对应了很长的时间，而正式版本对应了项目的发布，因此仅仅代表某个时刻项目的状态:
- 理想的发布版本应当对应了项目某个时刻比较稳定的状态，这包括源代码的状态以及构建的状态，因此这个时候项目的构建应当满足以下的条件：
·所有自动化测试应当全部通过。 毫无疑问，失败的测试代表了需要修复的问题，因此发布版本之前应该确保所有测试都能得以正确执行。
·项目没有配置任何快照版本的依赖。 快照版本的依赖意味着不同时间的构建可能会引入不同内容的依赖，这显然不能保证多次构建能够生成同样的结果。
·项目没有配置任何快照版本的插件。 快照版本的插件配置可能会在不同时间引入不容内容的Maven插件，从而影响Maven的行为，破坏构建的稳定性。
·项目所包含的代码已经全部提交到版本控制系统中。 项目已经发布了，可源代码却不在版本控制系统中，甚至丢失了。这意味着项目丢失了某个时刻的状态，因此
这种情况必须避免，版本发布的时候必须确保所有的源代码都已经提交了。

- 只有上述条件都满足之后，才可以将快照版本更新为发布版本，例如将1.0-SNAPSHOT更新为1.0，然后生成版本为1.0的项目构件。
- 不过这里还缺少一步关键的版本控制操作。如果你了解任何一种版本控制工具，如Subversion，那就应该能想到项目发布与标签（Tag）的关系。
- 版本控制系统记录代码的每一个变化，通常这些变化都被维护在主干（Trunk）中，但是当项目发布的时候，开发人员就应该使用标签记录这一特殊时刻项目的状态。以Subversion为例，日常的变更维护在主干中，包含各种源码版本r1、r2、…、r284、…。要找到某个时刻的项目状态会比较麻烦，而使用标签就可以明确地将某个源码版本（也就是项目状态）
从主干中标记出来，放到单独的位置，这样在之后的任何时刻，我们都能够快速地得到发布版本的源代码，从而能够比较各个版本的差异，甚至重新构建一个同样版本的
构件。
- 因此，将项目的快照版本更新至发布版本之后，应当再执行一次Maven构建，以确保项目状态是健康的。
- 然后将这一变更提交到版本控制系统的主干中。接着再为当前主干的状态打上标签。 
- 以Subversion为例，这几个步骤对应的命令如下：
$mvn clean install
$svn commit pom.xml -m "prepare to release 1.0"
$svn copy -m "tag release 1.0" \ https://svn.juvenxu.com/project.trunk \ https://svn.juvenxu.com/project/tags/1.0
- 至此，一个版本发布的过程完成了。接下来要做的就是更新发布版本至新的快照版本，如从1.0到1.1-SNAPSHOT。
- 项目到一个阶段后，就需要发布一个正式的版本（release版本）。一次正式的发布需要这样一些工作：
在trunk中，更新pom版本从1.0-SNAPSHOT到1.0
对1.0打一个svn tag
针对tag进行mvn deploy，发布正式版本
更新trunk从1.0到1.1-SNAPSHOT

#Maven的版本号定义约定
- 到目前为止，读者应该已经清楚了解了快照版和发布版的区别。
- 现在再深入看一下1.0、1.1、1.2.1、3.0-beta这样的版本号后面又遵循了怎样的约定。了解了这样的约定之后，就可以正确地为自己的产品或者项目定义版本号，而你的用户也能了解到隐藏在版本号中的信息。
- 看一个实际的例子，这里有一个版本：
1.3.4-beta-2
- 这往往表示了该项目或产品的第一个重大版本的,第三个次要版本的,第四次增量版本的,beta-2里程碑。
“1”表示了该版本是第一个重大版本；
“3”表示这是基于重大版本的第三个次要版本；
“4”表示该次要版本的第四个增量；
最后的“beta-2”表示该增量的某一个里程碑。
- 也就是说，Maven的版本号定义约定是这样的：<主版本>.<次版本>.<增量版本>-<里程碑版本>
- 主版本和次版本之间，以及次版本和增量版本之间用点号分隔，里程碑版本之前用连字号分隔：
·主版本： 表示了项目的重大架构变更。例如，Maven 2和Maven 1相去甚远；Struts 1和Struts 2采用了不同的架构；JUnit 4较JUnit 3增加了标注支持。
·次版本： 表示较大范围的功能增加和变化，及Bug修复。例如Nexus 1.5较1.4添加了LDAP的支持，并修复了很多Bug， 但从总体架构来说，没有什么变化。
·增量版本： 一般表示重大Bug的修复，例如项目发布了1.4.0版本之后，发现了一个影响功能的重大Bug，则应该快速发布一个修复了Bug的1.4.1版本。
·里程碑版本： 指某一个版本的里程碑。例如，Maven 3已经发布了很多里程碑版本，如3.0-alpha-1、3.0-alpha-2、3.0-beta-1等 。 这样的版本与正式的3.0相比，往往表示不是非常稳定，还需要很多测试。
- 需要注意的是，不是每个版本号都必须拥有这四个部分。一般来说，主版本和次版本都会声明，但增量版本和里程碑就不一定了。例如，像3.8这样的版本没有增量和里程碑，2.0-beta-1没有增量。但我们不会看到有人省略次版本，简单地给出主版本显然是不够的。
- **当用户在声明依赖或插件未声明版本时，Maven就会根据上述的版本号约定自动解析最新版本。
- 这个时候就需要对版本号进行排序。对于主版本、次版本和增量版本来说，比较是基于数字的，因此1.5>1.4>1.3.11>1.3.9。而对于里程碑版本，Maven则只进行简单的字符串比较，因此会得到1.2-beta-3>1.2-beta-11的结果。这一点需要留意。

#主干、标签与分支
- 使用版本控制工具时我们都会遇到主干（trunk）、标签（tag）和branch（分支）的概念。
- 这里再详细将这几个概念阐述一下，因为理解它们是理解Maven版本管理的基础。
·主干： 项目开发代码的主体，是从项目开始直到当前都处于活动的状态。 从这里可以获得项目最新的源代码以及几乎所有的变更历史。
·分支： 从主干的某个点分离出来的代码拷贝，通常可以在不影响主干的前提下在这里进行重大Bug的修复，或者做一些实验性质的开发。如果分支达到了预期的目的，通常发生在这里的变更会被合并（merge）到主干中。
·标签： 用来标识主干或者分支的某个点的状态，以代表项目的某个稳定状态，这通常就是版本发布时的状态。
- 本书采用Subversion作为版本控制系统，如果对上述概念不清晰，请参考开放的《Subversion与版本控制》（http://svnbook.red-bean.com/ ）一书。
- 使用Maven管理项目版本的时候，也涉及了很多的版本控制系统操作。下面就以一个实际的例子来介绍这些操作是如何执行的。
- 图13-2下方最长的箭头表示项目的主干，项目最初的版本是1.0.0-SNAPSHOT，经过一段时间的开发后，1.0.0版本发布，这个时候就需要打一个标签，图中用一个长条表示。
- 然后项目进入1.1.0-SNAPSHOT状态，大量的开发工作都完成在主干中，添加了一些新特性并修复了很多Bug之后，项目1.1.0发布，同样，这时候需要打另一个标签。
- 发布过后，项目进入1.2.0-SNAPSHOT阶段，可这个时候用户报告1.1.0版本有一个重大的Bug，需要尽快修复，我们不能在主干中修Bug，因为主干有太多的变化，无法在短时间内测试完毕并发布，我们也不能停止1.2.0-SNAPSHOT的开发，因此这时候可以基于1.1.0创建一个1.1.1-SNAPSHOT的分支，在这里进行Bug修复，然后为用户发布一个1.1.1增量版本，同时打上标签。
- 当然，还不能忘了把Bug修复涉及的变更合并到1.2.0-SNAPSHOT的主干中。主干在开发一段时间之后，发布1.2.0版本，然后进入
到新版本1.3.0-SNAPSHOT的开发过程中。

#13.4　自动化版本发布
- 本章前几节已经详细介绍了版本发布时所需要完成的工作，读者如果愿意，则完全可以手动地执行这些操作，检查是否有未提交代码、是否有快照依赖、更新快照版至发布版、执行Maven构建以及为源代码打标签等。
- 事实上，如果对这一过程不是很熟悉，那么还是应该一步一步地操作一遍，以得到最直观的感受。
- 当熟悉了版本发布流程之后，就会希望借助工具将这一流程自动化。Maven Release Plugin就提供了这样的功能， 只要提供一些必要的信息，它就能帮我们完成上述所有版本发布所涉及的操作。下面介绍如何使用Maven Release Plugin发布项目版本。

#Maven Release Plugin
- 主要有三个目标，它们分别为：
·release：prepare 准备版本发布，依次执行下列操作：
- 检查项目是否有未提交的代码。
- 检查项目是否有快照版本依赖。
- 根据用户的输入将快照版本升级为发布版。
- 将POM中的SCM信息更新为标签地址。
- 基于修改后的POM执行Maven构建。
- 提交POM变更。
- 基于用户输入为代码打标签。
- 将代码从发布版升级为新的快照版。
- 提交POM变更。
·release：rollback 
- 回退release：prepare所执行的操作。
- 将POM回退至release：prepare之前的状态，并提交。需要注意的是，该步骤不会删除release：prepare生成的标签，
因此用户需要手动删除。
·release：perform 执行版本发布。签出release：prepare生成的标签中的源代码，并在此基础上执行mvn deploy命令打包并部署构件至仓库。
- 要为项目发布版本，首先需要为其添加正确的版本控制系统信息，这是因为Maven Release Plugin需要知道版本控制系统的主干、标签等地址信息后才能执行相关的操作。一般配置项目的SCM信息:
<scm>  
  <connection>scm:svn:http://192.168.1.103/app/trunk/</connection>  
  <developerConnection>scm:svn:https://192.168.1.103/app/trunk/</developerConnection>
  <url>http://192.168.1.103/account/trunk</url>
</scm>
- connection元素表示一个只读的scm地址，而developerConnection元素表示可写的scm地址，url则表示可以在浏览器中访问的scm地址。
- 为了能让Maven识别，connection和developerConnection必须以scm开头，冒号之后的部分表示版本控制工具类型（这里是svn），Maven还支持cvs、git等。接下来才是实际的scm地址，该例中的connection使用了http协议，而developerConnection则由于涉及写操作，使用https协议进行了保护。
- 该配置只告诉Maven当前代码的位置（主干），而版本发布还要涉及标签操作。因此，还需要配置Maven Release Plugin告诉其标签的基础目录:
<plugin>  
  <groupId>org.apache.maven.plugins</groupId>  
  <artifactId>maven-release-plugin</artifactId>  
  <version>2.0</version>  
  <configuration>  
    <tagBase>https://192.168.1.103/app/tags/</tagBase>  
  </configuration>  
</plugin>
- 在执行release：prepare之前还有两个注意点：第一，系统必须要提供svn命令行工具，Maven需要svn命令行工具执行相关操作，而无法使用图形化的工具，如TortoiseSVN；第二，POM必须配置了可用的部署仓库，因为release：perform会执行deploy操作将构件发布到仓库中。
mvn release:prepare
- Maven Release Plugin开始准备发布版本，如果它检测到项目有未提交的代码，或者项目有快照版的依赖，则会提示出错。如果一切都没问题，则会提示用户输入想要发布的版本号、标签的名称以及新的快照版本号:
- 如果项目的artifactId为app，发布前的版本为1.0.0-SNAPSHOT，则Maven Release Plugin会提示使用发布版本号1.0.0， - 使用标签名称app-1.0.0，新的开发版本为1.0.1-SNAPSHOT。如果这些模式值正是你想要的，直接按Enter键即可，否则就输入想要的值再按Enter键，如上例中为新的开发版本输入了值1.1.0-SNAPSHOT。
- 基于这些信息，Maven Release Plugin会将版本从1.0.0-SNAPSHOT更新为1.0.0，并更新SCM地址http://192.168.1.103/app/trunk 至http://192.168.1.103/app/tags/app-1.0.0 。
- 在此基础上运行一次Maven构建以防止意外的错误出现，然后将这两个变化提交，并为该版本打上标签，标签地址是http://192.168.1.103/app/tags/app-1.0.0 。即tagBase路径加上标签名称。之后，Maven Release Plugin 会将POM中的版本信息从1.0.0 升级到1.1.0-SNAPSHOT并提交。

- 至此，release：prepare的工作完成。如果这时你发现了一些问题，例如将标签名称配置错了，则可以使用release：rollback命令回退发布，Maven Release Plugin会将POM的配置回退到release：prepare之前的状态。 但需要注意的是， 版本控制系统中的标签并不会被删除， 也就是说， 用户需要手动执行版本控制系统命令删除该标签。
- 在多模块项目中执行release：prepare的时候，默认maven-release-plugin会提示用户设定每个模块发布版本号及新的开发版本号。例如，如果在account-parent模块中配置正确的scm信息之后进行项目发布，就会看到如下的输出：
- 在很多情况下，我们会希望所有模块的发布版本以及新的SNAPSHOT开发版本都保持一致。为了避免重复确认，maven-release-plugin提供了autoVersionSubmodules参
数。例如运行下面的命令后，maven-release-plugin就会自动为所有子模块使用与父模块一致的发布版本和新的SNAPSHOT版本：
$mvn release:prepare -DautoVersionSubmodules=true
- 如果检查下来release：prepare的结果没有问题，标签和新的开发版本都是正确的，可以执行如下发布执行命令
mvn release:perform
- 该命令将标签中的代码签出，执行mvn deploy命令构建刚才准备的1.0.0版本，并部署到仓库中。至此，版本1.0.0正式发布完成。由于它已经被部署到了Maven仓库中，
其他人可以方便地配置对它的依赖。
- 如果你所发布项目的打包类型为jar，在执行release：perform之后，不仅项目的主构件会被生成并发布到仓库中，基于该主构件的-sources.jar
和-javadoc.jar也会生成并发布。对于你的用户来说，这无疑是非常方便的，他们不仅能够下载你的主构件，还能够得到项目的源码和Javadoc。那么，release：perform是怎
样生成-sources.jar和-javadoc.jar的呢？
- 8.5节介绍过，所有Maven项目的POM都继承自超级POM，而如果打开超级POM:
- 超级POM中sources和javadoc的配置:
<profiles>
    <!-- NOTE: The release profile will be removed from future versions of the super POM -->
    <profile>
      <id>release-profile</id>

      <activation>
        <property>
          <name>performRelease</name>
          <value>true</value>
        </property>
      </activation>

      <build>
        <plugins>
          <plugin>
            <inherited>true</inherited>
            <artifactId>maven-source-plugin</artifactId>
            <executions>
              <execution>
                <id>attach-sources</id>
                <goals>
                  <goal>jar</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
          <plugin>
            <inherited>true</inherited>
            <artifactId>maven-javadoc-plugin</artifactId>
            <executions>
              <execution>
                <id>attach-javadocs</id>
                <goals>
                  <goal>jar</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
          <plugin>
            <inherited>true</inherited>
            <artifactId>maven-deploy-plugin</artifactId>
            <configuration>
              <updateReleaseInfo>true</updateReleaseInfo>
            </configuration>
          </plugin>
        </plugins>
      </build>
    </profile>
  </profiles>
- 超级POM中定义了一个名为release-profile的Maven Profile，Profile是指一段在特定情况下被激活并更改Maven行为的配置，
- 这里看到activate元素下有一个名为performRelease、值为true的属性配置，这表示当Maven运行时，如果运行环境中有performRelease属性且值为true的时候，该Profile就被激活。也就是说，该Profile下的配置会得到应用。那么，什么情况下Maven运行环境中会有名为performRelease、值为true的属性呢？
- 可以在命令行指定: mvn clean install -DperformRelease=true
- 在执行release：perform的时候，Maven Release Plugin会自动生成值为true的performRelease属性。 这时，超级POM中的release-profile就会被激活。
- 这个Profile配置了3个Maven插件，maven-sources-plugin的jar目标会为项目生成-source.jar文件，maven-javadoc-plugin的jar目标会为项目生成-javadoc.jar文件，而maven-deploy-plugin的update-release-info配置则会在部署的时候更新仓库中的元数据，告诉仓库该版本是最新的发布版。每个插件配置中值为true的inherited元素则表示该插件配置可以被子POM继承。
- 在日常的快照开发过程中，往往没有必要每次都生成-source.jar和-javadoc.jar，但是当项目发布的时候，这些文件就显得十分重要。
- 超级POM中的release-profile就是为了这种情形而设计的。
- 这种隐式的配置对于不熟悉Maven的用户来说可能会显得十分令人费解，因此将来的Maven版本中可能会从超级POM中移除这段配置，所以如果用户希望在发布版本时自动生成-sources.jar和-javadoc.jar，最好还是在自己的POM中显式地配置这些插件。

#13.5　自动化创建分支
- 13.4节介绍了如何使用Maven Release Plugin自动化版本发布，如果回顾一下图13-2，就会发现分支创建的操作还没有具体涉及。
- 本节就继续基于实际的样例讲解如何自动化创建分支。
- 在正式发布版本1.1.0的同时，还可以创建一个分支用来修复将来这个版本可能遇到的重大Bug。
- 这个过程可以手工完成，例如使用svn copy操作将主干代码复制到一个名为1.1.x的分支中，然后修改分支中的POM文件， 升级其版本为1.1.1-SNAPSHOT， 这会涉及很多Subversion操作。
- 使用Maven Release Plugin的branch目标，它能够帮我们自动化这些操作：
·检查本地有无未提交的代码。
·为分支更改POM的版本，例如从1.1.0-SNAPSHOT改变成1.1.1-SNAPSHOT。
·将POM中的SCM信息更新为分支地址。
·提交以上更改。
·将主干的代码复制到分支中。
·修改本地代码使其回退到分之前的版本（用户可以指定新的版本）。
·提交本地更改。
当然，为了让Maven Release Plugin为我们工作，和版本发布一样，必须在POM中提供正确的SCM信息。此外，由于分支操作会涉及版本控制系统里的分支地址，因此
还要为Maven Release Plugin配置分支基础目录，
<plugin>  
  <groupId>org.apache.maven.plugins</groupId>  
  <artifactId>maven-release-plugin</artifactId>  
  <version>2.0</version>  
  <configuration>  
    <tagBase>https://192.168.1.103/app/tags/</tagBase>
    <branchBase>https://192.168.1.103/app/branches/</branchBase>  
  </configuration>  
</plugin>
- 然而tagBase和branchBase并非是一定要配置的。如果为版本控制仓库使用了标准的Subversion布局，即在平行的trunk/tags/branches目录下分别放置项目主干代码、标签代
码和分支代码，那么Maven Release Plugin就能够自动根据主干代码位置计算出标签及分支代码位置，因此你就可以省略这两项配置。
- 理解了创建分支所将执行的实际行为后，就可以在项目目录下运行如下命令以创建分支：
$mvn release:branch --DbranchName=1.1.x \ -DupdateBranchVersions=true -DupdateWorkingCopyVersions=false
- 上述命令中使用了Maven Release Plugin的branch目标，-DbranchName=1.1.x用来配置所要创建的分支的名称，-DupdateBranchVersions=true表示为分支使用新的版本，-DupdateWorkingCopyVersions=false表示不更新本地代码（即主干）的版本。运行上述命令之后，Maven会提示输入分支项目的版本:
- 用户根据自己的需要为分支输入新的版本后按Enter键，Maven就会处理其余的操作。最后，用户就能在源码库中找到Maven创建的分支，如https://192.168.1.103/app/branches/1.1.x/ 。在这里，POM中的版本已经升级到了1.1.1-SNAPSHOT。

#13.6　GPG签名
-从中央仓库下载第三方构件的时候，你可能会想要验证这些文件的合法性，例如它们是由开源项目官方发布的，并且没有被篡改过。
- 当发布自己项目给客户使用的时候，你的客户也会想要验证这些文件是否是由你的项目组发布的，且没有被恶意篡改过。 
- PGP（Pretty Good Privacy）就是这样一个用来帮助提高安全性的技术。PGP最常用来给电子邮件进行加密、解密以及提供签名，以提高电子邮件交流的安全性。本节介绍如何使用PGP技术为发布的Maven构件签名，为项目增强安全性。

#13.6.1　GPG及其基本使用
GnuPG（简称GPG，来自http://www.gnupg.org/）是PGP标准的一个免费实现，无论是类UNIX平台还是Windows平台， 都可以使用它。 
- GPG能够帮助我们为文件生成签名、管理密钥以及验证签名等。
- 首先，访问http://www.gnupg.org/download/ 下载对应自己平台的GPG分发包，按照官方的文档将GPG安装完毕，
- 运行如下命令检查安装：gpg --version
- 在使用GPG之前，先得为自己准备一个密钥对，即一个私钥和一个公钥。之后才可以使用私钥对文件进行签名，并且将公钥分发到公钥服务器供其他用户下载，用户可以使用公钥对签名进行验证。
使用如下命令生成密钥对：gpg --gen-key
- GPG会问你密钥的类型、大小和有效时间，通常使用默认的值即可。GPG还会要求你输入自己的名称、电子邮件地址和对密钥的注释，这些内容会被包含在公钥中并被你的用户看到，因此务必正确填写。最后，还可以提供一个密码来保护密钥，这不是强制性的，但通常最好提供以防止别人得到你的密钥后恶意使用。你将来需要使用私钥和密码为文件提供签名，因此一定要认证保护它们。
- 现在已经有了密钥对，就可以在命令行中查看它们（其他导入到本地机器的密钥也会被显示），如下面的命令可用来列出所有公钥：
gpg-list-keys
- 这里的/home/juven/.gnupg/pubring.gpg表示公钥存储的位置。以pub开头的一行显示公钥的长度（1024D）、ID（C6EED57A）以及创建日期（2010-01-13）。下一行显示了公钥的UID，也就是一个由名称、注释和邮件地址组成的字符串。最后一行显示的子钥不用关心。
- 类似地，下面的命令用来列出本机私钥： gpg --list -secret-keys
- 对GPG的公私钥有了基本的了解之后，就可以使用如下命令为任意文件创建一个ASCII格式的签名：
gpg --ab temp.java
- 这里的-a选项告诉GPG创建ASCII格式的输出，而-b选项则告诉GPG创建一个独立的签名文件。如果你的私钥拥有密码，这个时候就需要输入密码。如果私钥没有密码，那么只要他人获得了你的私钥，就能够以你的名义对任何内容进行签名，这是非常危险的。
- 在该例中，GPG会创建一个名为temp.java.asc的签名文件，这时就可以将这个后缀名为.asc的签名文件连同原始文件一起分发给你的用户。如果你的用户已经导入了你的公钥，就可以运行如下命令验证原始文件：
gpg --verify temp.java.asc
- 为了能让你的用户获取公钥并验证你分发的文件，需要将公钥分发到公钥服务器中。hkp：//pgp.mit.edu是美国 麻省理工学院提供的公钥服务器，运行如下命令可将公钥分发到该服务器中：: gpg --keyserver hkp://pgp.mit.edu --send-keys C6EED57A
- 这里的--keyserver选项用来指定分发服务器的地址，--send-keys用来指定想要分发公钥的ID。
- 你可以罗列本地公钥来查看它们的ID。需要注意的是，公钥会在各个公钥服务器中被同步，因此你不需要重复地往各个服务器分发同一公钥。
- 现在，你的用户可以将服务器上的公钥导入到本地机器：
gpg --keyserver hkp://pgp.mit.edu --recv-keys C6EED57A
- 上述就是一个基本的签名、分发并验证的流程，在使用Maven发布项目的时候，可以使用GPG为发布文件提供签名。
- 现在读者应该已经知道如何手工完成这一步骤了，下面介绍如何使用Maven GPG Plugin自动化签名这一步骤。
#13.6.2　Maven GPG Plugin
- 手动地对Maven构件进行签名并将这些签名部署到Maven仓库中是一件耗时的体力活。而使用Maven GPG Plugin只需要提供几行简单的配置，它就能够帮我们自动完成签名这一工作。
- 在使用Maven GPG Plugin之前，首先需要确认命令行下的gpg是可用的，然后如代码清单13-5所示配置POM。
<plugin>  
    <groupId>org.apache.maven.plugins</groupId>  
    <artifactId>maven-gpg-plugin</artifactId>  
    <version>1.0</version>  
    <executions>  
         <execution>  
        <id>sign-artifacts</id>  
        <phase>verify</phase>  
        <goals>  
              <goal>sign</goal>  
        </goals>  
         </execution>  
    </executions>  
</plugin>  
- 使用一般的mvn命令签名并发布项目构件：
$mvn clean deploy -Dgpg.passphrase=yourpassphrase
- 如果不提供-Dgpg.passphrase参数，运行时就会要求输入密码。
- 如果有一些已经发布了但没有被签名的文件，你仍然想对其签名并发布到Maven仓库中，上述方式显然是行不通的，因为POM已经不允许被修改。好在Maven GPGPlugin为此提供了另外一个目标:

...
- 在这里可以指定要签名的POM及相关文件、Maven仓库的地址和ID，Maven GPG Plugin就会帮你签名文件并部署到仓库中。
- 读者可以想到，GPG签名这一步骤只有在项目发布时才显得必要，对日常的SNAPSHOT构件进行签名不仅没有多大的意义，反而会比较耗时。因此，只需要配置Maven PGP Plugin在项目发布的时候运行，那么如何判断项目发布呢？回顾代码清单13-3，在超级POM中有一个release-profile，该Profile只有在Maven属性performRelease为true的时候才被激活，而release：perform执行的时候，就会将该属性置为true，这正是项目进行版本发布的时刻。
- 因此，类似地，可以在settings.xml或者POM中创建如代码清单13-6所示Profile。
<profiles>
    <profile>
      <id>release-profile</id>
      <activation>
        <property>
          <name>performRelease</name>
          <value>true</value>
        </property>
      </activation>
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugin</groupId>
            <artifactId>maven-gpg-plugin</artifactId>
            <version>1.0</version>
            <executions>  
              <execution>  
                <id>sign-artifacts</id>  
                <phase>verify</phase>  
                <goals>  
                  <goal>sign</goal>  
                </goals>  
              </execution>  
            </executions>  
          </plugin>         
        </plugins>
      </build>
    </profile>
  </profiles>
- 最后需要一提的是，由于一个已知的Maven Release lugin的Bug，release：perform执行过程中签名可能会导致进程永久挂起。 为了避免该情况， 用户需要为Maven ReleasePlugin提供mavenExecutorId配置:
...
- 至此，一个较为规范的自动化签名配置就完成了。当执行release：perform发布项目版本的时候，maven-gpg-plugin会被自动调用对构件进行签名。当然，这个时候你需要根据命令行提示输入私钥密码。

Chapter14 灵活的构建
- 一个优秀的构建系统必须足够灵活，它应该能够让项目在不同的环境下都能成功地构建。
- 例如，典型的项目都会有开发环境、测试环境和产品环境，这些环境的数据库配置不尽相同，那么项目构建的时候就需要能够识别所在的环境并使用正确的配置。
- 还有一种常见的情况是，项目开发了大量的集成测试，这些测试运行起来非常耗时，不适合在每次构建项目的时候都运行，因此需要一种手段能让我们在特定的时候才激活这些集成测试。
- Maven为了支持构建的灵活性，内置了三大特性，即属性、Profile和资源过滤。本章介绍如何合理使用这些特性来帮助项目自如地应对各种环境。
- Maven属性
前面的章节已经简单介绍过Maven属性的使用，使用Maven属性归类依赖: 
<properties>
    <springframework.version>2.5.6</springframework.version>
</properties>
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${springframework.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${springframework.version}</version>
    </dependency>   
    ...
</dependencies>
- 这可能是最常见的使用Maven属性的方式，通过<properties>元素用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用＄{属性名称}的方式引用该属
性，这种做法的最大意义在于消除重复。
- 这不是Maven属性的全部，事实上这只是6类Maven属性中的一类而已。这6类属性分别为：
1) 内置属性： ${basedir}表示项目根目录，即包含pom.xml文件的目录；${version}表示项目版本。
2) POM属性： 用户可以使用该类属性引用POM文件中对应元素的值。例如＄{project.artifactId}就对应了<project><artifactId>元素的值，常用的POM属性包括：
- ${project.build.sourceDirectory}：项目的主源码目录，默认为src/main/java/。
- ${project.build.testSourceDirectory}：项目的测试源码目录，默认为src/test/java/。
- ${project.build.directory}：项目构建输出目录，默认为target/。
- ${project.outputDirectory}：项目主代码编译输出目录，默认为target/classes/。
- ${project.testOutputDirectory}：项目测试代码编译输出目录，默认为target/test-classes/。
- ${project.groupId}：项目的groupId。
- ${project.artifactId}：项目的artifactId。
- ${project.version}：项目的version，与${version}等价。
- ${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}。
- 这些属性都对应了一个POM元素，它们中一些属性的默认值都是在超级POM中定义的.
3) 自定义属性： 用户可以在POM的<properties>元素下自定义Maven属性。
<properties>
  <my.prop>hello</my.prop>
</properties>
- 然后在POM中其他地方使用${my.prop}的时候会被替换成hello。
4) Settings属性： 
- 与POM属性同理，用户使用以settings.开头的属性引用settings.xml文件中XML元素的值，如常用的＄{settings.localRepository}指向用户本地仓库的地址。
5)Java系统属性： 
- 所有Java系统属性都可以使用Maven属性引用，例如＄{user.home}指向了用户目录。用户可以使用mvn help：system查看所有的Java系统属性。
6)环境变量属性： 
- 所有环境变量都可以使用以env.开头的Maven属性引用。例如＄{env.JAVA_HOME}指代了JAVA_HOME环境变量的值。用户可以使用mvn help：system
查看所有的环境变量。正确使用这些Maven属性可以帮助我们简化POM的配置和维护工作，下面列举几个常见的Maven属性使用样例。
- 在一个多模块项目中，模块之间的依赖比较常见，这些模块通常会使用同样的groupId和version。因此这个时候就可以使用POM属性:
  <dependencies>
    <dependency>
        <groupId>${project.groupId}</groupId>
        <artifactId>spring-core</artifactId>
        <version>${project.artifactId}</version>
    </dependency>
    <dependency>
        <groupId>${project.groupId}</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${project.artifactId}</version>
    </dependency> 
- 当前的模块依赖于account-email和account-persist，这三个模块使用同样的groupId和version，因此可以在依赖配置中使用POM属性${project.groupId}和＄{project.version}，表示这两个依赖的groupId和version与当前模块一致。这样，当项目版本升级的时候，就不再需要更改依赖的版本了。
- 大量的Maven插件用到了Maven属性，这意味着在配置插件的时候同样可以使用Maven属性来方便地自定义插件行为。
- 例如从10.6节我们知道，maven-surefire-plugin运行后默认的测试报告目录为target/surefire-reports，这实际上就是＄{project.build.directory}/surefire-reports， 如果查阅该插件的文档，会发现该插件提供了reportsDirectory参数来配置测试报告目录。因此如果想要改变测试报告目录，例如改成target/test-reports:
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>2.5</version>
    <configuration>
        <reportsDirectory>${project.build.directory}/test-reports</reportsDirectory>
    </configuration>
</plugin>
- 从上面的内容中可以看到，Maven属性能让我们在POM中方便地引用项目环境和构建环境的各种十分有用的值，这是创建灵活构建的基础。
- 下面将会结合profile和资源过滤，展示Maven能够为构建提供的更多的可能性。

#构建环境的差异
- 在不同的环境中，项目的源码应该使用不同的方式进行构建，最常见的就是数据库配置了。 例如在开发的过程中，有些项目会在src/main/resources/目录下放置带有如下内容的数据库配置文件：
database.jdbc.driverClass=com.sql.jdbc.Driver
database.jdbc.connectionURL=jdbc:mysql://localhost:3306/test
database.jdbc.username=dev  
database.jdbc.password=dev-pwd

可当测试人员想要构建项目产品并进行测试的时候，他们往往需要使用不同的数据库。这时的数据库配置文件可能是这样的：  
database.jdbc.driverClass=com.sql.jdbc.Driver
database.jdbc.connectionURL=jdbc:mysql://192.168.1.100:3306/test
database.jdbc.username=test  
database.jdbc.password=test-pwd
- 连接数据库的URL、用户名和密码都发生了变化，类似地，当项目被发布到产品环境的时候，所使用的数据库配置又是另外一套了。
- 比较原始的做法是，使用与开发环境一样的构建，然后在测试或者发布产品之前再手动更改这些配置。这是可行的，也是比较常见的，但肯定不是最好的方法。
- 本书已经不止一次强调，手动往往就意味着低效和错误，因此需要找到一种方法，使它能够自动地应对构建环境的差异。
- Maven的答案是针对不同的环境生成不同的构件。也就是说，在构建项目的过程中，Maven就已经将这种差异处理好了。

#资源过滤 <Test> <Test Done>
- 为了应对环境的变化，首先需要使用Maven属性将这些将会发生变化的部分提取出来。在上一节的数据库配置中，连接数据库使用的驱动类、URL、用户名和密码都
可能发生变化，因此用Maven属性取代它们：
database.jdbc.driverClass=${db.driver}
database.jdbc.connectionURL=${db.url}
database.jdbc.username=${db.username}  
database.jdbc.password=${db.password}
- 这里定义了4个Maven属性：db.driver、db.url、db.username和db.password，它们的命名是任意的，读者可以根据自己的实际情况定义最合适的属性名称。
- 既然使用了Maven属性，就应该在某个地方定义它们。自定义Maven属性后，这里要做的是使用一个额外的profile将其包裹:
- 针对开发环境的数据库配置：
<profiles>
    <profile>
      <id>dev</id>
      <properties>
          <db.driver>com.sql.jdbc.Driver</db.driver>
          <db.url>jdbc:mysql://localhost:3306/test</db.url>
          <db.username>dev</db.username>  
          <db.password>dev-pwd</db.password>
      </properties>
    </profile>
  </profiles>
- Maven属性定义与直接在POM的properties元素下定义并无二致，这里只是使用了一个id为dev的profile，其目的是将开发环境下的配置与其他环境区别
开来。
- 有了属性定义，配置文件中也使用了这些属性，一切OK了吗？还不行。
- Maven属性默认只有在POM中才会被解析。也就是说，＄{db.username}放到POM中会变成test，但是如果放到src/main/resources/目录下的文件中，构建的时候它将仍然还是＄{db.username}。
- 因此，需要让Maven解析资源文件中的Maven属性。
- 资源文件的处理其实是maven-resources-plugin做的事情，它默认的行为只是将项目主资源文件复制到主代码编译输出目录中， 将测试资源文件复制到测试代码编译输出目录中。
- 不过只要通过一些简单的POM配置，该插件就能够解析资源文件中的Maven属性，即开启资源过滤。
- Maven默认的主资源目录和测试资源目录的定义是在超级POM中)。要为资源目录开启过滤，只要在此基础上添加一行filtering配置即可，
    <resources>
      <resource>
        <directory>${project.basedir}/src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
    </resources>
- 为测试资源目录开启了过滤。
    <testResources>
      <testResource>
        <directory>${project.basedir}/src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
- 读者可能还会从上述代码中意识到，主资源目录和测试资源目录都可以超过一个，虽然会破坏Maven的约定，但Maven允许用户声明多个资源目录，并且为每个资源目
录提供不同的过滤配置
- 配置多个资源目录:
    <resources>
      <resource>
        <directory>${project.basedir}/src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
      <resource>
        <directory>${project.basedir}/src/main/sql</directory>
        <filtering>false</filtering>
      </resource>
    </resources>
- 配置了两个资源目录，其中src/main/resources开启了过滤，而src/main/sql没有启用过滤。
- 到目前为止一切基本就绪了，我们将数据库配置的变化部分提取成了Maven属性，在POM的profile中定义了这些属性的值，并且为资源目录开启了属性过滤。最后，只
需要在命令行激活profile，Maven就能够在构建项目的时候使用profile中属性值替换数据库配置文件中的属性引用。运行命令如下：mvn clean install -Pdev
- mvn的-P参数表示在命令行激活一个profile。这里激活了id为dev的profile。构建完成后，输出目录中的数据库配置就是开发环境的配置了：
database.jdbc.driverClass=com.sql.jdbc.Driver
database.jdbc.connectionURL=jdbc:mysql://localhost:3306/test
database.jdbc.username=dev  
database.jdbc.password=dev-pwd

#Maven Profile <Test> <Test Done>
- 从前面内容我们看到，不同环境的构建很可能是不同的，典型的情况就是数据库的配置。
- 除此之外，有些环境可能需要配置插件使用本地文件，或者使用特殊版本的依赖，或者需要一个特殊的构件名称。
- 要想使得一个构建不做任何修改就能在任何环境下运行，往往是不可能的。
- 为了能让构建在各个环境下方便地移植，Maven引入了profile的概念。
- profile能够在构建的时候修改POM的一个子集，或者添加额外的配置元素。
- 用户可以使用很多方式激活profile，以实现构建在不同环境下的移植。

#针对不同环境的profile
继续数据库差异为例，引入了一个针对开发环境的profile，类似地，可以加入测试环境和产品环境的profile:
<profiles>
    <profile>
      <id>dev</id>
      <properties>
        <db.driver>com.sql.jdbc.Driver</db.driver>
        <db.url>jdbc:mysql://localhost:3306/test</db.url>
        <db.username>dev</db.username>
        <db.password>dev-pwd</db.password>
      </properties>
    </profile>
    <profile>
      <id>test</id>
      <properties>
        <db.driver>com.sql.jdbc.Driver</db.driver>
        <db.url>jdbc:mysql://192.168.1.100:3306/test</db.url>
        <db.username>test</db.username>
        <db.password>test-pwd</db.password>
      </properties>
    </profile>
  </profiles>
- 同样的属性在两个profile中的值是不一样的，dev profile提供了开发环境数据库的配置，而test profile提供的是测试环境数据库的配置。 类似地，还可以添加一个基于产品环境数据库配置的profile.
- 开发人员可以在使用mvn命令的时候在后面加上-Pdev激活dev profile，而测试人员可以使用-Ptest激活test profile。
mvn clean install -Pdev
mvn clean install -Ptest

#激活profile
- 为了尽可能方便用户，Maven支持很多种激活Profile的方式。
1.命令行激活: 用户可以使用mvn命令行参数-P加上profile的id来激活profile，多个id之间以逗号分隔。例如，下面的命令激活了dev-x和dev-y两个profile：
mvn clean install -Pdev-x,dev-y
2. settings文件显式激活
如果用户希望某个profile默认一直处于激活状态，就可以配置settings.xml文件的activeProfiles元素，表示其配置的profile对于所有项目都处于激活状态:
  <activeProfiles>
    <activeProfile>nexus</activeProfile>
  </activeProfiles>
- 用到这种方式默认激活了一个关于仓库配置的profile。
3.系统属性激活
- 用户可以配置当某系统属性存在的时候，自动激活profile:
    <profile>
      <activation>
        <property>
          <name>test</name>
        </property>
      </activation>
    </profile>
- 某系统属性存在且值确定时激活profile
    <profile>
      <activation>
        <property>
          <name>test</name>
          <value>x</value>
        </property>
      </activation>
    </profile>
- 用户可以在命令行声明系统属性:
mvn clean package -Dtest=x
- 因此，这其实也是一种从命令行激活profile的方法，而且多个profile完全可以使用同一个系统属性来激活。
4.操作系统环境激活
- Profile还可以自动根据操作系统环境激活，如果构建在不同的操作系统有差异，用户完全可以将这些差异写进profile，然后配置它们自动基于操作系统环境激活，
    <profile>
      <activation>
        <os>
          <name>Windows XP</name>
          <family>windows</family>
          <arch>x86</arch>
          <version>5.1.2600</version>
        </os>
      </activation>
    </profile>
- 这里family的值包括Windows、UNIX和Mac等，而其他几项name、arch、version，用户可以通过查看环境中的系统属性os.name、os.arch、os.version获得。
- 5.文件存在与否激活
Maven能够根据项目中某个文件存在与否来决定是否激活profile:
<profile>
      <activation>
        <file>
          <missing>x.properties</missing>
          <exists>y.properties</exists>          
        </file>
      </activation>
    </profile>
6.默认激活
用户可以在定义profile的时候指定其默认激活:
<profile>
      <id>dev</id>
      <activation>
        <activeByDefault>true</activeDefault>
      </activation>
    </profile>
- 使用activeByDefault元素用户可以指定profile自动激活。不过需要注意的是，如果POM中有任何一个profile通过以上其他任意一种方式被激活了，所有的默认激活配置都会失效。
- 如果项目中有很多的profile，它们的激活方式各异，用户怎么知道哪些profile被激活了呢？maven-help-plugin提供了一个目标帮助用户了解当前激活的profile：
mvn help:active-profiles
- maven-help-plugin还有另外一个目标用来列出当前所有的profile：
mvn help:all-profiles

#14.4.3　profile的种类
- 根据具体的需要，可以在以下位置声明profile：
·pom.xml： 很显然，pom.xml中声明的profile只对当前项目有效。
·用户settings.xml： 用户目录下.m2/settings.xml中的profile对本机上该用户所有的Maven项目有效。
·全局settings.xml： Maven安装目录下conf/settings.xml中的profile对本机上所有的Maven项目有效。
- 为了不影响其他用户且方便升级Maven，用户应该选择配置用户范围的settings.xml，避免修改全局范围的settings.xml文件。也正是因为这个原因，一
般不会在全局的settings.xml文件中添加profile。
- 可供pom中profile使用的元素非常多，在pom profile中用户可以修改或添加仓库、插件仓库以及部署仓库地址；- 可以修改或者添加项目依赖；可以修改聚合项目的聚合配置；可以自由添加或修改Maven属性；添加或修改项目报告配置；pom profile还可以添加或修改插件配置、 项目资源目录和测试资源目录配置以及项目构件的默认名称。
<project>  
    <profiles>  
        <profile>  
            <build>  
                <defaultGoal>...</defaultGoal>  
                <finalName>...</finalName>  
                <resources>...</resources>  
                <testResources>...</testResources>  
                <plugins>...</plugins>  
            </build>  
            <reporting>...</reporting>  
            <modules>...</modules>  
            <dependencies>...</dependencies>  
            <dependencyManagement>...</dependencyManagement>  
            <distributionManagement>...</distributionManagement>  
            <repositories>...</repositories>  
            <pluginRepositories>...</pluginRepositories>  
            <properties>...</properties>  
        </profile>  
    </profiles>  
</project>  
- 与pom.xml中的profile对应的，是其他三种外部的profile，由于无法保证它们能够随着特定的pom.xml一起被分发， 因此Maven不允许它们添加或者修改绝大部分的pom元素。举个简单的例子。
- 假设用户Jack在自己的settings.xml文件中配置了一个profile，为了让项目A构建成功，Jack在这个profile中声明几个依赖和几个插件，然后通过激活该
profile将项目构建成功了。但是，当其他人获得项目A的源码后，它们并没有Jack settings.xml中的profile，因此它们无法构建项目， 这就导致了构建的移植性问题。为了避免这种问题的出现，Maven不允许用户在settings.xml的profile中声明依赖或者插件。事实上，在pom.xml外部的profile只能够声明几个元素。
<project>
  <repositories></repositories>
  <pluginRepositories></pluginRepositories>
  <property></property>
</project>

#14.5　Web资源过滤
- 14.3节介绍了如何开启资源过滤，在Web项目中，资源文件同样位于src/main/resources/目录下，它们经处理后会位于WAR包的WEB-INF/classes目录下，这也是Java代码编译打包后的目录。
- 这类资源文件在打包过后位于应用程序的classpath中。
- Web项目中还有另外一类资源文件，默认它们的源码位于src/main/webapp/目录，经打包后位于WAR包的根目录。
- 例如，一个Web项目的css源码文件在src/main/webapp/css/目录，项目打包后可以在WAR包的css/目录下找到对应的css文件。这一类资源文件称
做web资源文件，它们在打包过后不位于应用程序的classpath中。
- 与一般的资源文件一样，web资源文件默认不会被过滤。开启一般资源文件的过滤也不会影响到web资源文件。
- 不过有的时候，我们可能希望在构建项目的时候，为不同的客户使用不一样的资源文件（例如客户的logo图片不同，或者css主题不同）。
- 这时可以在web资源文件中使用Maven属性，例如用${client.logo}表示客户的logo图片，用${client.theme}表示客户的css主题。然后使用profile分别定义这些Maven属性的值:
<profiles>
    <profile>
      <id>client-a</id>
      <properties>
        <client.logo>a.jpg</client.logo>
        <client.theme>red</client.theme>
      </properties>
    </profile>
    <profile>
      <id>client-b</id>
      <properties>
        <client.logo>b.jpg</client.logo>
        <client.theme>blue</client.theme>
      </properties>
    </profile>
  </profiles>
- 最后需要配置maven-war-plugin对src/main/webapp/这一web资源目录开启过滤
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-war-plugin</artifactId>
  <version>2.1-beta-1</version>
  <configuration>
    <webResources>
      <resource>
        <filtering>true</filtering>
        <dictionary>src/main/webapp</dictionary>
        <includes>
          <include>**/*.css</include>
          <include>**/*.js</include>
        </includes>
      </resource>
    </webResources>
  </configuration>
</plugin>
- 代码中声明web资源目录src/main/webapp（这也是默认的web资源目录），然后配置filtering开启过滤，并且使用includes指定要过滤的文件，这里是所有css和
js文件。
- 读者可以模仿上述配置添加额外的web资源目录，选择是否开启过滤，以及包含或者排除一些该目录下的文件。
- 配置完成后，可以选择激活某个profile进行构建:
mvn clean install -Pclinet-a，告诉web资源文件使用logo图片a.jpg，使用css主题red。

#14.6　在profile中激活集成测试
- 很多项目都有大量的单元测试和集成测试，单元测试的粒度较细，运行较快，
- 集成测试粒度较粗，运行比较耗时。
- 在构建项目或者做持续集成的时候，我们都应当尽量运行所有的测试用例，但是当集成测试比较多的时候，高频率地运行它们就会变得不现实。
- 因此有一种更为合理的做法。例如，每次构建时只运行所有的单元测试，因为这不会消耗太多的时间（可能小于5分钟），然后以一个相对低一点的频率执行所有集成测试（例如每天2次）。
- TestNG中组的概念能够很好地支持单元测试和集成测试的分类标记。例如，可以使用如下的标注表示一个测试方法属于单元测试：
@Test(groups={"unit"})
- 然后使用类似的标注表示某个测试方法为集成测试：
@Test(groups={"integration"})
- 在profile中配置执行TestNG测试组:

使用上述方法可以很方便清晰地声明每个测试方法所属的类别。下面的工作就是告诉Maven默认只执行所有的单元测试，只在特定的时候才执行集成测试，见代码清
单14-20所示。
    <build>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.5</version>
          <configuration>
            <groups>unit</groups>
          </configuration>
        </plugin>
      </plugins>
    </build>
    <profiles>
      <profile>
        <id>full</id>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.5</version>
          <configuration>
            <groups>unit,integration</groups>
          </configuration>
        </plugin>
      </profile>
    </profiles>
- 配置了maven-surefire-plugin执行unit测试组，也就是说默认Maven只会执行单元测试。
- 如果想要执行集成测试，就需要激活full profile，在这个profile中配置了maven-surefire-plugin执行unit和integration两个测试组。
- 有了上述配置，用户就可以根据实际情况配置持续集成服务器。例如，每隔15分钟检查源码更新，如有更新则进行一次默认构建，即只包含单元测试。
- 此外，还可以配置一个定时的任务。例如，每天执行两次，执行一个激活full profile的构建，以包含所有的集成测试。
- 从该例中可以看到，profile不仅可以用来应对不同的构建环境以保持构建的可移植性，还可以用来分离构建的一些较耗时或者耗资源的行为，并给予更合适的构建频
率。
- 项目构建过程中一个常常需要面对的问题就是不同的平台环境差异，这可能是操作系统的差异、开发平台和测试平台的差异、不同客户之间的差异。
- 为了应对这些差异，Maven提供了属性、资源过滤以及profile三大特性。
- Maven用户可以在POM和资源文件中使用Maven属性表示那些可能变化的量，通过不同profile中的属性值和资源过滤特性为不同环境执行不同的构建。
- 需要区分Web项目中一般资源文件和web资源文件，前者是通过maven-resources-plugin处理的，而后者通过maven-war-plugin处理。
- 介绍了profile，包括各种类别profile的特点，以及激活profile的多种方式。

第15章　生成项目站点
- Maven不仅仅是一个自动化构建工具和一个依赖管理工具，它还能够帮助聚合项目信息，促进团队间的交流。
- POM可以包含各种项目信息，如项目描述、版本控制系统地址、缺陷跟踪系统地址、许可证信息、开发者信息等。
- 用户可以让Maven自动生成一个Web站点，以Web的形式发布这些信息。
- 此外，Maven社区提供了大量插件，能让用户生成各种各样的项目审查报告，包括测试覆盖率、静态代码分析、代码变更等。

#15.1　最简单的站点
Maven 3用户必须使用3.x版本的maven-site-plugin:
  <pluginManagement>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-site-plugin</artifactId>
        <version>3.0-beta-1</version>        
      </plugin>
    </plugins>
  </pluginManagement>

- 待Maven运行完毕后，可以在项目的target/site/目录下找到Maven生成的站点文件，包括dependencies.html、dependency-convergence.html、 index.html等文件和css、images文件夹。
- 从这些文件及文件夹的名字中猜到其中的内容：css和images文件夹是用来存放站点相关的图片和css文件的，其他html文件基本对应了一项项目信息，如
dependencies.html包含了项目依赖信息，license.html包含了项目许可证信息。index.html则是站点的主页面
- 左边导航栏的下方包含了各类项目信息的链接，包括持续集成、依赖、问题追踪、邮件列表、团队、源码库等。
- 如果这是一个聚合项目，导航栏的上方还会包含子模块的链接，但是如果单击这些链接，将无法转到子模块的项目页面。这是由于多模块Maven项目本身的目录结构
导致的。
- 如果将站点发布到服务器上，该问题会自然消失。如果想在本地查看结构正确的站点，则可以maven-site-plugin的stage目标，将站点预发布至某个本地临时目录
下。例如：
mvn site:stage -DstagingDirectory=~\tmp
- site生命周期有四个阶段，它们分别为pre-site、site、post-site和site-deploy。
- 其中，pre-site和post-site默认没有绑定任何插件目标，可以说它们是预留给用户做一些站点生成之前及之后的处理的；site阶段绑定到了maven-site-plugin的site目标，该目标负责生成项目站点，
- 因此之前使用简单的mvn site命令就能直接生成项目站点；site-deploy目标绑定了maven-site-plugin的deploy目标，该目标负责将站点部署至远程服务器。

#15.2　丰富项目信息
- 在15.1节中可以看到，在默认情况下Maven生成的站点包含了很多项目信息链接，这其实是由一个名为maven-project-info-reports-plugin的插件生成的。
- 在Maven 3中，该插件的配置内置在maven-site-plugin中，
- 该插件会基于POM配置生成下列项目信息报告：
·关于 （about）：项目描述。
·持续集成 （Continuous Integration）：项目持续集成服务器信息。
·依赖 （Dependencies）：项目依赖信息，包括传递性依赖、依赖图、依赖许可证以及依赖文件的大小、所包含的类数目等。
·依赖收敛 （Dependency Convergence）：只针对多模块项目生成，提供一些依赖健康状况分析，如各模块使用的依赖版本是否一致、项目中是否有SNAPSHOT依赖。
·依赖管理 （Dependency Management）：基于项目的依赖管理配置生成的报告。
·问题追踪 （Issue Tracking）：项目的问题追踪系统信息。
·邮件列表 （Mailing Lists）：项目的邮件列表信息。
·插件管理 （Plugin Management）：项目所使用插件的列表。
·项目许可证 （Project License）：项目许可证信息。
·项目概述 （Project Summary）：项目概述包括坐标、名称、描述等。
·项目团队 （Project Team）：项目团队信息。
·源码仓库 （Source Repository）：项目的源码仓库信息。
- 上述有些项是根据项目已有的依赖和插件配置生成的。例如，依赖这一项就很有意思，除了依赖坐标、传递性依赖以及依赖图，可以使用maven-dependency-plugin生成
的信息之外，报告还有依赖文件细节的信息，这里详细罗列了每个依赖文件的名称、大小、所包含文件数目、类数目、包数目和JDK版本等信息，
- 依赖相关的项是基于POM的dependencies和dependencyManagement元素生成的，类似地，其他项也都有其对应的POM元素。Maven不会凭空生成信息，只有用户在POM
中提供了相关配置后，站点才有可能包含这些信息的报告。
- 为了让站点包含完整的项目信息，需配置POM:
....
- 类似的项目信息报告读者可以在很多的开源项目中看到，使用Maven站点来一致化开源项目的信息展现方式无疑为用户获取信息提供了便利。
有些时候，用户可能不需要生成某些项目信息项，例如你可能没有邮件列表或者不想在站点中公开源码仓库信息，这时可以配置maven-project-info-reports-plugin选择性地生成信息项:
...

#15.3　项目报告插件
- 除了默认的项目信息报告，Maven社区还提供了大量报告插件，只要稍加配置，用户就能让Maven自动生成各种内容丰富的报告。
- 下面介绍一些比较常用的报告插件。值得注意的是，报告插件在POM中配置的位置与一般的插件配置不同。一般的插件在<project><build><plugins>下配置，而报告插件在<project><reporting><plugins>下配置。
#15.3.1　JavaDocs
- 这可能是最简单、也最容易理解的报告插件了。maven-javadoc-plugin使用JDK的javadoc工具，基于项目的源代码生成JavaDocs文档:
...
- 左侧的导航栏有两个类别，Project Information包含了15.2节讲述的各类基本信息，Project Reports则包含其他插件生成的报告。 这里能看到maven-javadoc-plugin生成JavaDocs和Test JavaDocs文档，单击相应链接就能查看具体文档
- 在生成项目站点文档的时候，一个常见的问题是：用户往往只希望在聚合项目一次性生成融合了所有模块信息的文档，而不是为每个模块单独生成，原因就是为了方
便。用户总是希望在一个地方看到尽可能全面的信息，而非不停地单击链接。幸运的是，maven-javadoc-plugin考虑到了这一点，使用该插件的最新版本，用户无须任何额
外的配置，就能在聚合项目的站点中得到包含所有模块的JavaDocs

#15.3.2 Source Xref
如果能够随时随地地打开浏览器访问项目的最新源代码，那无疑会方便团队之间的交流。maven-jxr-plugin能够帮助我们完成这一目标，在生成站点的时候配置该插
件，Maven就会以Web页面的形式将Java源代码展现出来。该插件的配置:
...

若想在聚合模块整合所有的源码，则需添加额外的aggregate配置:

#15.3.3　CheckStyle
CheckStyle是一个用来帮助Java开发人员遵循编码规范的工具，能根据一套规则自动检查Java代码，使得团队能够方便地定义自己的编码规范。关于该工具的详细信息
可以访问http://checkstyle.sourceforge.net/ 进行了解。要让Maven在站点中生成CheckStyle报告，只需要配置maven-checkstyle-plugin
- 运行mvn site命令后，就能得到图15-7所示的CheckStyle报告。
- 默认情况下，maven-checkstyle-plugin会使用Sun定义的编码规范，读者能够选择其他预置的规则。也可以自定义规则，maven-checkstyle-plugin内置了四种规则：
·config/sun_checks.xml： Sun定义的编码规范（默认值）。
·config/maven_checks.xml： Maven社区定义的编码规范。
·config/turbine_checks.xml： Turbine定义的编码规范。
·config/avalon_checks.xml： Avalon定义的编码规范。
- 用户可以配置maven-checkstyle-plugin使用上述编码规范:
...
#15.3.4　PMD
- PMD是一款强大的Java源代码分析工具，它能够寻找代码中的问题，包括潜在的bug、无用代码、可优化代码、重复代码以及过于复杂的表达式。关于该工具的详细信
息可以访问http://pmd.sourceforge.net/ 进行了解.
- 要让Maven在站点中生成PMD报告，只需要配置maven-pmd-plugin如下：
...
- 除了PMD报告之外，maven-pmd-plugin还会生成一个名为CPD的报告，该报告中包含了代码拷贝粘贴的分析结果。
- PMD包含了大量的分析规则，读者可以访问http://pmd.sourceforge.net/rules/index.html 查看这些规则。PMD默认使用的规则为rulesets/basic.xml、rulesets/unusedcode.xml和rulesets/importss.xml。要使用其他的规则，可以配置maven-pmd-plugin插件:

#15.3.5　ChangeLog
- maven-changelog-plugin能够基于版本控制系统中就近的变更记录生成三份变更报告，它们分别为：
·Change Log： 基于提交的变更报告，包括每次提交的日期、文件、作者、注释等信息。
·Developer Activity： 基于作者的变更报告，包括作者列表以及每个作者相关的提交次数和涉及文件数目。
·File Activity： 基于文件的变更报告，包括变更的文件列表及每个文件的变更次数。
想要生成项目的变更报告，首先需要配置正确的SCM信息 [1] ，如下：
...
有了SCM配置，就可以配置maven-changelog-plugin生成变更报告
..

#15.3.6　Cobertura
- 10.6.2节已经介绍过用Cobertura生成测试覆盖率报告，现在介绍如何将该报告集成到项目站点中。
- 要在Maven站点中包含Cobertura测试覆盖率报告，只需要配置cobertura-maven-plugin。

#15.4　自定义站点外观
- Maven生成的站点非常灵活，除了本章前面提到的标准项目信息报告和其他插件生成的报告，用户还能够自定义站点的布局和外观。这些特性能让用户创建出更适合
自己的，更有个性的Maven站点。
#15.4.1　站点描述符
- 要自定义站点外观，用户必须创建一个名为site.xml的站点描述符文件，且默认该文件应该位于项目的src/site目录下。该站点描述符文件是由XML Schema约束定义的，
相关的xsd文件位于http://maven.apache.org/xsd/decoration-1.0.0.xsd 。

#15.6　国际化
- 对于广大欧美以外的用户来说，站点上难免需要添加一些本土的文字，如果没有特殊的配置，站点可能无法对其使用正确的字符集编码。本节以简体中文为例，介绍
如何生成本地化的Maven站点。
- 要生成正确的简体中文站点，用户首先需要确保项目所有的源码，包括pom.xml、site.xml以及apt文档等，都以UTF-8编码保存，各种编辑器和IDE都支持用户指定保存
文档的编码。图15-18就展示了Windows上用记事本保存文档时候如何指定UTF-8编码。
- 接下来要做的是告诉maven-site-plugin使用UTF-8编码读取所有源码及文档，并且同样使用UTF-8编码呈现站点html文档。这两点可以通过配置两个Maven属性实现，如
下：
<properties>
  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
</properties>
- project.build.sourceEncoding属性用来指定Maven用什么编码来读取源码及文档，而project.reporting.outputEncoding用来指定Maven用什么编码来呈现站点的html文档。
- 最后一步要做的是配置maven-site-plugin指定当地的语言，配置当地语言为简体中文zh_CN:
  <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-site-plugin</artifactId>
        <version>2.1.1</version>  
        <configuration>
            <locales>zh_CN</locales>
        </configuration>      
      </plugin>
    </plugins>
- 完成这些配置后，就能生成图15-19所示的中文站点。

15.7　部署站点
- 为了方便团队和用户得到必要的项目信息，我们需要将Maven站点部署到服务器上。Maven支持多种协议部署站点，包括FTP、SCP和DAV。
...

第18章　Archetype
- 可以将Archetype理解成Maven项目的模板，例如maven-archetype-quickstart就是最简单的Maven项目模板，只需要提供基本的元素（如groupId、artifactId及version等），它就能生成项目的基本结构及POM文件。
- 很多著名的开源项目（如AppFuse和Apache Wicket）都提供了Archetype方便用户快速创建项目。
- 如果你所在组织的项目都遵循一些通用的配置及结构，则也可以为其创建一个自己的Archetype并进行维护。使用Archetype不仅能让用户快速简单地创建项目；还可以鼓励大家遵循一些项目结构及配置约定。

#Maven Archetype Plugin
Archetype并不是Maven的核心特性，它也是通过插件来实现的，这一插件就是maven-archetype-plugin（http://maven.apache.org/archetype/maven-archetype-plugin/ ）。尽管它只是一个插件，但由于其使用范围非常广泛，主要的IDE（如Eclipse、NetBeans和IDEA）在集成Maven的时候都着重集成了archetype特性，以方便用户快速地创建Maven项目。

#使用Archetype的一般步骤
在Maven 3中，如果插件的版本未声明，Maven只会自动解析最新的发布版，因此用户不用担心引入快照版本带来的问题。
mvn archetype：generate
- 输入上述命令后，Archetype插件会输出一个Archetype列表供用户选择. 
- 这个列表来自于名为archetype-catalog.xml的文件，18.3节将对其进行深入解释。现在，用户需要选择自己想要使用的Archetype，然后输入其对应的编号。
- 由于Archetype只是一个模板，为了保持模板的通用性，它的很多重要内容都是可配置的。
- 因此，在用户选择了一个Archetype之后，下一步就需要提供一些基本的参数。主要有：
·groupId： 想要创建项目的groupId。
·artifactId： 想要创建项目的artifactId。
·version： 想要创建项目的version。
·package： 想要创建项目的默认Java包名。
上述参数是Archetype插件内置的，也是最常用和最基本的。用户在自己编写Archetype的时候，还可以声明额外的配置参数。根据Maven提示填写完配置参数之后，Archetype插件就能够生成项目的骨架了。

#批处理方式使用Archetype
- 有时候用户可能不希望以交互的方式使用Archetype，例如当创建Maven项目的命令在一段自动化的Shell脚本中的时候，交互的方式会破坏自动化。这时用户可以使用
mvn命令的-B选项，要求maven-archetype-plugin以批处理的方式运行。
- 用户还必须显式地声明要使用的Archetype坐标信息，以及要创建项目的groupId、artifactId、version、package等信息
- 该例中的Archetype的坐标为org.apache.maven.archetypes：maven-archetype-quckstart：1.0，而真正要创建的项目坐标则为com.juvenxu.mvnbook：archetype-test：1.0-SNAPSHOT。

#常用Archetype介绍
- 在编写本书的时候，Maven中央仓库中已经包含了249个Archetype（详见http://repo1.maven.org/maven2/archetype-catalog.xml ）。此外，还有大量没有发布到中央仓库的Archetype分布在其他Maven仓库中。任何人都不可能全部了解它们，因此这里只介绍几个比较常用的Archetype。

1.maven-archetype-quickstart
maven-archetype-quickstart可能是最常用的Archetype，当maven-archetype-plugin提示用户选择Archetype的时候，它就是默认值。使用maven-archetype-quickstart生成的项目十分简单，基本内容如下：
·一个包含JUnit依赖声明的pom.xml。
·src/main/java主代码目录及该目录下一个名为App的输出“Hello World！”的类。
·src/test/java测试代码目录及该目录下一个名为AppTest的JUnit测试用例。
当需要创建一个全新的Maven项目时，就可以使用该Archetype生成项目后进行修改，省去了手工创建POM及目录结构的麻烦。

2.maven-archetype-webapp
这是一个最简单的Maven war项目模板，当需要快速创建一个Web应用的时候就可以使用它。使用maven-archetype-webapp生成的项目内容如下：
·一个packaging为war且带有JUnit依赖声明的pom.xml。
·src/main/webapp/目录。
·src/main/webapp/index.jsp文件，一个简单的Hello World页面。
·src/main/webapp/WEB-INF/web.xml文件，一个基本为空的Web应用配置文件。

3.AppFuse Archetype
- AppFuse是一个集成了很多开源工具的项目，它由Matt Raible开发，旨在帮助Java编程人员快速高效地创建项目。AppFuse本身使用Maven构建，它的核心其实就是一个
项目的骨架，是包含了持久层、业务层及展现层的一个基本结构。
- 在AppFuse 2.x中，已经集成了大量流行的开源工具，如Spring、Struts 2、JPA、JSF、Tapestry等。
AppFuse为用户提供了大量Archetype，以方便用户快速创建各种类型的项目，它们都使用同样的groupId org.appfuse。针对各种展现层框架分别为：
·appfuse-*-jsf： 基于JSF展现层框架的Archetype。
·appfuse-*-spring： 基于Spring MVC展现层框架的Archetype。
·appfuse-*-struts： 基于Struts 2展现层框架的Archetype。
·appfuse-*-tapestry： 基于Tapestry展现层框架的Archetype。
每一种展现层框架都有3个Archetype，分别为light、basic和modular。其中，light类型的Archetype只包含最简单的骨架；basic类型的Archetype则包含了一些用户管理及安全方面的特性；modular类型的Archetype会生成多模块的项目，其中的core模块包含了持久层及业务层的代码，而Web模块则是展现层的代码。
更多关于AppFuse Archetype的信息，读者可以访问其官方的快速入门手册：http://appfuse.org/display/apf/appfuse+quickstart 。