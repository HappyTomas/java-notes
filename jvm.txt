1) jvm
1.1) stack：存放thread， thread has program counter and stack - frame - local variables, return values, operand, constant reference
1.2) heap
1.3) Non heap
1.4) Class Data (Constants + Method)

2) 线程
2.1) 这里所说的线程指程序执行过程中的一个线程实体。
2.2) JVM 允许一个应用并发执行多个线程。
2.2) 线程获取资源：线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。
2.3) 当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。run() 返回时，被处理未捕获异常，原生线程将确认由于它的结束是否要终止 JVM 进程（比如这个线程是最后一个非守护线程）。
2.4) 当线程结束时，会释放原生线程和 Java 线程的所有资源。

3) JVM 系统线程
3.1) 这些后台线程与触发 public static void main(String[]) 
函数的主线程以及主线程创建的其他线程一起运行。
VM thread， 周期性线程（timer/interruption）， GC， Compiler(runtime compiling into bytecode)， signalling

4) 程序计数器（PC）: 当前指令（或操作码）的地址，本地指令除外。
- 如果当前方法是 native 方法，那么PC 的值为 undefined。
- 所有的 CPU 都有一个 PC，典型状态下，每执行一条指令 PC 都会自增，因此 PC 存储了指向下一条要被执行的指令地址。
- JVM 用 PC 来跟踪指令执行的位置，PC 将实际上是指向方法区（Method Area）的一个内存地址。

5) 栈（Stack）
- 每个线程拥有自己的栈，栈包含每个方法执行的栈帧。
- 栈是一个后进先出（LIFO）的数据结构，因此当前执行的方法在栈的顶部。
- 每次方法调用时，一个新的栈帧创建并压栈到栈顶。
- 当方法正常返回或抛出未捕获的异常时，栈帧就会出栈。
- 除了栈帧的压栈和出栈，栈不能被直接操作。
- 所以可以在堆上分配栈帧，并且不需要连续内存。

6) Native栈
并非所有的 JVM 实现都支持本地（native）方法，那些提供支持的 JVM 般都会为每个线程创建本地方法栈。
如果 JVM 用 C-linkage 模型实现 JNI（Java Native Invocation），那么本地栈就是一个 C 的栈。在这种情况下，本地方法栈的参数顺序、返回值和典型的 C 程序相同。本地方法一般来说可以（依赖 JVM 的实现）反过来调用 JVM 中的 Java 方法。这种 native 方法调用 Java 会发生在栈（一般是 Java 栈）上；线程将离开本地方法栈，并在 Java 栈上开辟一个新的栈帧。

7) 栈的限制
- 栈可以是动态分配也可以固定大小。
- 如果线程请求一个超过允许范围的空间，就会抛出一个StackOverflowError。
- 如果线程需要一个新的栈帧，但是没有足够的内存可以分配，就会抛出一个 OutOfMemoryError。

8) 栈帧（Frame）
- 每次方法调用都会新建一个新的栈帧并把它压栈到栈顶。当方法正常返回或者调用过程中抛出未捕获的异常时，栈帧将出栈。
- 每个栈帧包含：
局部变量数组
返回值
操作数栈
类当前方法的运行时常量池引用

9) 局部变量数组 (local variables)
- 局部变量数组包含了方法执行过程中的所有变量，包括 this 引用、所有方法参数、其他局部变量。
- 对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置0保留为 this。
- 有下面这些局部变量：boolean, byte, char, long, short, int, float, double, reference, returnAddress
- 除了 long 和 double 类型以外，所有的变量类型都占用局部变量数组的一个位置。long 和 double 需要占用局部变量数组两个连续的位置，因为它们是 64 位双精度，其它类型都是 32 位单精度。

10) 操作数栈
- 操作数栈在执行字节码指令过程中被用到，这种方式类似于原生 CPU 寄存器。
- 大部分 JVM 字节码把时间花费在操作数栈的操作上：入栈、出栈、复制、交换、产生消费变量的操作。
- 因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。

11) 动态链接
每个栈帧都有一个运行时常量池的引用。这个引用指向栈帧当前运行方法所在类的常量池。通过这个引用支持动态链接（dynamic linking）。

# 线程间共享


1) 堆 : 用来在运行时分配类实例、数组。
- 不能在栈上存储数组和对象。因为栈帧被设计为创建以后无法调整大小。
- 栈帧只存储指向堆中对象或数组的引用。
- 与局部变量数组（每个栈帧中的）中的原始类型和引用类型不同，对象总是存储在堆上以便在方法结束时不会被移除。
- 对象只能由垃圾回收器移除。
- 为了支持垃圾回收机制，堆被分为了下面三个区域：
新生代(经常被分为 Eden 和 Survivor)
老年代
永久代

# 内存管理
- 对象和数组永远不会显式回收，而是由垃圾回收器自动回收。
- 通常，过程是这样的
1) 新的对象和数组被创建并放入老年代。
2) Minor垃圾回收将发生在新生代。依旧存活的对象将从 eden 区移到 survivor 区。
3) Major垃圾回收一般会导致应用进程暂停，它将在三个区内移动对象。仍然存活的对象将被从新生代移动到老年代。
4) 每次进行老年代回收时也会进行永久代回收。它们之中任何一个变满时，都会进行回收。

# 非堆内存
- 非堆内存指的是那些逻辑上属于 JVM 一部分对象，但实际上不在堆上创建。
非堆内存包括：
- 永久代，包括：方法区, 驻留字符串（interned strings）
- 代码缓存（Code Cache）：用于编译和存储那些被 JIT 编译器编译成原生代码的方法。

# 即时编译（JIT）
- Java 字节码是解释执行的，但是没有直接在 JVM 宿主执行原生代码快。
- 为了提高性能，Oracle Hotspot 虚拟机会找到执行最频繁的字节码片段并把它们编译成原生机器码。
- 编译出的原生机器码被存储在非堆内存的代码缓存中。
- Hotspot虚拟机将权衡下面两种时间消耗：将字节码编译成本地代码需要的额外时间和解释执行字节码消耗更多的时间。

# 方法区
方法区存储了每个类的信息，比如：
Classloader 引用
运行时常量池
数值型常量
字段引用
方法引用
属性
字段数据
针对每个字段的信息
字段名
类型
修饰符
属性（Attribute）
方法数据
每个方法
方法名
返回值类型
参数类型（按顺序）
修饰符
属性
方法代码
每个方法
字节码
操作数栈大小
局部变量大小
局部变量表
异常表
每个异常处理器
开始点
结束点
异常处理代码的程序计数器（PC）偏移量
被捕获的异常类对应的常量池下标
- 所有线程共享同一个方法区，因此访问方法区数据的和动态链接的进程必须线程安全。
- 如果两个线程试图访问一个还未加载的类的字段或方法，必须只加载一次，而且两个线程必须等它加载完毕才能继续执行。

# 类文件结构
一个编译后的类文件包含下面的结构：
ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info contant_pool[constant_pool_count – 1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; }

#类加载器
- JVM 启动时会用 bootstrap 类加载器加载一个初始化类，
- 然后这个类会在public static void main(String[]) 调用之前完成链接和初始化。
- 执行这个方法会执行加载、链接、初始化需要的额外类和接口。
- 加载（Loading）是这样一个过程，找到代表这个类的 class 文件或根据特定的名字找到接口类型，然后读取到一个字节数组中。接着，这些字节会被解析检验它们是否代表一个 Class 对象并包含正确的 major、minor 版本信息。直接父类的类和接口也会被加载进来。这些操作一旦完成，类或者接口对象就从二进制表示中创建出来了。
链接（Linking）是校验类或接口并准备类型和父类父接口的过程。链接过程包含三步：校验（verifying）、准备（preparing）、部分解析（optionally resolving）。

- JVM 中有多个类加载器，分饰不同的角色。每个类加载器由它的父加载器加载。
- bootstrap 加载器除外，它是所有最顶层的类加载器。
- Bootstrap 加载器一般由本地代码实现，因为它在 JVM 加载以后的早期阶段就被初始化了。bootstrap 加载器负责载入基础的Java API，比如包含rt.jar。它只加载拥有较高信任级别的启动路径下找到的类，因此跳过了很多普通类需要做的校验工作。
- Extension 加载器加载了标准 Java 扩展 API 中的类，比如 security 的扩展函数。 System 加载器是应用的默认类加载器，比如从 classpath 中加载应用类。
- 用户自定义类加载器也可以用来加载应用类。
- 使用自定义的类加载器有很多特殊的原因：运行时重新加载类或者把加载的类分隔为不同的组，典型的用法比如web 服务器 Tomcat。

# 加速类加载
- 共享类数据（CDS）是Hotspot JVM 5.0 的时候引入的新特性。
- 在 JVM安装过程中，安装进程会加载一系列核心 JVM 类（比如rt.jar）到一个共享的内存映射区域。
- CDS 减少了加载这些类需要的时间，提高了 JVM 启动的速度，允许这些类被不同的 JVM实例共享，同时也减少了内存消耗。

# 方法区在哪里
- The Java Virtual Machine Specification Java SE 7 Edition 中写得很清楚：“尽管方法区逻辑上属于堆的一部分，简单的实现可以选择不对它进行回收和压缩。”。
- Oracle JVM 的 jconsle 显示方法区和 code cache 区被当做为非堆内存，
- 而 OpenJDK 则显示 CodeCache 被当做 VM 中对象堆（ObjectHeap）的一个独立的域。

# Classloader 引用
所有的类加载之后都包含一个加载自身的加载器的引用，反过来每个类加载器都包含它们加载的所有类的引用

# 运行时常量池
- JVM 维护了一个按类型区分的常量池，一个类似于符号表的运行时数据结构。
- Java 字节码需要数据。这个数据经常因为太大不能直接存储在字节码中，取而代之的是存储在常量池中，- 字节码包含这个常量池的引用。运行时常量池被用来上面介绍过的动态链接。
- 常量池中可以存储多种类型的数据：数字型, 字符串型, 类引用型, 域引用型, 方法引用

====================================================================================


# 运行数据区域
- Runtime Data Areas：当运行一个JVM示例时，系统将分配给它一块内存区域（这块内存区域的大小可以设置的），这一内存区域由JVM自己来管理。
- 从这一块内存中分出一块用来存储一些运行数据，例如创建的对象，传递给方法的参数，局部变量，返回值等等。分出来的这一块就称为运行数据区域。
- 运行数据区域可以划分为6大块：Java栈、程序计数寄存器（PC寄存器）、本地方法栈（Native Method Stack）、Java堆、方法区域、运行常量池（Runtime Constant Pool）。
- 运行常量池本应该属于方法区，但是由于其重要性，JVM规范将其独立出来说明。
- 其中，前面3各区域（PC寄存器、Java栈、本地方法栈）是每个线程独自拥有的，后三者则是整个JVM实例中的所有线程共有的。

二、PermGen（永久代）
1) 绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。
2) 这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。
3）前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。
4) 由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。
5) 最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

java -Xms16m -Xmn8m -Xmx16m org.atwjsw.HeapOomNock

java -XX:PermSize=8m -XX:MaxPermSize=8m org.atwjsw.PermGenOomMock

4) 在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。

5) Metaspace 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。
6) 元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

7) 除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

8) JDK 8 中永久代向元空间的转换。为什么要做这个转换？
8.1)字符串存在永久代中，容易出现性能问题和内存溢出。
8.2) 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
8.3) 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
8.4) Oracle 可能会将HotSpot 与 JRockit 合二为一。


# JVM调优总结（一）-- 一些概念
http://pengjiaheng.iteye.com/blog/518623

1) 数据类型
1.1）java虚拟机中，数据类型可以分为两类：基本类型和引用类型。
1.2） 基本类型的变量保存原始值，即：他代表的值就是数值本身；而引用类型的变量保存引用值。“引用值”代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。
1.3) 基本类型包括：byte,short,int,long,char,float,double,Boolean,returnAddress
1.4) 引用类型包括：类类型，接口类型和数组。

2) 堆与栈
2.1) 堆和栈是程序运行的关键，很有必要把他们的关系说清楚。
2.2)  栈是运行时的单位，而堆是存储的单位。
2.3) 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；
2.4) 堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
2.4) 在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。
2.5) 栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等； 而堆只负责存储对象信息。

3) 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。
第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。 一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。

4）堆中存什么？栈中存什么？
4.1） 堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。
4.2） 一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：））
4.3） 为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节

5) Java中的参数传递时传值呢？还是传引用？
5.1) Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用

6) hotspot虚拟机的默认堆大小如果未指定，他们是根据服务器物理内存计算而来的

client模式下，JVM初始和最大堆大小为：
在物理内存达到192MB之前，JVM最大堆大小为物理内存的一半，否则，在物理内存大于192MB，在到达1GB之前，JVM最大堆大小为物理内存的1/4，大于1GB的物理内存也按1GB计算，举个例子，如果你的电脑内存是128MB，那么最大堆大小就是64MB，如果你的物理内存大于或等于1GB，那么最大堆大小为256MB。
Java初始堆大小是物理内存的1/64，但最小是8MB。

server模式下：
与client模式类似，区别就是默认值可以更大，比如在32位JVM下，如果物理内存在4G或更高，最大堆大小可以提升至1GB，，如果是在64位JVM下，如果物理内存在128GB或更高，最大堆大小可以提升至32GB。

7) JVM documents: https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html

8) Tomcat JVM调优
http://blog.csdn.net/ye1992/article/details/9344807